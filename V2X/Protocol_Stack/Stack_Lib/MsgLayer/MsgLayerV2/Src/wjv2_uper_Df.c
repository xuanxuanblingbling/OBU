/**
* @file         :wjv2_uper_Df.c
* @brief        :数据帧相关函数的实现
* @details      :主要实现数据帧结构的编码实现
* @author       :huangsai  any question please send mail to huangsai@wanji,net.cn
* @date         :2020-12-17
* @version      :V1.0
* @copyright    :Copyright (c) 2020-2025  万集科技股份有限公司
**********************************************************************************
* @attention
* SDK版本：IMX6
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
**********************************************************************************
*/
/* 头文件包含 */
#include "wjv2_uper_Df.h"
#include "wjv2_uper_com.h"
/**
* @brief     WJV2_AccelerationSet4Way_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_AccelerationSet4Way_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_AccelerationSet4Way *pstruWjAccelerationSet4Way = (WJV2_STRU_AccelerationSet4Way *)pvoidWjDf;
    AccelerationSet4Way_t *pstruAsnAccelerationSet4Way = (AccelerationSet4Way_t *)pvoidAsnDf;
    if ((WJV2_MAX_ACCELERATION_SIZE < pstruWjAccelerationSet4Way->n32long) || (WJV2_MIN_ACCELERATION_SIZE > pstruWjAccelerationSet4Way->n32long))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjAccelerationSet4Way->n32long = %d",
                 pstruWjAccelerationSet4Way->n32long);
        return false;
    }
    pstruAsnAccelerationSet4Way->Long = pstruWjAccelerationSet4Way->n32long;
    if ((WJV2_MAX_ACCELERATION_SIZE < pstruWjAccelerationSet4Way->n32lat) || (WJV2_MIN_ACCELERATION_SIZE > pstruWjAccelerationSet4Way->n32lat))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjAccelerationSet4Way->n32lat = %d",
                 pstruWjAccelerationSet4Way->n32lat);
        return false;
    }
    pstruAsnAccelerationSet4Way->lat = pstruWjAccelerationSet4Way->n32lat;
    if ((WJV2_MAX_VERTICALACCELERATION_SIZE < pstruWjAccelerationSet4Way->n32vert) || (WJV2_MIN_VERTICALACCELERATION_SIZE > pstruWjAccelerationSet4Way->n32vert))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjAccelerationSet4Way->n32vert = %d",
                 pstruWjAccelerationSet4Way->n32vert);
        return false;
    }
    pstruAsnAccelerationSet4Way->vert = pstruWjAccelerationSet4Way->n32vert;
    if ((WJV2_MAX_YAWRATE_SIZE < pstruWjAccelerationSet4Way->n32yaw) || (WJV2_MIN_YAWRATE_SIZE > pstruWjAccelerationSet4Way->n32yaw))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjAccelerationSet4Way->n32yaw = %d",
                 pstruWjAccelerationSet4Way->n32yaw);
        return false;
    }
    pstruAsnAccelerationSet4Way->yaw = pstruWjAccelerationSet4Way->n32yaw;
    return true;
}
/**
* @brief     WJV2_AccelerationSet4Way_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_AccelerationSet4Way_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_AccelerationSet4Way *pstruWjAccelerationSet4Way = (WJV2_STRU_AccelerationSet4Way *)pvoidWjDf;
    AccelerationSet4Way_t *pstruAsnAccelerationSet4Way = (AccelerationSet4Way_t *)pvoidAsnDf;
    if ((WJV2_MAX_ACCELERATION_SIZE < pstruAsnAccelerationSet4Way->Long) || (WJV2_MIN_ACCELERATION_SIZE > pstruAsnAccelerationSet4Way->Long))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnAccelerationSet4Way->Long = %d",
                 pstruAsnAccelerationSet4Way->Long);
        return false;
    }
    pstruWjAccelerationSet4Way->n32long = pstruAsnAccelerationSet4Way->Long;
    if ((WJV2_MAX_ACCELERATION_SIZE < pstruAsnAccelerationSet4Way->lat) || (WJV2_MIN_ACCELERATION_SIZE > pstruAsnAccelerationSet4Way->lat))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnAccelerationSet4Way->lat = %d",
                 pstruAsnAccelerationSet4Way->lat);
        return false;
    }
    pstruWjAccelerationSet4Way->n32lat = pstruAsnAccelerationSet4Way->lat;
    if ((WJV2_MAX_VERTICALACCELERATION_SIZE < pstruAsnAccelerationSet4Way->vert) || (WJV2_MIN_VERTICALACCELERATION_SIZE > pstruAsnAccelerationSet4Way->vert))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnAccelerationSet4Way->vert = %d",
                 pstruAsnAccelerationSet4Way->vert);
        return false;
    }
    pstruWjAccelerationSet4Way->n32vert = pstruAsnAccelerationSet4Way->vert;
    if ((WJV2_MAX_YAWRATE_SIZE < pstruAsnAccelerationSet4Way->yaw) || (WJV2_MIN_YAWRATE_SIZE > pstruAsnAccelerationSet4Way->yaw))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnAccelerationSet4Way->yaw = %d",
                 pstruAsnAccelerationSet4Way->yaw);
        return false;
    }
    pstruWjAccelerationSet4Way->n32yaw = pstruAsnAccelerationSet4Way->yaw;
    return true;
}
/**
* @brief     WJV2_BrakeSystemStatus_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_BrakeSystemStatus_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_BrakeSystemStatus *pstruWjBrakeSystemStatus = (WJV2_STRU_BrakeSystemStatus *)pvoidWjDf;
    BrakeSystemStatus_t *pstruAsnBrakeSystemStatus = (BrakeSystemStatus_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (WJV2_PRESENT == pstruWjBrakeSystemStatus->u8brakePadelPresent)
    {
        pstruAsnBrakeSystemStatus->brakePadel = CALLOC(1, sizeof(BrakePedalStatus_t));
        if (NULL == pstruAsnBrakeSystemStatus->brakePadel)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        *(pstruAsnBrakeSystemStatus->brakePadel) = pstruWjBrakeSystemStatus->enumbrakePadel;
    }
    else
    {
        pstruAsnBrakeSystemStatus->brakePadel = NULL;
    }
    if (WJV2_PRESENT == pstruWjBrakeSystemStatus->u8wheelBrakesPresent)
    {
        pstruAsnBrakeSystemStatus->wheelBrakes = CALLOC(1, sizeof(BrakeAppliedStatus_t));
        if (NULL == pstruAsnBrakeSystemStatus->wheelBrakes)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        n32Ret = WJV2_BrakeAppliedStatus_DeEnc(pstruAsnBrakeSystemStatus->wheelBrakes, &(pstruWjBrakeSystemStatus->strbitwheelBrakes));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_BrakeAppliedStatus_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnBrakeSystemStatus->wheelBrakes = NULL;
    }
    if (WJV2_PRESENT == pstruWjBrakeSystemStatus->u8tractionPresent)
    {
        pstruAsnBrakeSystemStatus->traction = CALLOC(1, sizeof(TractionControlStatus_t));
        if (NULL == pstruAsnBrakeSystemStatus->traction)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        *(pstruAsnBrakeSystemStatus->traction) = pstruWjBrakeSystemStatus->enumtraction;
    }
    else
    {
        pstruAsnBrakeSystemStatus->traction = NULL;
    }
    if (WJV2_PRESENT == pstruWjBrakeSystemStatus->u8absPresent)
    {
        pstruAsnBrakeSystemStatus->abs = CALLOC(1, sizeof(AntiLockBrakeStatus_t));
        if (NULL == pstruAsnBrakeSystemStatus->abs)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        *(pstruAsnBrakeSystemStatus->abs) = pstruWjBrakeSystemStatus->enumabs;
    }
    else
    {
        pstruAsnBrakeSystemStatus->abs = NULL;
    }
    if (WJV2_PRESENT == pstruWjBrakeSystemStatus->u8scsPresent)
    {
        pstruAsnBrakeSystemStatus->scs = CALLOC(1, sizeof(StabilityControlStatus_t));
        if (NULL == pstruAsnBrakeSystemStatus->scs)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        *(pstruAsnBrakeSystemStatus->scs) = pstruWjBrakeSystemStatus->enumscs;
    }
    else
    {
        pstruAsnBrakeSystemStatus->scs = NULL;
    }
    if (WJV2_PRESENT == pstruWjBrakeSystemStatus->u8brakeBoostPresent)
    {
        pstruAsnBrakeSystemStatus->brakeBoost = CALLOC(1, sizeof(BrakeBoostApplied_t));
        if (NULL == pstruAsnBrakeSystemStatus->brakeBoost)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        *(pstruAsnBrakeSystemStatus->brakeBoost) = pstruWjBrakeSystemStatus->enumbrakeBoost;
    }
    else
    {
        pstruAsnBrakeSystemStatus->brakeBoost = NULL;
    }
    if (WJV2_PRESENT == pstruWjBrakeSystemStatus->u8auxBrakesPresent)
    {
        pstruAsnBrakeSystemStatus->auxBrakes = CALLOC(1, sizeof(AuxiliaryBrakeStatus_t));
        if (NULL == pstruAsnBrakeSystemStatus->auxBrakes)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        *(pstruAsnBrakeSystemStatus->auxBrakes) = pstruWjBrakeSystemStatus->enumauxBrakes;
    }
    else
    {
        pstruAsnBrakeSystemStatus->auxBrakes = NULL;
    }
    return true;
}
/**
* @brief     WJV2_BrakeSystemStatus_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_BrakeSystemStatus_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_BrakeSystemStatus *pstruWjBrakeSystemStatus = (WJV2_STRU_BrakeSystemStatus *)pvoidWjDf;
    BrakeSystemStatus_t *pstruAsnBrakeSystemStatus = (BrakeSystemStatus_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (NULL != pstruAsnBrakeSystemStatus->brakePadel)
    {
        pstruWjBrakeSystemStatus->enumbrakePadel = *(pstruAsnBrakeSystemStatus->brakePadel);
        pstruWjBrakeSystemStatus->u8brakePadelPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjBrakeSystemStatus->u8brakePadelPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnBrakeSystemStatus->wheelBrakes)
    {
        n32Ret = WJV2_BrakeAppliedStatus_DeDec(pstruAsnBrakeSystemStatus->wheelBrakes, &(pstruWjBrakeSystemStatus->strbitwheelBrakes));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_BrakeAppliedStatus_DeDec is err");
            return false;
        }
        pstruWjBrakeSystemStatus->u8wheelBrakesPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjBrakeSystemStatus->u8wheelBrakesPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnBrakeSystemStatus->traction)
    {
        pstruWjBrakeSystemStatus->enumtraction = *(pstruAsnBrakeSystemStatus->traction);
        pstruWjBrakeSystemStatus->u8tractionPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjBrakeSystemStatus->u8tractionPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnBrakeSystemStatus->abs)
    {
        pstruWjBrakeSystemStatus->enumabs = *(pstruAsnBrakeSystemStatus->abs);
        pstruWjBrakeSystemStatus->u8absPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjBrakeSystemStatus->u8absPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnBrakeSystemStatus->scs)
    {
        pstruWjBrakeSystemStatus->enumscs = *(pstruAsnBrakeSystemStatus->scs);
        pstruWjBrakeSystemStatus->u8scsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjBrakeSystemStatus->u8scsPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnBrakeSystemStatus->brakeBoost)
    {
        pstruWjBrakeSystemStatus->enumbrakeBoost = *(pstruAsnBrakeSystemStatus->brakeBoost);
        pstruWjBrakeSystemStatus->u8brakeBoostPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjBrakeSystemStatus->u8brakeBoostPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnBrakeSystemStatus->auxBrakes)
    {
        pstruWjBrakeSystemStatus->enumauxBrakes = *(pstruAsnBrakeSystemStatus->auxBrakes);
        pstruWjBrakeSystemStatus->u8auxBrakesPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjBrakeSystemStatus->u8auxBrakesPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_ConnectingLane_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_ConnectingLane_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ConnectingLane *pstruWjConnectingLane = (WJV2_STRU_ConnectingLane *)pvoidWjDf;
    ConnectingLane_t *pstruAsnConnectingLane = (ConnectingLane_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_LANEID_SIZE < pstruWjConnectingLane->n32lane) || (WJV2_MIN_LANEID_SIZE > pstruWjConnectingLane->n32lane))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjConnectingLane->n32lane = %d",
                 pstruWjConnectingLane->n32lane);
        return false;
    }
    pstruAsnConnectingLane->lane = pstruWjConnectingLane->n32lane;
    if (WJV2_PRESENT == pstruWjConnectingLane->u8maneuverPresent)
    {
        pstruAsnConnectingLane->maneuver = CALLOC(1, sizeof(AllowedManeuvers_t));
        if (NULL == pstruAsnConnectingLane->maneuver)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        n32Ret = WJV2_AllowedManeuvers_DeEnc(pstruAsnConnectingLane->maneuver, &(pstruWjConnectingLane->strbitmaneuver));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AllowedManeuvers_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnConnectingLane->maneuver = NULL;
    }
    return true;
}
/**
* @brief     WJV2_ConnectingLane_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_ConnectingLane_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ConnectingLane *pstruWjConnectingLane = (WJV2_STRU_ConnectingLane *)pvoidWjDf;
    ConnectingLane_t *pstruAsnConnectingLane = (ConnectingLane_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_LANEID_SIZE < pstruAsnConnectingLane->lane) || (WJV2_MIN_LANEID_SIZE > pstruAsnConnectingLane->lane))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnConnectingLane->lane = %d",
                 pstruAsnConnectingLane->lane);
        return false;
    }
    pstruWjConnectingLane->n32lane = pstruAsnConnectingLane->lane;
    if (NULL != pstruAsnConnectingLane->maneuver)
    {
        n32Ret = WJV2_AllowedManeuvers_DeDec(pstruAsnConnectingLane->maneuver, &(pstruWjConnectingLane->strbitmaneuver));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AllowedManeuvers_DeDec is err");
            return false;
        }
        pstruWjConnectingLane->u8maneuverPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjConnectingLane->u8maneuverPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_Connection_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_Connection_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Connection *pstruWjConnection = (WJV2_STRU_Connection *)pvoidWjDf;
    Connection_t *pstruAsnConnection = (Connection_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_NodeReferenceID_DfEnc(&(pstruAsnConnection->remoteIntersection), &(pstruWjConnection->struremoteIntersection));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfEnc is err");
        return false;
    }
    if (WJV2_PRESENT == pstruWjConnection->u8connectingLanePresent)
    {
        pstruAsnConnection->connectingLane = CALLOC(1, sizeof(struct ConnectingLane));
        if (NULL == pstruAsnConnection->connectingLane)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        n32Ret = WJV2_ConnectingLane_DfEnc(pstruAsnConnection->connectingLane, &(pstruWjConnection->struconnectingLane));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ConnectingLane_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnConnection->connectingLane = NULL;
    }
    if (WJV2_PRESENT == pstruWjConnection->u8phaseIdPresent)
    {
        pstruAsnConnection->phaseId = CALLOC(1, sizeof(PhaseID_t));
        if (NULL == pstruAsnConnection->phaseId)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        if ((WJV2_MAX_PHASEID_SIZE < pstruWjConnection->n32phaseId) || (WJV2_MIN_PHASEID_SIZE > pstruWjConnection->n32phaseId))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjConnection->n32phaseId = %d",
                     pstruWjConnection->n32phaseId);
            return false;
        }
        *(pstruAsnConnection->phaseId) = pstruWjConnection->n32phaseId;
    }
    else
    {
        pstruAsnConnection->phaseId = NULL;
    }
    return true;
}
/**
* @brief     WJV2_Connection_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_Connection_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Connection *pstruWjConnection = (WJV2_STRU_Connection *)pvoidWjDf;
    Connection_t *pstruAsnConnection = (Connection_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_NodeReferenceID_DfDec(&(pstruAsnConnection->remoteIntersection), &(pstruWjConnection->struremoteIntersection));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfDec is err");
        return false;
    }
    if (NULL != pstruAsnConnection->connectingLane)
    {
        n32Ret = WJV2_ConnectingLane_DfDec(pstruAsnConnection->connectingLane, &(pstruWjConnection->struconnectingLane));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ConnectingLane_DfDec is err");
            return false;
        }
        pstruWjConnection->u8connectingLanePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjConnection->u8connectingLanePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnConnection->phaseId)
    {
        if ((WJV2_MAX_PHASEID_SIZE < *(pstruAsnConnection->phaseId)) || (WJV2_MIN_PHASEID_SIZE > *(pstruAsnConnection->phaseId)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnConnection->phaseId) = %d",
                     *(pstruAsnConnection->phaseId));
            return false;
        }
        pstruWjConnection->n32phaseId = *(pstruAsnConnection->phaseId);
        pstruWjConnection->u8phaseIdPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjConnection->u8phaseIdPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_ConnectsToList_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_ConnectsToList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ConnectsToList *pstruWjConnectsToList = (WJV2_STRU_ConnectsToList *)pvoidWjDf;
    ConnectsToList_t *pstruAsnConnectsToList = (ConnectsToList_t *)pvoidAsnDf;
    Connection_t *pstruConnection_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_CONNECTION_LEN < pstruWjConnectsToList->u8ConnectionNum) || (WJV2_MIN_LIST_CONNECTION_LEN > pstruWjConnectsToList->u8ConnectionNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjConnectsToList->u8ConnectionNum = %d",
                 pstruWjConnectsToList->u8ConnectionNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjConnectsToList->u8ConnectionNum; u32i++)
    {
        pstruConnection_node = CALLOC(1, sizeof(Connection_t));
        if (NULL == pstruConnection_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_Connection_DfEnc(pstruConnection_node, &(pstruWjConnectsToList->struConnection[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Connection_DfEnc is err");
            FREEMEM(pstruConnection_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnConnectsToList->list), pstruConnection_node);
    }
    return true;
}
/**
* @brief     WJV2_ConnectsToList_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_ConnectsToList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ConnectsToList *pstruWjConnectsToList = (WJV2_STRU_ConnectsToList *)pvoidWjDf;
    ConnectsToList_t *pstruAsnConnectsToList = (ConnectsToList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_CONNECTION_LEN < pstruAsnConnectsToList->list.count) || (WJV2_MIN_LIST_CONNECTION_LEN > pstruAsnConnectsToList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnConnectsToList->list.count = %d",
                 pstruAsnConnectsToList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnConnectsToList->list.count; u32i++)
    {
        n32Ret = WJV2_Connection_DfDec(pstruAsnConnectsToList->list.array[u32i],
                                       &(pstruWjConnectsToList->struConnection[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Connection_DfDec is err");
            return false;
        }
    }
    pstruWjConnectsToList->u8ConnectionNum = (uint8_t)u32i;
    return true;
}
/**
* @brief     WJV2_DDateTime_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_DDateTime_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_DDateTime *pstruWjDDateTime = (WJV2_STRU_DDateTime *)pvoidWjDf;
    DDateTime_t *pstruAsnDDateTime = (DDateTime_t *)pvoidAsnDf;
    if (WJV2_PRESENT == pstruWjDDateTime->u8yearPresent)
    {
        pstruAsnDDateTime->year = CALLOC(1, sizeof(DYear_t));
        if (NULL == pstruAsnDDateTime->year)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_DYEAR_SIZE < pstruWjDDateTime->n32year) || (WJV2_MIN_DYEAR_SIZE > pstruWjDDateTime->n32year))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjDDateTime->n32year = %d",
                     pstruWjDDateTime->n32year);
            return false;
        }
        *(pstruAsnDDateTime->year) = pstruWjDDateTime->n32year;
    }
    else
    {
        pstruAsnDDateTime->year = NULL;
    }
    if (WJV2_PRESENT == pstruWjDDateTime->u8monthPresent)
    {
        pstruAsnDDateTime->month = CALLOC(1, sizeof(DMonth_t));
        if (NULL == pstruAsnDDateTime->month)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_DMONTH_SIZE < pstruWjDDateTime->n32month) || (WJV2_MIN_DMONTH_SIZE > pstruWjDDateTime->n32month))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjDDateTime->n32month = %d",
                     pstruWjDDateTime->n32month);
            return false;
        }
        *(pstruAsnDDateTime->month) = pstruWjDDateTime->n32month;
    }
    else
    {
        pstruAsnDDateTime->month = NULL;
    }
    if (WJV2_PRESENT == pstruWjDDateTime->u8dayPresent)
    {
        pstruAsnDDateTime->day = CALLOC(1, sizeof(DDay_t));
        if (NULL == pstruAsnDDateTime->day)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_DDAY_SIZE < pstruWjDDateTime->n32day) || (WJV2_MIN_DDAY_SIZE > pstruWjDDateTime->n32day))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjDDateTime->n32day = %d",
                     pstruWjDDateTime->n32day);
            return false;
        }
        *(pstruAsnDDateTime->day) = pstruWjDDateTime->n32day;
    }
    else
    {
        pstruAsnDDateTime->day = NULL;
    }
    if (WJV2_PRESENT == pstruWjDDateTime->u8hourPresent)
    {
        pstruAsnDDateTime->hour = CALLOC(1, sizeof(DHour_t));
        if (NULL == pstruAsnDDateTime->hour)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_DHOUR_SIZE < pstruWjDDateTime->n32hour) || (WJV2_MIN_DHOUR_SIZE > pstruWjDDateTime->n32hour))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjDDateTime->n32hour = %d",
                     pstruWjDDateTime->n32hour);
            return false;
        }
        *(pstruAsnDDateTime->hour) = pstruWjDDateTime->n32hour;
    }
    else
    {
        pstruAsnDDateTime->hour = NULL;
    }
    if (WJV2_PRESENT == pstruWjDDateTime->u8minutePresent)
    {
        pstruAsnDDateTime->minute = CALLOC(1, sizeof(DMinute_t));
        if (NULL == pstruAsnDDateTime->minute)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_DMINUTE_SIZE < pstruWjDDateTime->n32minute) || (WJV2_MIN_DMINUTE_SIZE > pstruWjDDateTime->n32minute))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjDDateTime->n32minute = %d",
                     pstruWjDDateTime->n32minute);
            return false;
        }
        *(pstruAsnDDateTime->minute) = pstruWjDDateTime->n32minute;
    }
    else
    {
        pstruAsnDDateTime->minute = NULL;
    }
    if (WJV2_PRESENT == pstruWjDDateTime->u8secondPresent)
    {
        pstruAsnDDateTime->second = CALLOC(1, sizeof(DSecond_t));
        if (NULL == pstruAsnDDateTime->second)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_DSECOND_SIZE < pstruWjDDateTime->n32second) || (WJV2_MIN_DSECOND_SIZE > pstruWjDDateTime->n32second))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjDDateTime->n32second = %d",
                     pstruWjDDateTime->n32second);
            return false;
        }
        *(pstruAsnDDateTime->second) = pstruWjDDateTime->n32second;
    }
    else
    {
        pstruAsnDDateTime->second = NULL;
    }
    if (WJV2_PRESENT == pstruWjDDateTime->u8offsetPresent)
    {
        pstruAsnDDateTime->offset = CALLOC(1, sizeof(DTimeOffset_t));
        if (NULL == pstruAsnDDateTime->offset)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_DTIMEOFFSET_SIZE < pstruWjDDateTime->n32offset) || (WJV2_MIN_DTIMEOFFSET_SIZE > pstruWjDDateTime->n32offset))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjDDateTime->n32offset = %d",
                     pstruWjDDateTime->n32offset);
            return false;
        }
        *(pstruAsnDDateTime->offset) = pstruWjDDateTime->n32offset;
    }
    else
    {
        pstruAsnDDateTime->offset = NULL;
    }
    return true;
}
/**
* @brief     WJV2_DDateTime_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_DDateTime_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_DDateTime *pstruWjDDateTime = (WJV2_STRU_DDateTime *)pvoidWjDf;
    DDateTime_t *pstruAsnDDateTime = (DDateTime_t *)pvoidAsnDf;

    if (NULL != pstruAsnDDateTime->year)
    {
        if ((WJV2_MAX_DYEAR_SIZE < *(pstruAsnDDateTime->year)) || (WJV2_MIN_DYEAR_SIZE > *(pstruAsnDDateTime->year)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnDDateTime->year) = %d",
                     *(pstruAsnDDateTime->year));
            return false;
        }
        pstruWjDDateTime->n32year = *(pstruAsnDDateTime->year);
        pstruWjDDateTime->u8yearPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDDateTime->u8yearPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnDDateTime->month)
    {
        if ((WJV2_MAX_DMONTH_SIZE < *(pstruAsnDDateTime->month)) || (WJV2_MIN_DMONTH_SIZE > *(pstruAsnDDateTime->month)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnDDateTime->month) = %d",
                     *(pstruAsnDDateTime->month));
            return false;
        }
        pstruWjDDateTime->n32month = *(pstruAsnDDateTime->month);
        pstruWjDDateTime->u8monthPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDDateTime->u8monthPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDDateTime->day)
    {
        if ((WJV2_MAX_DDAY_SIZE < *(pstruAsnDDateTime->day)) || (WJV2_MIN_DDAY_SIZE > *(pstruAsnDDateTime->day)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnDDateTime->day) = %d",
                     *(pstruAsnDDateTime->day));
            return false;
        }
        pstruWjDDateTime->n32day = *(pstruAsnDDateTime->day);
        pstruWjDDateTime->u8dayPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDDateTime->u8dayPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDDateTime->hour)
    {
        if ((WJV2_MAX_DHOUR_SIZE < *(pstruAsnDDateTime->hour)) || (WJV2_MIN_DHOUR_SIZE > *(pstruAsnDDateTime->hour)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnDDateTime->hour) = %d",
                     *(pstruAsnDDateTime->hour));
            return false;
        }
        pstruWjDDateTime->n32hour = *(pstruAsnDDateTime->hour);
        pstruWjDDateTime->u8hourPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDDateTime->u8hourPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDDateTime->minute)
    {
        if ((WJV2_MAX_DMINUTE_SIZE < *(pstruAsnDDateTime->minute)) || (WJV2_MIN_DMINUTE_SIZE > *(pstruAsnDDateTime->minute)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnDDateTime->minute) = %d",
                     *(pstruAsnDDateTime->minute));
            return false;
        }
        pstruWjDDateTime->n32minute = *(pstruAsnDDateTime->minute);
        pstruWjDDateTime->u8minutePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDDateTime->u8minutePresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDDateTime->second)
    {
        if ((WJV2_MAX_DSECOND_SIZE < *(pstruAsnDDateTime->second)) || (WJV2_MIN_DSECOND_SIZE > *(pstruAsnDDateTime->second)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnDDateTime->second) = %d",
                     *(pstruAsnDDateTime->second));
            return false;
        }
        pstruWjDDateTime->n32second = *(pstruAsnDDateTime->second);
        pstruWjDDateTime->u8secondPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDDateTime->u8secondPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDDateTime->offset)
    {
        if ((WJV2_MAX_DTIMEOFFSET_SIZE < *(pstruAsnDDateTime->offset)) || (WJV2_MIN_DTIMEOFFSET_SIZE > *(pstruAsnDDateTime->offset)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnDDateTime->offset) = %d",
                     *(pstruAsnDDateTime->offset));
            return false;
        }
        pstruWjDDateTime->n32offset = *(pstruAsnDDateTime->offset);
        pstruWjDDateTime->u8offsetPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDDateTime->u8offsetPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_Description_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_Description_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Description *pstruWjDescription = (WJV2_STRU_Description *)pvoidWjDf;
    Description_t *pstruAsnDescription = (Description_t *)pvoidAsnDf;
    if (WJV2_DescriptiontextString == pstruWjDescription->enumDescriptionStringChoice)
    {
        if ((WJV2_MAX_IA5_STRING_LEN < pstruWjDescription->n32textNum) || (WJV2_MIN_IA5_STRING_LEN > pstruWjDescription->n32textNum))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjDescription->n32textNum = %d",
                     pstruWjDescription->n32textNum);
            return false;
        }
        pstruAsnDescription->choice.textString.buf = CALLOC(1, pstruWjDescription->n32textNum);
        if (NULL == pstruAsnDescription->choice.textString.buf)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        memcpy(pstruAsnDescription->choice.textString.buf, pstruWjDescription->u.u8textString, pstruWjDescription->n32textNum);
        pstruAsnDescription->choice.textString.size = pstruWjDescription->n32textNum;
        pstruAsnDescription->present = Description_PR_textString;
    }
    else if (WJV2_DescriptiontextGB2312 == pstruWjDescription->enumDescriptionStringChoice)
    {
        if ((WJV2_MAX_OCT_STRING_LEN < pstruWjDescription->n32textNum) || (WJV2_MIN_OCT_STRING_LEN > pstruWjDescription->n32textNum))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjDescription->n32textNum = %d",
                     pstruWjDescription->n32textNum);
            return false;
        }
        pstruAsnDescription->choice.textGB2312.buf = CALLOC(2, pstruWjDescription->n32textNum);
        if (NULL == pstruAsnDescription->choice.textGB2312.buf)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        memcpy(pstruAsnDescription->choice.textGB2312.buf, pstruWjDescription->u.u16textGB2312, pstruWjDescription->n32textNum * 2);
        pstruAsnDescription->choice.textGB2312.size = pstruWjDescription->n32textNum * 2;
        pstruAsnDescription->present = Description_PR_textGB2312;
    }
    else
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "type is err pstruWjDescription->enumDescriptionStringChoice = %d",
                 pstruWjDescription->enumDescriptionStringChoice);
        return false;
    }
    return true;
}
/**
* @brief     WJV2_Description_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_Description_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Description *pstruWjDescription = (WJV2_STRU_Description *)pvoidWjDf;
    Description_t *pstruAsnDescription = (Description_t *)pvoidAsnDf;
    if (Description_PR_textString == pstruAsnDescription->present)
    {
        if ((WJV2_MAX_IA5_STRING_LEN < pstruAsnDescription->choice.textString.size) || (WJV2_MIN_IA5_STRING_LEN > pstruAsnDescription->choice.textString.size))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruAsnDescription->choice.textString.size = %d",
                     pstruAsnDescription->choice.textString.size);
            return false;
        }
        pstruWjDescription->n32textNum = pstruAsnDescription->choice.textString.size;
        memcpy(pstruWjDescription->u.u8textString, pstruAsnDescription->choice.textString.buf, pstruAsnDescription->choice.textString.size);
        pstruWjDescription->enumDescriptionStringChoice = WJV2_DescriptiontextString;
    }
    else if (Description_PR_textGB2312 == pstruAsnDescription->present)
    {
        if ((WJV2_MAX_OCT_STRING_LEN < pstruAsnDescription->choice.textGB2312.size / 2) || (WJV2_MIN_OCT_STRING_LEN > pstruAsnDescription->choice.textGB2312.size / 2))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruAsnDescription->choice.textGB2312.size / 2 = %d",
                     pstruAsnDescription->choice.textGB2312.size / 2);
            return false;
        }
        pstruWjDescription->n32textNum = pstruAsnDescription->choice.textGB2312.size / 2;
        memcpy(pstruWjDescription->u.u16textGB2312, pstruAsnDescription->choice.textGB2312.buf, pstruAsnDescription->choice.textString.size);
        pstruWjDescription->enumDescriptionStringChoice = WJV2_DescriptiontextGB2312;
    }
    else
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "type is err pstruAsnDescription->present = %d",
                 pstruAsnDescription->present);
        return false;
    }
    return true;
}
/**
* @brief     WJV2_FullPositionVector_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_FullPositionVector_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_FullPositionVector *pstruWjFullPositionVector = (WJV2_STRU_FullPositionVector *)pvoidWjDf;
    FullPositionVector_t *pstruAsnFullPositionVector = (FullPositionVector_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (WJV2_PRESENT == pstruWjFullPositionVector->u8utcTimePresent)
    {
        pstruAsnFullPositionVector->utcTime = CALLOC(1, sizeof(struct DDateTime));
        if (NULL == pstruAsnFullPositionVector->utcTime)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        n32Ret = WJV2_DDateTime_DfEnc(pstruAsnFullPositionVector->utcTime, &(pstruWjFullPositionVector->struutcTime));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DDateTime_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnFullPositionVector->utcTime = NULL;
    }
    n32Ret = WJV2_Position3D_DfEnc(&(pstruAsnFullPositionVector->pos), &(pstruWjFullPositionVector->strupos));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_Position3D_DfEnc is err");
        return false;
    }
    if (WJV2_PRESENT == pstruWjFullPositionVector->u8headingPresent)
    {
        pstruAsnFullPositionVector->heading = CALLOC(1, sizeof(Heading_t));
        if (NULL == pstruAsnFullPositionVector->heading)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        if ((WJV2_MAX_HEADING_SIZE < pstruWjFullPositionVector->n32heading) || (WJV2_MIN_HEADING_SIZE > pstruWjFullPositionVector->n32heading))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjFullPositionVector->n32heading = %d",
                     pstruWjFullPositionVector->n32heading);
            return false;
        }
        *(pstruAsnFullPositionVector->heading) = pstruWjFullPositionVector->n32heading;
    }
    else
    {
        pstruAsnFullPositionVector->heading = NULL;
    }
    if (WJV2_PRESENT == pstruWjFullPositionVector->u8transmissionPresent)
    {
        pstruAsnFullPositionVector->transmission = CALLOC(1, sizeof(TransmissionState_t));
        if (NULL == pstruAsnFullPositionVector->transmission)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        *(pstruAsnFullPositionVector->transmission) = pstruWjFullPositionVector->enumtransmission;
    }
    else
    {
        pstruAsnFullPositionVector->transmission = NULL;
    }
    if (WJV2_PRESENT == pstruWjFullPositionVector->u8speedPresent)
    {
        pstruAsnFullPositionVector->speed = CALLOC(1, sizeof(Speed_t));
        if (NULL == pstruAsnFullPositionVector->speed)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        if ((WJV2_MAX_SPEED_SIZE < pstruWjFullPositionVector->n32speed) || (WJV2_MIN_SPEED_SIZE > pstruWjFullPositionVector->n32speed))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjFullPositionVector->n32speed = %d",
                     pstruWjFullPositionVector->n32speed);
            return false;
        }
        *(pstruAsnFullPositionVector->speed) = pstruWjFullPositionVector->n32speed;
    }
    else
    {
        pstruAsnFullPositionVector->speed = NULL;
    }
    if (WJV2_PRESENT == pstruWjFullPositionVector->u8posAccuracyPresent)
    {
        pstruAsnFullPositionVector->posAccuracy = CALLOC(1, sizeof(struct PositionConfidenceSet));
        if (NULL == pstruAsnFullPositionVector->posAccuracy)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        n32Ret = WJV2_PositionConfidenceSet_DfEnc(pstruAsnFullPositionVector->posAccuracy, &(pstruWjFullPositionVector->struposAccuracy));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionConfidenceSet_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnFullPositionVector->posAccuracy = NULL;
    }

    if (WJV2_PRESENT == pstruWjFullPositionVector->u8timeConfidencePresent)
    {
        pstruAsnFullPositionVector->timeConfidence = CALLOC(1, sizeof(TimeConfidence_t));
        if (NULL == pstruAsnFullPositionVector->timeConfidence)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        *(pstruAsnFullPositionVector->timeConfidence) = pstruWjFullPositionVector->enumtimeConfidence;
    }
    else
    {
        pstruAsnFullPositionVector->timeConfidence = NULL;
    }
    if (WJV2_PRESENT == pstruWjFullPositionVector->u8motionCfdPresent)
    {
        pstruAsnFullPositionVector->motionCfd = CALLOC(1, sizeof(struct MotionConfidenceSet));
        if (NULL == pstruAsnFullPositionVector->motionCfd)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        n32Ret = WJV2_MotionConfidenceSet_DfEnc(pstruAsnFullPositionVector->motionCfd, &(pstruWjFullPositionVector->strumotionCfd));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_MotionConfidenceSet_DfEnc. is err");
            return false;
        }
    }
    else
    {
        pstruAsnFullPositionVector->motionCfd = NULL;
    }
    return true;
}
/**
* @brief     WJV2_FullPositionVector_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_FullPositionVector_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_FullPositionVector *pstruWjFullPositionVector = (WJV2_STRU_FullPositionVector *)pvoidWjDf;
    FullPositionVector_t *pstruAsnFullPositionVector = (FullPositionVector_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (NULL != pstruAsnFullPositionVector->utcTime)
    {
        n32Ret = WJV2_DDateTime_DfDec(pstruAsnFullPositionVector->utcTime, &(pstruWjFullPositionVector->struutcTime));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DDateTime_DfDec. is err");
            return false;
        }
        pstruWjFullPositionVector->u8utcTimePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjFullPositionVector->u8utcTimePresent = WJV2_ABSENT;
    }
    n32Ret = WJV2_Position3D_DfDec(&(pstruAsnFullPositionVector->pos), &(pstruWjFullPositionVector->strupos));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_Position3D_DfDec. is err");
        return false;
    }
    if (NULL != pstruAsnFullPositionVector->heading)
    {
        if ((WJV2_MAX_HEADING_SIZE < *(pstruAsnFullPositionVector->heading)) || (WJV2_MIN_HEADING_SIZE > *(pstruAsnFullPositionVector->heading)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjFullPositionVector->n32heading = %d",
                     pstruWjFullPositionVector->n32heading);
            return false;
        }
        pstruWjFullPositionVector->n32heading = *(pstruAsnFullPositionVector->heading);
        pstruWjFullPositionVector->u8headingPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjFullPositionVector->u8headingPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnFullPositionVector->transmission)
    {
        pstruWjFullPositionVector->enumtransmission = *(pstruAsnFullPositionVector->transmission);
        pstruWjFullPositionVector->u8transmissionPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjFullPositionVector->u8transmissionPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnFullPositionVector->speed)
    {
        if ((WJV2_MAX_SPEED_SIZE < *(pstruAsnFullPositionVector->speed)) || (WJV2_MIN_SPEED_SIZE > *(pstruAsnFullPositionVector->speed)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjFullPositionVector->n32speed = %d",
                     pstruWjFullPositionVector->n32speed);
            return false;
        }
        pstruWjFullPositionVector->n32speed = *(pstruAsnFullPositionVector->speed);
        pstruWjFullPositionVector->u8speedPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjFullPositionVector->u8speedPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnFullPositionVector->posAccuracy)
    {
        n32Ret = WJV2_PositionConfidenceSet_DfDec(pstruAsnFullPositionVector->posAccuracy, &(pstruWjFullPositionVector->struposAccuracy));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionConfidenceSet_DfDec. is err");
            return false;
        }
        pstruWjFullPositionVector->u8posAccuracyPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjFullPositionVector->u8posAccuracyPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnFullPositionVector->timeConfidence)
    {
        pstruWjFullPositionVector->enumtimeConfidence = *(pstruAsnFullPositionVector->timeConfidence);
        pstruWjFullPositionVector->u8timeConfidencePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjFullPositionVector->u8timeConfidencePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnFullPositionVector->motionCfd)
    {
        n32Ret = WJV2_MotionConfidenceSet_DfDec(pstruAsnFullPositionVector->motionCfd, &(pstruWjFullPositionVector->strumotionCfd));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_MotionConfidenceSet_DfDec. is err");
            return false;
        }
        pstruWjFullPositionVector->u8motionCfdPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjFullPositionVector->u8motionCfdPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_IntersectionState_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_IntersectionState_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_IntersectionState *pstruWjIntersectionState = (WJV2_STRU_IntersectionState *)pvoidWjDf;
    IntersectionState_t *pstruAsnIntersectionState = (IntersectionState_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_NodeReferenceID_DfEnc(&(pstruAsnIntersectionState->intersectionId), &(pstruWjIntersectionState->struintersectionId));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfEnc is err");
        return false;
    }
    n32Ret = WJV2_IntersectionStatusObject_DeEnc(&(pstruAsnIntersectionState->status), &(pstruWjIntersectionState->strbitstatus));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_IntersectionStatusObject_DeEnc is err");
        return false;
    }
    if (WJV2_PRESENT == pstruWjIntersectionState->u8moyPresent)
    {
        pstruAsnIntersectionState->moy = CALLOC(1, sizeof(MinuteOfTheYear_t));
        if (NULL == pstruAsnIntersectionState->moy)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        if ((WJV2_MAX_MINUTEOFTHEYEAR_SIZE < pstruWjIntersectionState->n32moy) || (WJV2_MIN_MINUTEOFTHEYEAR_SIZE > pstruWjIntersectionState->n32moy))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjIntersectionState->n32moy = %d",
                     pstruWjIntersectionState->n32moy);
            return false;
        }
        *(pstruAsnIntersectionState->moy) = pstruWjIntersectionState->n32moy;
    }
    else
    {
        pstruAsnIntersectionState->moy = NULL;
    }
    if (WJV2_PRESENT == pstruWjIntersectionState->u8timeStampPresent)
    {
        pstruAsnIntersectionState->timeStamp = CALLOC(1, sizeof(DSecond_t));
        if (NULL == pstruAsnIntersectionState->timeStamp)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        if ((WJV2_MAX_DSECOND_SIZE < pstruWjIntersectionState->n32timeStamp) || (WJV2_MIN_DSECOND_SIZE > pstruWjIntersectionState->n32timeStamp))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjIntersectionState->n32timeStamp = %d",
                     pstruWjIntersectionState->n32timeStamp);
            return false;
        }
        *(pstruAsnIntersectionState->timeStamp) = pstruWjIntersectionState->n32timeStamp;
    }
    else
    {
        pstruAsnIntersectionState->timeStamp = NULL;
    }
    if (WJV2_PRESENT == pstruWjIntersectionState->u8timeConfidencePresent)
    {
        pstruAsnIntersectionState->timeConfidence = CALLOC(1, sizeof(TimeConfidence_t));
        if (NULL == pstruAsnIntersectionState->timeConfidence)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        *(pstruAsnIntersectionState->timeConfidence) = pstruWjIntersectionState->enumtimeConfidence;
    }
    else
    {
        pstruAsnIntersectionState->timeConfidence = NULL;
    }
    n32Ret = WJV2_PhaseList_DfEnc(&(pstruAsnIntersectionState->phases), &(pstruWjIntersectionState->struphases));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PhaseList_DfEnc is err");
        return false;
    }
    return true;
}
/**
* @brief     WJV2_IntersectionState_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创���初始版本
* </table>
*/
int32_t WJV2_IntersectionState_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_IntersectionState *pstruWjIntersectionState = (WJV2_STRU_IntersectionState *)pvoidWjDf;
    IntersectionState_t *pstruAsnIntersectionState = (IntersectionState_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_NodeReferenceID_DfDec(&(pstruAsnIntersectionState->intersectionId), &(pstruWjIntersectionState->struintersectionId));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfDec. is err");
        return false;
    }
    n32Ret = WJV2_IntersectionStatusObject_DeDec(&(pstruAsnIntersectionState->status), &(pstruWjIntersectionState->strbitstatus));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_IntersectionStatusObject_DeDec. is err");
        return false;
    }
    if (NULL != pstruAsnIntersectionState->moy)
    {
        if ((WJV2_MAX_MINUTEOFTHEYEAR_SIZE < *(pstruAsnIntersectionState->moy)) || (WJV2_MIN_MINUTEOFTHEYEAR_SIZE > *(pstruAsnIntersectionState->moy)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjIntersectionState->n32moy = %d",
                     pstruWjIntersectionState->n32moy);
            return false;
        }
        pstruWjIntersectionState->n32moy = *(pstruAsnIntersectionState->moy);
        pstruWjIntersectionState->u8moyPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjIntersectionState->u8moyPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnIntersectionState->timeStamp)
    {
        if ((WJV2_MAX_DSECOND_SIZE < *(pstruAsnIntersectionState->timeStamp)) || (WJV2_MIN_DSECOND_SIZE > *(pstruAsnIntersectionState->timeStamp)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjIntersectionState->n32timeStamp = %d",
                     pstruWjIntersectionState->n32timeStamp);
            return false;
        }
        pstruWjIntersectionState->n32timeStamp = *(pstruAsnIntersectionState->timeStamp);
        pstruWjIntersectionState->u8timeStampPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjIntersectionState->u8timeStampPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnIntersectionState->timeConfidence)
    {
        pstruWjIntersectionState->enumtimeConfidence = *(pstruAsnIntersectionState->timeConfidence);
        pstruWjIntersectionState->u8timeConfidencePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjIntersectionState->u8timeConfidencePresent = WJV2_ABSENT;
    }
    n32Ret = WJV2_PhaseList_DfDec(&(pstruAsnIntersectionState->phases), &(pstruWjIntersectionState->struphases));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PhaseList_DfDec is err");
        return false;
    }
    return true;
}
/**
* @brief     WJV2_IntersectionStateList_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_IntersectionStateList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_IntersectionStateList *pstruWjIntersectionStateList = (WJV2_STRU_IntersectionStateList *)pvoidWjDf;
    IntersectionStateList_t *pstruAsnIntersectionStateList = (IntersectionStateList_t *)pvoidAsnDf;
    IntersectionState_t *pstruIntersectionState_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_INTERSECTIONSTATE_LEN < pstruWjIntersectionStateList->u8IntersectionStateNum) || (WJV2_MIN_LIST_INTERSECTIONSTATE_LEN > pstruWjIntersectionStateList->u8IntersectionStateNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjIntersectionStateList->u8IntersectionStateNum = %d",
                 pstruWjIntersectionStateList->u8IntersectionStateNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjIntersectionStateList->u8IntersectionStateNum; u32i++)
    {
        pstruIntersectionState_node = CALLOC(1, sizeof(IntersectionState_t));
        if (NULL == pstruIntersectionState_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_IntersectionState_DfEnc(pstruIntersectionState_node, &(pstruWjIntersectionStateList->struIntersectionState[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_IntersectionState_DfEnc is err");
            FREEMEM(pstruIntersectionState_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnIntersectionStateList->list), pstruIntersectionState_node);
    }
    return true;
}
/**
* @brief     WJV2_IntersectionStateList_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_IntersectionStateList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_IntersectionStateList *pstruWjIntersectionStateList = (WJV2_STRU_IntersectionStateList *)pvoidWjDf;
    IntersectionStateList_t *pstruAsnIntersectionStateList = (IntersectionStateList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_INTERSECTIONSTATE_LEN < pstruAsnIntersectionStateList->list.count) || (WJV2_MIN_LIST_INTERSECTIONSTATE_LEN > pstruAsnIntersectionStateList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnIntersectionStateList->list.count = %d",
                 pstruAsnIntersectionStateList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnIntersectionStateList->list.count; u32i++)
    {
        n32Ret = WJV2_IntersectionState_DfDec(pstruAsnIntersectionStateList->list.array[u32i],
                                              &(pstruWjIntersectionStateList->struIntersectionState[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_IntersectionState_DfDec is err");
            return false;
        }
    }
    pstruWjIntersectionStateList->u8IntersectionStateNum = (uint8_t)u32i;
    return true;
}
/**
* @brief     WJV2_Lane_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_Lane_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Lane *pstruWjLane = (WJV2_STRU_Lane *)pvoidWjDf;
    Lane_t *pstruAsnLane = (Lane_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_LANEID_SIZE < pstruWjLane->n32laneID) || (WJV2_MIN_LANEID_SIZE > pstruWjLane->n32laneID))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjLane->n32laneID = %d",
                 pstruWjLane->n32laneID);
        return false;
    }
    pstruAsnLane->laneID = pstruWjLane->n32laneID;
    if (WJV2_PRESENT == pstruWjLane->u8laneWidthPresent)
    {
        pstruAsnLane->laneWidth = CALLOC(1, sizeof(LaneWidth_t));
        if (NULL == pstruAsnLane->laneWidth)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        if ((WJV2_MAX_LANEWIDTH_SIZE < pstruWjLane->n32laneWidth) || (WJV2_MIN_LANEWIDTH_SIZE > pstruWjLane->n32laneWidth))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjLane->n32laneWidth = %d",
                     pstruWjLane->n32laneWidth);
            return false;
        }
        *(pstruAsnLane->laneWidth) = pstruWjLane->n32laneWidth;
    }
    else
    {
        pstruAsnLane->laneWidth = NULL;
    }
    if (WJV2_PRESENT == pstruWjLane->u8laneAttributesPresent)
    {
        pstruAsnLane->laneAttributes = CALLOC(1, sizeof(struct LaneAttributes));
        if (NULL == pstruAsnLane->laneAttributes)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        n32Ret = WJV2_LaneAttributes_DfEnc(pstruAsnLane->laneAttributes, &(pstruWjLane->strulaneAttributes));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneAttributes_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLane->laneAttributes = NULL;
    }
    if (WJV2_PRESENT == pstruWjLane->u8maneuversPresent)
    {
        pstruAsnLane->maneuvers = CALLOC(1, sizeof(AllowedManeuvers_t));
        if (NULL == pstruAsnLane->maneuvers)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        n32Ret = WJV2_AllowedManeuvers_DeEnc(pstruAsnLane->maneuvers, &(pstruWjLane->strbitmaneuvers));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AllowedManeuvers_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLane->maneuvers = NULL;
    }
    if (WJV2_PRESENT == pstruWjLane->u8connectsToPresent)
    {
        pstruAsnLane->connectsTo = CALLOC(1, sizeof(struct ConnectsToList));
        if (NULL == pstruAsnLane->connectsTo)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        n32Ret = WJV2_ConnectsToList_DfEnc(pstruAsnLane->connectsTo, &(pstruWjLane->struConnectsToList));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ConnectsToList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLane->connectsTo = NULL;
    }
    if (WJV2_PRESENT == pstruWjLane->u8speedLimitsPresent)
    {
        pstruAsnLane->speedLimits = CALLOC(1, sizeof(struct SpeedLimitList));
        if (NULL == pstruAsnLane->speedLimits)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        n32Ret = WJV2_SpeedLimitList_DfEnc(pstruAsnLane->speedLimits, &(pstruWjLane->struspeedLimits));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_SpeedLimitList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLane->speedLimits = NULL;
    }

    if (WJV2_PRESENT == pstruWjLane->u8pointsPresent)
    {
        pstruAsnLane->points = CALLOC(1, sizeof(struct PointList));
        if (NULL == pstruAsnLane->points)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        n32Ret = WJV2_PointList_DfEnc(pstruAsnLane->points, &(pstruWjLane->strupoints));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PointList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLane->points = NULL;
    }
    return true;
}
/**
* @brief     WJV2_Lane_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_Lane_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Lane *pstruWjLane = (WJV2_STRU_Lane *)pvoidWjDf;
    Lane_t *pstruAsnLane = (Lane_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_LANEID_SIZE < pstruAsnLane->laneID) || (WJV2_MIN_LANEID_SIZE > pstruAsnLane->laneID))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnLane->laneID = %d",
                 pstruAsnLane->laneID);
        return false;
    }
    pstruWjLane->n32laneID = pstruAsnLane->laneID;
    if (NULL != pstruAsnLane->laneWidth)
    {
        if ((WJV2_MAX_LANEWIDTH_SIZE < *(pstruAsnLane->laneWidth)) || (WJV2_MIN_LANEWIDTH_SIZE > *(pstruAsnLane->laneWidth)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnLane->laneWidth) = %d",
                     *(pstruAsnLane->laneWidth));
            return false;
        }
        pstruWjLane->n32laneWidth = *(pstruAsnLane->laneWidth);
        pstruWjLane->u8laneWidthPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLane->u8laneWidthPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnLane->laneAttributes)
    {
        n32Ret = WJV2_LaneAttributes_DfDec(pstruAsnLane->laneAttributes, &(pstruWjLane->strulaneAttributes));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneAttributes_DfDec is err");
            return false;
        }
        pstruWjLane->u8laneAttributesPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLane->u8laneAttributesPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnLane->maneuvers)
    {
        n32Ret = WJV2_AllowedManeuvers_DeDec(pstruAsnLane->maneuvers, &(pstruWjLane->strbitmaneuvers));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AllowedManeuvers_DeDec is err");
            return false;
        }
        pstruWjLane->u8maneuversPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLane->u8maneuversPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnLane->connectsTo)
    {
        n32Ret = WJV2_ConnectsToList_DfDec(pstruAsnLane->connectsTo, &(pstruWjLane->struConnectsToList));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ConnectsToList_DfDec is err");
            return false;
        }
        pstruWjLane->u8connectsToPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLane->u8connectsToPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnLane->speedLimits)
    {
        n32Ret = WJV2_SpeedLimitList_DfDec(pstruAsnLane->speedLimits, &(pstruWjLane->struspeedLimits));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_SpeedLimitList_DfDec is err");
            return false;
        }
        pstruWjLane->u8speedLimitsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLane->u8speedLimitsPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnLane->points)
    {
        n32Ret = WJV2_PointList_DfDec(pstruAsnLane->points, &(pstruWjLane->strupoints));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PointList_DfDec is err");
            return false;
        }
        pstruWjLane->u8pointsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLane->u8pointsPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_LaneAttributes_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_LaneAttributes_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_LaneAttributes *pstruWjLaneAttributes = (WJV2_STRU_LaneAttributes *)pvoidWjDf;
    LaneAttributes_t *pstruAsnLaneAttributes = (LaneAttributes_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (WJV2_PRESENT == pstruWjLaneAttributes->u8shareWithPresent)
    {
        pstruAsnLaneAttributes->shareWith = CALLOC(1, sizeof(LaneSharing_t));
        if (NULL == pstruAsnLaneAttributes->shareWith)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        n32Ret = WJV2_LaneSharing_DeEnc(pstruAsnLaneAttributes->shareWith, &(pstruWjLaneAttributes->strbitshareWith));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneSharing_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLaneAttributes->shareWith = NULL;
    }
    n32Ret = WJV2_LaneTypeAttributes_DfEnc(&(pstruAsnLaneAttributes->laneType), &(pstruWjLaneAttributes->strulaneType));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_LaneTypeAttributes_DfEnc is err");
        return false;
    }
    return true;
}
/**
* @brief     WJV2_LaneAttributes_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_LaneAttributes_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_LaneAttributes *pstruWjLaneAttributes = (WJV2_STRU_LaneAttributes *)pvoidWjDf;
    LaneAttributes_t *pstruAsnLaneAttributes = (LaneAttributes_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (NULL != pstruAsnLaneAttributes->shareWith)
    {
        n32Ret = WJV2_LaneSharing_DeDec(pstruAsnLaneAttributes->shareWith, &(pstruWjLaneAttributes->strbitshareWith));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneSharing_DeDec is err");
            return false;
        }
        pstruWjLaneAttributes->u8shareWithPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLaneAttributes->u8shareWithPresent = WJV2_ABSENT;
    }
    n32Ret = WJV2_LaneTypeAttributes_DfDec(&(pstruAsnLaneAttributes->laneType), &(pstruWjLaneAttributes->strulaneType));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_LaneTypeAttributes_DfDec is err");
        return false;
    }
    return true;
}
/**
* @brief     WJV2_LaneList_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_LaneList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_LaneList *pstruWjLaneList = (WJV2_STRU_LaneList *)pvoidWjDf;
    LaneList_t *pstruAsnLaneList = (LaneList_t *)pvoidAsnDf;
    Lane_t *pstruLane_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_LANE_LEN < pstruWjLaneList->u8LaneNum) || (WJV2_MIN_LIST_LANE_LEN > pstruWjLaneList->u8LaneNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjLaneList->u8LaneNum = %d",
                 pstruWjLaneList->u8LaneNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjLaneList->u8LaneNum; u32i++)
    {
        pstruLane_node = CALLOC(1, sizeof(Lane_t));
        if (NULL == pstruLane_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_Lane_DfEnc(pstruLane_node, &(pstruWjLaneList->struLane[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Lane_DfEnc is err");
            FREEMEM(pstruLane_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnLaneList->list), pstruLane_node);
    }
    return true;
}
/**
* @brief     WJV2_LaneList_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_LaneList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_LaneList *pstruWjLaneList = (WJV2_STRU_LaneList *)pvoidWjDf;
    LaneList_t *pstruAsnLaneList = (LaneList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_LANE_LEN < pstruAsnLaneList->list.count) || (WJV2_MIN_LIST_LANE_LEN > pstruAsnLaneList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnLaneList->list.count = %d",
                 pstruAsnLaneList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnLaneList->list.count; u32i++)
    {
        n32Ret = WJV2_Lane_DfDec(pstruAsnLaneList->list.array[u32i],
                                 &(pstruWjLaneList->struLane[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Lane_DfDec is err");
            return false;
        }
    }
    pstruWjLaneList->u8LaneNum = (uint8_t)u32i;
    return true;
}
/**
* @brief     WJV2_LaneTypeAttributes_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_LaneTypeAttributes_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_LaneTypeAttributes *pstruWjLaneTypeAttributes = (WJV2_STRU_LaneTypeAttributes *)pvoidWjDf;
    LaneTypeAttributes_t *pstruAsnLaneTypeAttributes = (LaneTypeAttributes_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (WJV2_LaneAttributesVehicle == pstruWjLaneTypeAttributes->enumLaneTypeAttributesChoice)
    {
        n32Ret = WJV2_LaneAttributesVehicle_DeEnc(&(pstruAsnLaneTypeAttributes->choice.vehicle), &(pstruWjLaneTypeAttributes->u.strbitvehicle));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneAttributesVehicle_DeEnc is err");
            return false;
        }
        pstruAsnLaneTypeAttributes->present = LaneTypeAttributes_PR_vehicle;
    }
    else if (WJV2_LaneAttributesCrosswalk == pstruWjLaneTypeAttributes->enumLaneTypeAttributesChoice)
    {
        n32Ret = WJV2_LaneAttributesCrosswalk_DeEnc(&(pstruAsnLaneTypeAttributes->choice.crosswalk), &(pstruWjLaneTypeAttributes->u.strbitcrosswalk));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneAttributesCrosswalk_DeEnc is err");
            return false;
        }
        pstruAsnLaneTypeAttributes->present = LaneTypeAttributes_PR_crosswalk;
    }
    else if (WJV2_LaneAttributesBike == pstruWjLaneTypeAttributes->enumLaneTypeAttributesChoice)
    {
        n32Ret = WJV2_LaneAttributesBike_DeEnc(&(pstruAsnLaneTypeAttributes->choice.bikeLane), &(pstruWjLaneTypeAttributes->u.strbitbikeLane));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneAttributesBike_DeEnc is err");
            return false;
        }
        pstruAsnLaneTypeAttributes->present = LaneTypeAttributes_PR_bikeLane;
    }
    else if (WJV2_LaneAttributesSidewalk == pstruWjLaneTypeAttributes->enumLaneTypeAttributesChoice)
    {
        n32Ret = WJV2_LaneAttributesSidewalk_DeEnc(&(pstruAsnLaneTypeAttributes->choice.sidewalk), &(pstruWjLaneTypeAttributes->u.strbitsidewalk));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneAttributesSidewalk_DeEnc is err");
            return false;
        }
        pstruAsnLaneTypeAttributes->present = LaneTypeAttributes_PR_sidewalk;
    }
    else if (WJV2_LaneAttributesBarrier == pstruWjLaneTypeAttributes->enumLaneTypeAttributesChoice)
    {
        n32Ret = WJV2_LaneAttributesBarrier_DeEnc(&(pstruAsnLaneTypeAttributes->choice.median), &(pstruWjLaneTypeAttributes->u.strbitmedian));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneAttributesBarrier_DeEnc is err");
            return false;
        }
        pstruAsnLaneTypeAttributes->present = LaneTypeAttributes_PR_median;
    }
    else if (WJV2_LaneAttributesStriping == pstruWjLaneTypeAttributes->enumLaneTypeAttributesChoice)
    {
        n32Ret = WJV2_LaneAttributesStriping_DeEnc(&(pstruAsnLaneTypeAttributes->choice.striping), &(pstruWjLaneTypeAttributes->u.strbitstriping));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneAttributesStriping_DeEnc is err");
            return false;
        }
        pstruAsnLaneTypeAttributes->present = LaneTypeAttributes_PR_striping;
    }
    else if (WJV2_LaneAttributesTrackedVehicle == pstruWjLaneTypeAttributes->enumLaneTypeAttributesChoice)
    {
        n32Ret = WJV2_LaneAttributesTrackedVehicle_DeEnc(&(pstruAsnLaneTypeAttributes->choice.trackedVehicle), &(pstruWjLaneTypeAttributes->u.strbittrackedVehicle));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneAttributesTrackedVehicle_DeEnc is err");
            return false;
        }
        pstruAsnLaneTypeAttributes->present = LaneTypeAttributes_PR_trackedVehicle;
    }
    else if (WJV2_LaneAttributesParking == pstruWjLaneTypeAttributes->enumLaneTypeAttributesChoice)
    {
        n32Ret = WJV2_LaneAttributesParking_DeEnc(&(pstruAsnLaneTypeAttributes->choice.parking), &(pstruWjLaneTypeAttributes->u.strbitparking));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneAttributesParking_DeEnc is err");
            return false;
        }
        pstruAsnLaneTypeAttributes->present = LaneTypeAttributes_PR_parking;
    }
    else
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "choice is err pstruWjLaneTypeAttributes->enumLaneTypeAttributesChoice = %d",
                 pstruWjLaneTypeAttributes->enumLaneTypeAttributesChoice);
        return false;
    }
    return true;
}
/**
* @brief     WJV2_LaneTypeAttributes_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_LaneTypeAttributes_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_LaneTypeAttributes *pstruWjLaneTypeAttributes = (WJV2_STRU_LaneTypeAttributes *)pvoidWjDf;
    LaneTypeAttributes_t *pstruAsnLaneTypeAttributes = (LaneTypeAttributes_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (LaneTypeAttributes_PR_vehicle == pstruAsnLaneTypeAttributes->present)
    {
        n32Ret = WJV2_LaneAttributesVehicle_DeDec(&(pstruAsnLaneTypeAttributes->choice.vehicle), &(pstruWjLaneTypeAttributes->u.strbitvehicle));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneAttributesVehicle_DeDec is err");
            return false;
        }
        pstruWjLaneTypeAttributes->enumLaneTypeAttributesChoice = WJV2_LaneAttributesVehicle;
    }
    else if (LaneTypeAttributes_PR_crosswalk == pstruAsnLaneTypeAttributes->present)
    {
        n32Ret = WJV2_LaneAttributesCrosswalk_DeDec(&(pstruAsnLaneTypeAttributes->choice.crosswalk), &(pstruWjLaneTypeAttributes->u.strbitcrosswalk));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneAttributesCrosswalk_DeDec is err");
            return false;
        }
        pstruWjLaneTypeAttributes->enumLaneTypeAttributesChoice = WJV2_LaneAttributesCrosswalk;
    }
    else if (LaneTypeAttributes_PR_bikeLane == pstruAsnLaneTypeAttributes->present)
    {
        n32Ret = WJV2_LaneAttributesBike_DeDec(&(pstruAsnLaneTypeAttributes->choice.bikeLane), &(pstruWjLaneTypeAttributes->u.strbitbikeLane));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneAttributesBike_DeDec is err");
            return false;
        }
        pstruWjLaneTypeAttributes->enumLaneTypeAttributesChoice = WJV2_LaneAttributesBike;
    }
    else if (LaneTypeAttributes_PR_sidewalk == pstruAsnLaneTypeAttributes->present)
    {
        n32Ret = WJV2_LaneAttributesSidewalk_DeDec(&(pstruAsnLaneTypeAttributes->choice.sidewalk), &(pstruWjLaneTypeAttributes->u.strbitsidewalk));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneAttributesSidewalk_DeDec is err");
            return false;
        }
        pstruWjLaneTypeAttributes->enumLaneTypeAttributesChoice = WJV2_LaneAttributesSidewalk;
    }
    else if (LaneTypeAttributes_PR_median == pstruAsnLaneTypeAttributes->present)
    {
        n32Ret = WJV2_LaneAttributesBarrier_DeDec(&(pstruAsnLaneTypeAttributes->choice.median), &(pstruWjLaneTypeAttributes->u.strbitmedian));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneAttributesBarrier_DeDec is err");
            return false;
        }
        pstruWjLaneTypeAttributes->enumLaneTypeAttributesChoice = LaneTypeAttributes_PR_median;
    }
    else if (LaneTypeAttributes_PR_striping == pstruAsnLaneTypeAttributes->present)
    {
        n32Ret = WJV2_LaneAttributesStriping_DeDec(&(pstruAsnLaneTypeAttributes->choice.striping), &(pstruWjLaneTypeAttributes->u.strbitstriping));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneAttributesStriping_DeDec is err");
            return false;
        }
        pstruWjLaneTypeAttributes->enumLaneTypeAttributesChoice = LaneTypeAttributes_PR_striping;
    }
    else if (LaneTypeAttributes_PR_trackedVehicle == pstruAsnLaneTypeAttributes->present)
    {
        n32Ret = WJV2_LaneAttributesTrackedVehicle_DeDec(&(pstruAsnLaneTypeAttributes->choice.trackedVehicle), &(pstruWjLaneTypeAttributes->u.strbittrackedVehicle));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneAttributesTrackedVehicle_DeDec is err");
            return false;
        }
        pstruWjLaneTypeAttributes->enumLaneTypeAttributesChoice = LaneTypeAttributes_PR_trackedVehicle;
    }
    else if (LaneTypeAttributes_PR_parking == pstruAsnLaneTypeAttributes->present)
    {
        n32Ret = WJV2_LaneAttributesParking_DeDec(&(pstruAsnLaneTypeAttributes->choice.parking), &(pstruWjLaneTypeAttributes->u.strbitparking));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneAttributesParking_DeDec is err");
            return false;
        }
        pstruWjLaneTypeAttributes->enumLaneTypeAttributesChoice = LaneTypeAttributes_PR_parking;
    }
    else
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "choice is err pstruAsnLaneTypeAttributes->present = %d",
                 pstruAsnLaneTypeAttributes->present);
        return false;
    }
    return true;
}
/**
* @brief     WJV2_Link_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_Link_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Link *pstruWjLink = (WJV2_STRU_Link *)pvoidWjDf;
    Link_t *pstruAsnLink = (Link_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (WJV2_PRESENT == pstruWjLink->u8namePresent)
    {
        pstruAsnLink->name = CALLOC(1, sizeof(DescriptiveName_t));
        if (NULL == pstruAsnLink->name)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_DescriptiveName_DeEnc(pstruAsnLink->name, &(pstruWjLink->stria5name));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DescriptiveName_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLink->name = NULL;
    }
    n32Ret = WJV2_NodeReferenceID_DfEnc(&(pstruAsnLink->upstreamNodeId), &(pstruWjLink->struupstreamNodeId));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfEnc is err");
        return false;
    }
    if (WJV2_PRESENT == pstruWjLink->u8speedLimitsPresent)
    {
        pstruAsnLink->speedLimits = CALLOC(1, sizeof(struct SpeedLimitList));
        if (NULL == pstruAsnLink->speedLimits)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_SpeedLimitList_DfEnc(pstruAsnLink->speedLimits, &(pstruWjLink->struspeedLimits));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_SpeedLimitList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLink->speedLimits = NULL;
    }
    pstruAsnLink->linkWidth = pstruWjLink->n32linkWidth;

    if (WJV2_PRESENT == pstruWjLink->u8pointsPresent)
    {
        pstruAsnLink->points = CALLOC(1, sizeof(struct PointList));
        if (NULL == pstruAsnLink->points)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PointList_DfEnc(pstruAsnLink->points, &(pstruWjLink->strupoints));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PointList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLink->points = NULL;
    }
    if (WJV2_PRESENT == pstruWjLink->u8MovementListPresent)
    {
        pstruAsnLink->movements = CALLOC(1, sizeof(struct MovementList));
        if (NULL == pstruAsnLink->movements)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_MovementList_DfEnc(pstruAsnLink->movements, &(pstruWjLink->strumovements));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_MovementList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLink->movements = NULL;
    }
    n32Ret = WJV2_LaneList_DfEnc(&(pstruAsnLink->lanes), &(pstruWjLink->strulanes));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_LaneList_DfEnc is err");
        return false;
    }
    return true;
}
/**
* @brief     WJV2_Link_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_Link_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Link *pstruWjLink = (WJV2_STRU_Link *)pvoidWjDf;
    Link_t *pstruAsnLink = (Link_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (NULL != pstruAsnLink->name)
    {
        n32Ret = WJV2_DescriptiveName_DeDec(pstruAsnLink->name, &(pstruWjLink->stria5name));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DescriptiveName_DeDec is err");
            return false;
        }
        pstruWjLink->u8namePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLink->u8namePresent = WJV2_ABSENT;
    }
    n32Ret = WJV2_NodeReferenceID_DfDec(&(pstruAsnLink->upstreamNodeId), &(pstruWjLink->struupstreamNodeId));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfDec is err");
        return false;
    }
    if (NULL != pstruAsnLink->speedLimits)
    {
        n32Ret = WJV2_SpeedLimitList_DfDec(pstruAsnLink->speedLimits, &(pstruWjLink->struspeedLimits));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_SpeedLimitList_DfDec is err");
            return false;
        }
        pstruWjLink->u8speedLimitsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLink->u8speedLimitsPresent = WJV2_ABSENT;
    }
    pstruWjLink->n32linkWidth = pstruAsnLink->linkWidth;

    if (NULL != pstruAsnLink->points)
    {
        n32Ret = WJV2_PointList_DfDec(pstruAsnLink->points, &(pstruWjLink->strupoints));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PointList_DfDec is err");
            return false;
        }
        pstruWjLink->u8pointsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLink->u8pointsPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnLink->movements)
    {
        n32Ret = WJV2_MovementList_DfDec(pstruAsnLink->movements, &(pstruWjLink->strumovements));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_MovementList_DfDec is err");
            return false;
        }
        pstruWjLink->u8MovementListPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLink->u8MovementListPresent = WJV2_ABSENT;
    }
    n32Ret = WJV2_LaneList_DfDec(&(pstruAsnLink->lanes), &(pstruWjLink->strulanes));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_LaneList_DfDec is err");
        return false;
    }
    return true;
}
/**
* @brief     WJV2_LinkList_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_LinkList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_LinkList *pstruWjLinkList = (WJV2_STRU_LinkList *)pvoidWjDf;
    LinkList_t *pstruAsnLinkList = (LinkList_t *)pvoidAsnDf;
    Link_t *pstruLink_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_LINK_LEN < pstruWjLinkList->u8LinkNum) || (WJV2_MIN_LIST_LINK_LEN > pstruWjLinkList->u8LinkNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjLinkList->u8LinkNum = %d",
                 pstruWjLinkList->u8LinkNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjLinkList->u8LinkNum; u32i++)
    {
        pstruLink_node = CALLOC(1, sizeof(Link_t));
        if (NULL == pstruLink_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_Link_DfEnc(pstruLink_node, &(pstruWjLinkList->struLink[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Link_DfEnc is err");
            FREEMEM(pstruLink_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnLinkList->list), pstruLink_node);
    }
    return true;
}
/**
* @brief     WJV2_LinkList_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_LinkList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_LinkList *pstruWjLinkList = (WJV2_STRU_LinkList *)pvoidWjDf;
    LinkList_t *pstruAsnLinkList = (LinkList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_LINK_LEN < pstruAsnLinkList->list.count) || (WJV2_MIN_LIST_LINK_LEN > pstruAsnLinkList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnLinkList->list.count = %d",
                 pstruAsnLinkList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnLinkList->list.count; u32i++)
    {
        n32Ret = WJV2_Link_DfDec(pstruAsnLinkList->list.array[u32i],
                                 &(pstruWjLinkList->struLink[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Link_DfDec is err");
            return false;
        }
    }
    pstruWjLinkList->u8LinkNum = (uint8_t)u32i;
    return true;
}
/**
* @brief     WJV2_MotionConfidenceSet_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_MotionConfidenceSet_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_MotionConfidenceSet *pstruWjMotionConfidenceSet = (WJV2_STRU_MotionConfidenceSet *)pvoidWjDf;
    MotionConfidenceSet_t *pstruAsnMotionConfidenceSet = (MotionConfidenceSet_t *)pvoidAsnDf;
    if (WJV2_PRESENT == pstruWjMotionConfidenceSet->u8speedCfdPresent)
    {
        pstruAsnMotionConfidenceSet->speedCfd = CALLOC(1, sizeof(SpeedConfidence_t));
        if (NULL == pstruAsnMotionConfidenceSet->speedCfd)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnMotionConfidenceSet->speedCfd) = pstruWjMotionConfidenceSet->enumspeedCfd;
    }
    else
    {
        pstruAsnMotionConfidenceSet->speedCfd = NULL;
    }
    if (WJV2_PRESENT == pstruWjMotionConfidenceSet->u8headingCfdPresent)
    {
        pstruAsnMotionConfidenceSet->headingCfd = CALLOC(1, sizeof(HeadingConfidence_t));
        if (NULL == pstruAsnMotionConfidenceSet->headingCfd)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnMotionConfidenceSet->headingCfd) = pstruWjMotionConfidenceSet->enumheadingCfd;
    }
    else
    {
        pstruAsnMotionConfidenceSet->headingCfd = NULL;
    }
    if (WJV2_PRESENT == pstruWjMotionConfidenceSet->u8steerCfdPresent)
    {
        pstruAsnMotionConfidenceSet->steerCfd = CALLOC(1, sizeof(SteeringWheelAngleConfidence_t));
        if (NULL == pstruAsnMotionConfidenceSet->steerCfd)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnMotionConfidenceSet->steerCfd) = pstruWjMotionConfidenceSet->enumsteerCfd;
    }
    else
    {
        pstruAsnMotionConfidenceSet->steerCfd = NULL;
    }
    return true;
}
/**
* @brief     WJV2_MotionConfidenceSet_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_MotionConfidenceSet_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_MotionConfidenceSet *pstruWjMotionConfidenceSet = (WJV2_STRU_MotionConfidenceSet *)pvoidWjDf;
    MotionConfidenceSet_t *pstruAsnMotionConfidenceSet = (MotionConfidenceSet_t *)pvoidAsnDf;
    if (NULL != pstruAsnMotionConfidenceSet->speedCfd)
    {
        pstruWjMotionConfidenceSet->enumspeedCfd = *(pstruAsnMotionConfidenceSet->speedCfd);
        pstruWjMotionConfidenceSet->u8speedCfdPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjMotionConfidenceSet->u8speedCfdPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnMotionConfidenceSet->headingCfd)
    {
        pstruWjMotionConfidenceSet->enumheadingCfd = *(pstruAsnMotionConfidenceSet->headingCfd);
        pstruWjMotionConfidenceSet->u8headingCfdPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjMotionConfidenceSet->u8headingCfdPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnMotionConfidenceSet->steerCfd)
    {
        pstruWjMotionConfidenceSet->enumsteerCfd = *(pstruAsnMotionConfidenceSet->steerCfd);
        pstruWjMotionConfidenceSet->u8steerCfdPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjMotionConfidenceSet->u8steerCfdPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_Movement_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_Movement_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Movement *pstruWjMovement = (WJV2_STRU_Movement *)pvoidWjDf;
    Movement_t *pstruAsnMovement = (Movement_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_NodeReferenceID_DfEnc(&(pstruAsnMovement->remoteIntersection),
                                        &(pstruWjMovement->struremoteIntersection));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfEnc is err");
        return false;
    }
    if (WJV2_PRESENT == pstruWjMovement->u8phaseIdPresent)
    {
        pstruAsnMovement->phaseId = CALLOC(1, sizeof(PhaseID_t));
        if (NULL == pstruAsnMovement->phaseId)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_PHASEID_SIZE < pstruWjMovement->n32phaseId) || (WJV2_MIN_PHASEID_SIZE > pstruWjMovement->n32phaseId))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjMovement->n32phaseId = %d",
                     pstruWjMovement->n32phaseId);
            return false;
        }
        *(pstruAsnMovement->phaseId) = pstruWjMovement->n32phaseId;
    }
    else
    {
        pstruAsnMovement->phaseId = NULL;
    }
    return true;
}
/**
* @brief     WJV2_Movement_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_Movement_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Movement *pstruWjMovement = (WJV2_STRU_Movement *)pvoidWjDf;
    Movement_t *pstruAsnMovement = (Movement_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_NodeReferenceID_DfDec(&(pstruAsnMovement->remoteIntersection),
                                        &(pstruWjMovement->struremoteIntersection));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfDec is err");
        return false;
    }
    if (NULL != pstruAsnMovement->phaseId)
    {
        if ((WJV2_MAX_PHASEID_SIZE < *(pstruAsnMovement->phaseId)) || (WJV2_MIN_PHASEID_SIZE > *(pstruAsnMovement->phaseId)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnMovement->phaseId) = %d",
                     *(pstruAsnMovement->phaseId));
            return false;
        }
        pstruWjMovement->n32phaseId = *(pstruAsnMovement->phaseId);
        pstruWjMovement->u8phaseIdPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjMovement->u8phaseIdPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_MovementList_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_MovementList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_MovementList *pstruWjMovementList = (WJV2_STRU_MovementList *)pvoidWjDf;
    MovementList_t *pstruAsnMovementList = (MovementList_t *)pvoidAsnDf;
    Movement_t *pstruMovement_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_MOVEMENT_LEN < pstruWjMovementList->u8MovementNum) || (WJV2_MIN_LIST_MOVEMENT_LEN > pstruWjMovementList->u8MovementNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjMovementList->u8MovementNum = %d",
                 pstruWjMovementList->u8MovementNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjMovementList->u8MovementNum; u32i++)
    {
        pstruMovement_node = CALLOC(1, sizeof(Movement_t));
        if (NULL == pstruMovement_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_Movement_DfEnc(pstruMovement_node, &(pstruWjMovementList->struMovement[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Movement_DfEnc is err");
            FREEMEM(pstruMovement_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnMovementList->list), pstruMovement_node);
    }
    return true;
}
/**
* @brief     WJV2_MovementList_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_MovementList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_MovementList *pstruWjMovementList = (WJV2_STRU_MovementList *)pvoidWjDf;
    MovementList_t *pstruAsnMovementList = (MovementList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_MOVEMENT_LEN < pstruAsnMovementList->list.count) || (WJV2_MIN_LIST_MOVEMENT_LEN > pstruAsnMovementList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnMovementList->list.count = %d",
                 pstruAsnMovementList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnMovementList->list.count; u32i++)
    {
        n32Ret = WJV2_Movement_DfDec(pstruAsnMovementList->list.array[u32i],
                                     &(pstruWjMovementList->struMovement[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Movement_DfDec is err");
            return false;
        }
    }
    pstruWjMovementList->u8MovementNum = (uint8_t)u32i;
    return true;
}
/**
* @brief     WJV2_Node_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_Node_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Node *pstruWjNode = (WJV2_STRU_Node *)pvoidWjDf;
    Node_t *pstruAsnNode = (Node_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (WJV2_PRESENT == pstruWjNode->u8namePresent)
    {
        pstruAsnNode->name = CALLOC(1, sizeof(DescriptiveName_t));
        if (NULL == pstruAsnNode->name)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_DescriptiveName_DeEnc(pstruAsnNode->name, &(pstruWjNode->stria5name));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DescriptiveName_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnNode->name = NULL;
    }
    n32Ret = WJV2_NodeReferenceID_DfEnc(&(pstruAsnNode->id), &(pstruWjNode->struid));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfEnc is err");
        return false;
    }
    n32Ret = WJV2_Position3D_DfEnc(&(pstruAsnNode->refPos), &(pstruWjNode->strurefPos));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_Position3D_DfEnc is err");
        return false;
    }
    if (WJV2_PRESENT == pstruWjNode->u8inLinksPresent)
    {
        pstruAsnNode->inLinks = CALLOC(1, sizeof(struct LinkList));
        if (NULL == pstruAsnNode->inLinks)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_LinkList_DfEnc(pstruAsnNode->inLinks, &(pstruWjNode->struinLinks));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LinkList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnNode->inLinks = NULL;
    }

    if (WJV2_PRESENT == pstruWjNode->u8inLinks_exPresent)
    {
        pstruAsnNode->inLinks_ex = CALLOC(1, sizeof(struct LinkExList));
        if (NULL == pstruAsnNode->inLinks_ex)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_LinkExList_DfEnc(pstruAsnNode->inLinks_ex, &(pstruWjNode->struinLinks_ex));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LinkExList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnNode->inLinks_ex = NULL;
    }

    if (WJV2_PRESENT == pstruWjNode->u8prohibitedzonePresent)
    {
        pstruAsnNode->prohibitedzone = CALLOC(1, sizeof(struct ProhibitedZone));
        if (NULL == pstruAsnNode->prohibitedzone)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ProhibitedZone_DfEnc(pstruAsnNode->prohibitedzone, &(pstruWjNode->struprohibitedzone));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ProhibitedZone_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnNode->prohibitedzone = NULL;
    }
    return true;
}
/**
* @brief     WJV2_Node_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_Node_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Node *pstruWjNode = (WJV2_STRU_Node *)pvoidWjDf;
    Node_t *pstruAsnNode = (Node_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (NULL != pstruAsnNode->name)
    {
        n32Ret = WJV2_DescriptiveName_DeDec(pstruAsnNode->name, &(pstruWjNode->stria5name));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DescriptiveName_DeDec is err");
            return false;
        }
        pstruWjNode->u8namePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjNode->u8namePresent = WJV2_ABSENT;
    }
    n32Ret = WJV2_NodeReferenceID_DfDec(&(pstruAsnNode->id), &(pstruWjNode->struid));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfDec is err");
        return false;
    }
    n32Ret = WJV2_Position3D_DfDec(&(pstruAsnNode->refPos), &(pstruWjNode->strurefPos));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_Position3D_DfDec is err");
        return false;
    }
    if (NULL != pstruAsnNode->inLinks)
    {
        n32Ret = WJV2_LinkList_DfDec(pstruAsnNode->inLinks, &(pstruWjNode->struinLinks));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LinkList_DfDec is err");
            return false;
        }
        pstruWjNode->u8inLinksPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjNode->u8inLinksPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnNode->inLinks_ex)
    {
        n32Ret = WJV2_LinkExList_DfDec(pstruAsnNode->inLinks_ex, &(pstruWjNode->struinLinks_ex));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LinkExList_DfDec is err");
            return false;
        }
        pstruWjNode->u8inLinks_exPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjNode->u8inLinks_exPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnNode->prohibitedzone)
    {
        n32Ret = WJV2_ProhibitedZone_DfDec(pstruAsnNode->prohibitedzone, &(pstruWjNode->struprohibitedzone));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ProhibitedZone_DfDec is err");
            return false;
        }
        pstruWjNode->u8prohibitedzonePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjNode->u8prohibitedzonePresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_NodeList_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_NodeList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_NodeList *pstruWjNodeList = (WJV2_STRU_NodeList *)pvoidWjDf;
    NodeList_t *pstruAsnNodeList = (NodeList_t *)pvoidAsnDf;
    Node_t *pstruNode_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_NODE_LEN < pstruWjNodeList->u8NodeNum) || (WJV2_MIN_LIST_NODE_LEN > pstruWjNodeList->u8NodeNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjNodeList->u8NodeNum = %d",
                 pstruWjNodeList->u8NodeNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjNodeList->u8NodeNum; u32i++)
    {
        pstruNode_node = CALLOC(1, sizeof(Node_t));
        if (NULL == pstruNode_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_Node_DfEnc(pstruNode_node, &(pstruWjNodeList->struNode[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Node_DfEnc is err");
            FREEMEM(pstruNode_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnNodeList->list), pstruNode_node);
    }
    return true;
}
/**
* @brief     WJV2_NodeList_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_NodeList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_NodeList *pstruWjNodeList = (WJV2_STRU_NodeList *)pvoidWjDf;
    NodeList_t *pstruAsnNodeList = (NodeList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_NODE_LEN < pstruAsnNodeList->list.count) || (WJV2_MIN_LIST_NODE_LEN > pstruAsnNodeList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnNodeList->list.count = %d",
                 pstruAsnNodeList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnNodeList->list.count; u32i++)
    {
        n32Ret = WJV2_Node_DfDec(pstruAsnNodeList->list.array[u32i],
                                 &(pstruWjNodeList->struNode[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Node_DfDec is err");
            return false;
        }
    }
    pstruWjNodeList->u8NodeNum = (uint8_t)u32i;
    return true;
}
/**
* @brief     WJV2_NodeReferenceID_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_NodeReferenceID_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_NodeReferenceID *pstruWjNodeReferenceID = (WJV2_STRU_NodeReferenceID *)pvoidWjDf;
    NodeReferenceID_t *pstruAsnNodeReferenceID = (NodeReferenceID_t *)pvoidAsnDf;
    if (WJV2_PRESENT == pstruWjNodeReferenceID->u8regionPresent)
    {
        pstruAsnNodeReferenceID->region = CALLOC(1, sizeof(RoadRegulatorID_t));
        if (NULL == pstruAsnNodeReferenceID->region)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_ROADREGULATORID_SIZE < pstruWjNodeReferenceID->n32region) || (WJV2_MIN_ROADREGULATORID_SIZE > pstruWjNodeReferenceID->n32region))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjNodeReferenceID->n32region = %d",
                     pstruWjNodeReferenceID->n32region);
            return false;
        }
        *(pstruAsnNodeReferenceID->region) = pstruWjNodeReferenceID->n32region;
    }
    else
    {
        pstruAsnNodeReferenceID->region = NULL;
    }
    if ((WJV2_MAX_NODEID_SIZE < pstruWjNodeReferenceID->n32id) || (WJV2_MIN_NODEID_SIZE > pstruWjNodeReferenceID->n32id))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjNodeReferenceID->n32id = %d",
                 pstruWjNodeReferenceID->n32id);
        return false;
    }
    pstruAsnNodeReferenceID->id = pstruWjNodeReferenceID->n32id;
    return true;
}
/**
* @brief     WJV2_NodeReferenceID_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_NodeReferenceID_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_NodeReferenceID *pstruWjNodeReferenceID = (WJV2_STRU_NodeReferenceID *)pvoidWjDf;
    NodeReferenceID_t *pstruAsnNodeReferenceID = (NodeReferenceID_t *)pvoidAsnDf;
    if (NULL != pstruAsnNodeReferenceID->region)
    {
        if ((WJV2_MAX_ROADREGULATORID_SIZE < *(pstruAsnNodeReferenceID->region)) || (WJV2_MIN_ROADREGULATORID_SIZE > *(pstruAsnNodeReferenceID->region)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnNodeReferenceID->region) = %d",
                     *(pstruAsnNodeReferenceID->region));
            return false;
        }
        pstruWjNodeReferenceID->n32region = *(pstruAsnNodeReferenceID->region);
        pstruWjNodeReferenceID->u8regionPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjNodeReferenceID->u8regionPresent = WJV2_ABSENT;
    }
    if ((WJV2_MAX_NODEID_SIZE < pstruAsnNodeReferenceID->id) || (WJV2_MIN_NODEID_SIZE > pstruAsnNodeReferenceID->id))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnNodeReferenceID->id = %d",
                 pstruAsnNodeReferenceID->id);
        return false;
    }
    pstruWjNodeReferenceID->n32id = pstruAsnNodeReferenceID->id;
    return true;
}
/**
* @brief     WJV2_ParticipantData_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_ParticipantData_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ParticipantData *pstruWjParticipantData = (WJV2_STRU_ParticipantData *)pvoidWjDf;
    ParticipantData_t *pstruAsnParticipantData = (ParticipantData_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    pstruAsnParticipantData->ptcType = pstruWjParticipantData->enumptcType;
    if ((WJV2_MAX_PTCID_SIZE < pstruWjParticipantData->n32ptcId) || (WJV2_MIN_PTCID_SIZE > pstruWjParticipantData->n32ptcId))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjParticipantData->n32ptcId = %d",
                 pstruWjParticipantData->n32ptcId);
        return false;
    }
    pstruAsnParticipantData->ptcId = pstruWjParticipantData->n32ptcId;
    pstruAsnParticipantData->source = pstruWjParticipantData->enumsource;
    if (WJV2_PRESENT == pstruWjParticipantData->u8OCTidPresent)
    {
        pstruAsnParticipantData->id = CALLOC(1, sizeof(OCTET_STRING_t));
        if (NULL == pstruAsnParticipantData->id)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        pstruAsnParticipantData->id->size = WJV2_MAX_OCTID_SIZE;
        pstruAsnParticipantData->id->buf = CALLOC(pstruAsnParticipantData->id->size, sizeof(uint8_t));
        if (NULL == pstruAsnParticipantData->id->buf)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        memcpy(pstruAsnParticipantData->id->buf, pstruWjParticipantData->u8OCTid, pstruAsnParticipantData->id->size);
    }
    else
    {
        pstruAsnParticipantData->id = NULL;
    }
    if ((WJV2_MAX_DSECOND_SIZE < pstruWjParticipantData->n32secMark) || (WJV2_MIN_DSECOND_SIZE > pstruWjParticipantData->n32secMark))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjParticipantData->n32secMark = %d",
                 pstruWjParticipantData->n32secMark);
        return false;
    }
    pstruAsnParticipantData->secMark = pstruWjParticipantData->n32secMark;
    n32Ret = WJV2_PositionOffsetLLV_DfEnc(&(pstruAsnParticipantData->pos), &(pstruWjParticipantData->strupos));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PositionOffsetLLV_DfEnc is err");
        return false;
    }
    n32Ret = WJV2_PositionConfidenceSet_DfEnc(&(pstruAsnParticipantData->posConfidence), &(pstruWjParticipantData->struposConfidence));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PositionConfidenceSet_DfEnc is err");
        return false;
    }
    if (WJV2_PRESENT == pstruWjParticipantData->u8transmissionPresent)
    {
        pstruAsnParticipantData->transmission = CALLOC(1, sizeof(TransmissionState_t));
        if (NULL == pstruAsnParticipantData->transmission)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnParticipantData->transmission) = pstruWjParticipantData->enumtransmission;
    }
    else
    {
        pstruAsnParticipantData->transmission = NULL;
    }
    if ((WJV2_MAX_SPEED_SIZE < pstruWjParticipantData->n32speed) || (WJV2_MIN_SPEED_SIZE > pstruWjParticipantData->n32speed))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjParticipantData->n32speed = %d",
                 pstruWjParticipantData->n32speed);
        return false;
    }
    pstruAsnParticipantData->speed = pstruWjParticipantData->n32speed;
    if ((WJV2_MAX_HEADING_SIZE < pstruWjParticipantData->n32heading) || (WJV2_MIN_HEADING_SIZE > pstruWjParticipantData->n32heading))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjParticipantData->n32heading = %d",
                 pstruWjParticipantData->n32heading);
        return false;
    }
    pstruAsnParticipantData->heading = pstruWjParticipantData->n32heading;
    if (WJV2_PRESENT == pstruWjParticipantData->u8anglePresent)
    {
        pstruAsnParticipantData->angle = CALLOC(1, sizeof(SteeringWheelAngle_t));
        if (NULL == pstruAsnParticipantData->angle)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_STEERINGWHEELANGLE_SIZE < pstruWjParticipantData->n32angle) || (WJV2_MIN_STEERINGWHEELANGLE_SIZE > pstruWjParticipantData->n32angle))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjParticipantData->n32angle = %d",
                     pstruWjParticipantData->n32angle);
            return false;
        }
        *(pstruAsnParticipantData->angle) = pstruWjParticipantData->n32angle;
    }
    else
    {
        pstruAsnParticipantData->angle = NULL;
    }
    if (WJV2_PRESENT == pstruWjParticipantData->u8motionCfdPresent)
    {
        pstruAsnParticipantData->motionCfd = CALLOC(1, sizeof(struct MotionConfidenceSet));
        if (NULL == pstruAsnParticipantData->motionCfd)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_MotionConfidenceSet_DfEnc(pstruAsnParticipantData->motionCfd, &(pstruWjParticipantData->strumotionCfd));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_MotionConfidenceSet_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnParticipantData->motionCfd = NULL;
    }
    if (WJV2_PRESENT == pstruWjParticipantData->u8accelSetPresent)
    {
        pstruAsnParticipantData->accelSet = CALLOC(1, sizeof(struct AccelerationSet4Way));
        if (NULL == pstruAsnParticipantData->accelSet)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_AccelerationSet4Way_DfEnc(pstruAsnParticipantData->accelSet, &(pstruWjParticipantData->struaccelSet));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AccelerationSet4Way_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnParticipantData->accelSet = NULL;
    }
    n32Ret = WJV2_VehicleSize_DfEnc(&(pstruAsnParticipantData->size), &(pstruWjParticipantData->strusize));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_VehicleSize_DfEnc is err");
        return false;
    }
    if (WJV2_PRESENT == pstruWjParticipantData->u8vehicleClassPresent)
    {
        pstruAsnParticipantData->vehicleClass = CALLOC(1, sizeof(struct VehicleClassification));
        if (NULL == pstruAsnParticipantData->vehicleClass)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_VehicleClassification_DfEnc(pstruAsnParticipantData->vehicleClass, &(pstruWjParticipantData->struvehicleClass));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_VehicleClassification_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnParticipantData->vehicleClass = NULL;
    }
    return true;
}
/**
* @brief     WJV2_ParticipantData_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_ParticipantData_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ParticipantData *pstruWjParticipantData = (WJV2_STRU_ParticipantData *)pvoidWjDf;
    ParticipantData_t *pstruAsnParticipantData = (ParticipantData_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    pstruWjParticipantData->enumptcType = pstruAsnParticipantData->ptcType;
    if ((WJV2_MAX_PTCID_SIZE < pstruAsnParticipantData->ptcId) || (WJV2_MIN_PTCID_SIZE > pstruAsnParticipantData->ptcId))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnParticipantData->ptcId = %d",
                 pstruAsnParticipantData->ptcId);
        return false;
    }
    pstruWjParticipantData->n32ptcId = pstruAsnParticipantData->ptcId;
    pstruWjParticipantData->enumsource = pstruAsnParticipantData->source;
    if (NULL != pstruAsnParticipantData->id)
    {
        if (WJV2_MAX_OCTID_SIZE != pstruAsnParticipantData->id->size)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruAsnParticipantData->id->size = %d",
                     pstruAsnParticipantData->id->size);
            return false;
        }
        memcpy(pstruWjParticipantData->u8OCTid, pstruAsnParticipantData->id->buf, pstruAsnParticipantData->id->size);
        pstruWjParticipantData->u8OCTidPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjParticipantData->u8OCTidPresent = WJV2_ABSENT;
    }
    if ((WJV2_MAX_DSECOND_SIZE < pstruAsnParticipantData->secMark) || (WJV2_MIN_DSECOND_SIZE > pstruAsnParticipantData->secMark))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnParticipantData->secMark = %d",
                 pstruAsnParticipantData->secMark);
        return false;
    }
    pstruWjParticipantData->n32secMark = pstruAsnParticipantData->secMark;
    n32Ret = WJV2_PositionOffsetLLV_DfDec(&(pstruAsnParticipantData->pos), &(pstruWjParticipantData->strupos));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PositionOffsetLLV_DfDec is err");
        return false;
    }
    n32Ret = WJV2_PositionConfidenceSet_DfDec(&(pstruAsnParticipantData->posConfidence), &(pstruWjParticipantData->struposConfidence));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PositionConfidenceSet_DfDec is err");
        return false;
    }
    if (NULL != pstruAsnParticipantData->transmission)
    {
        pstruWjParticipantData->enumtransmission = *(pstruAsnParticipantData->transmission);
        pstruWjParticipantData->u8transmissionPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjParticipantData->u8transmissionPresent = WJV2_ABSENT;
    }
    if ((WJV2_MAX_SPEED_SIZE < pstruAsnParticipantData->speed) || (WJV2_MIN_SPEED_SIZE > pstruAsnParticipantData->speed))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnParticipantData->speed = %d",
                 pstruAsnParticipantData->speed);
        return false;
    }
    pstruWjParticipantData->n32speed = pstruAsnParticipantData->speed;
    if ((WJV2_MAX_HEADING_SIZE < pstruAsnParticipantData->heading) || (WJV2_MIN_HEADING_SIZE > pstruAsnParticipantData->heading))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnParticipantData->heading = %d",
                 pstruAsnParticipantData->heading);
        return false;
    }
    pstruWjParticipantData->n32heading = pstruAsnParticipantData->heading;
    if (NULL != pstruAsnParticipantData->angle)
    {
        if ((WJV2_MAX_STEERINGWHEELANGLE_SIZE < *(pstruAsnParticipantData->angle)) || (WJV2_MIN_STEERINGWHEELANGLE_SIZE > *(pstruAsnParticipantData->angle)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnParticipantData->angle) = %d",
                     *(pstruAsnParticipantData->angle));
            return false;
        }
        pstruWjParticipantData->n32angle = *(pstruAsnParticipantData->angle);
        pstruWjParticipantData->u8anglePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjParticipantData->u8anglePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnParticipantData->motionCfd)
    {
        n32Ret = WJV2_MotionConfidenceSet_DfDec(pstruAsnParticipantData->motionCfd, &(pstruWjParticipantData->strumotionCfd));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_MotionConfidenceSet_DfDec is err");
            return false;
        }
        pstruWjParticipantData->u8motionCfdPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjParticipantData->u8motionCfdPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnParticipantData->accelSet)
    {
        n32Ret = WJV2_AccelerationSet4Way_DfDec(pstruAsnParticipantData->accelSet, &(pstruWjParticipantData->struaccelSet));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AccelerationSet4Way_DfDec is err");
            return false;
        }
        pstruWjParticipantData->u8accelSetPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjParticipantData->u8accelSetPresent = WJV2_ABSENT;
    }
    n32Ret = WJV2_VehicleSize_DfDec(&(pstruAsnParticipantData->size), &(pstruWjParticipantData->strusize));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_VehicleSize_DfDec is err");
        return false;
    }
    if (NULL != pstruAsnParticipantData->vehicleClass)
    {
        n32Ret = WJV2_VehicleClassification_DfDec(pstruAsnParticipantData->vehicleClass, &(pstruWjParticipantData->struvehicleClass));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_VehicleClassification_DfDec is err");
            return false;
        }
        pstruWjParticipantData->u8vehicleClassPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjParticipantData->u8vehicleClassPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_ParticipantList_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_ParticipantList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ParticipantList *pstruWjParticipantList = (WJV2_STRU_ParticipantList *)pvoidWjDf;
    ParticipantList_t *pstruAsnParticipantList = (ParticipantList_t *)pvoidAsnDf;
    ParticipantData_t *pstruParticipantData_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_PARTICIPANTDATA_LEN < pstruWjParticipantList->u8ParticipantDataNum) || (WJV2_MIN_LIST_PARTICIPANTDATA_LEN > pstruWjParticipantList->u8ParticipantDataNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjParticipantList->u8ParticipantDataNum = %d",
                 pstruWjParticipantList->u8ParticipantDataNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjParticipantList->u8ParticipantDataNum; u32i++)
    {
        pstruParticipantData_node = CALLOC(1, sizeof(ParticipantData_t));
        if (NULL == pstruParticipantData_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ParticipantData_DfEnc(pstruParticipantData_node, &(pstruWjParticipantList->struParticipantData[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ParticipantData_DfEnc is err");
            FREEMEM(pstruParticipantData_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnParticipantList->list), pstruParticipantData_node);
    }
    return true;
}
/**
* @brief     WJV2_ParticipantList_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_ParticipantList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ParticipantList *pstruWjParticipantList = (WJV2_STRU_ParticipantList *)pvoidWjDf;
    ParticipantList_t *pstruAsnParticipantList = (ParticipantList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_PARTICIPANTDATA_LEN < pstruAsnParticipantList->list.count) || (WJV2_MIN_LIST_PARTICIPANTDATA_LEN > pstruAsnParticipantList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnParticipantList->list.count = %d",
                 pstruAsnParticipantList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnParticipantList->list.count; u32i++)
    {
        n32Ret = WJV2_ParticipantData_DfDec(pstruAsnParticipantList->list.array[u32i],
                                            &(pstruWjParticipantList->struParticipantData[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ParticipantData_DfDec is err");
            return false;
        }
    }
    pstruWjParticipantList->u8ParticipantDataNum = (uint8_t)u32i;
    return true;
}
/**
* @brief     WJV2_PathHistory_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PathHistory_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PathHistory *pstruWjPathHistory = (WJV2_STRU_PathHistory *)pvoidWjDf;
    PathHistory_t *pstruAsnPathHistory = (PathHistory_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (WJV2_PRESENT == pstruWjPathHistory->u8initialPositionPresent)
    {
        pstruAsnPathHistory->initialPosition = CALLOC(1, sizeof(struct FullPositionVector));
        if (NULL == pstruAsnPathHistory->initialPosition)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        n32Ret = WJV2_FullPositionVector_DfEnc(pstruAsnPathHistory->initialPosition, &(pstruWjPathHistory->struinitialPosition));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_FullPositionVector_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnPathHistory->initialPosition = NULL;
    }
    if (WJV2_PRESENT == pstruWjPathHistory->u8currGNSSstatusPresent)
    {
        pstruAsnPathHistory->currGNSSstatus = CALLOC(1, sizeof(GNSSstatus_t));
        if (NULL == pstruAsnPathHistory->currGNSSstatus)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        n32Ret = WJV2_GNSSstatus_DeEnc(pstruAsnPathHistory->currGNSSstatus, &(pstruWjPathHistory->strbitcurrGNSSstatus));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_GNSSstatus_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnPathHistory->currGNSSstatus = NULL;
    }
    n32Ret = WJV2_PathHistoryPointList_DfEnc(&(pstruAsnPathHistory->crumbData), &(pstruWjPathHistory->strucrumbData));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PathHistoryPointList_DfEnc is err");
        return false;
    }
    return true;
}
/**
* @brief     WJV2_PathHistory_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PathHistory_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PathHistory *pstruWjPathHistory = (WJV2_STRU_PathHistory *)pvoidWjDf;
    PathHistory_t *pstruAsnPathHistory = (PathHistory_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (NULL != pstruAsnPathHistory->initialPosition)
    {
        n32Ret = WJV2_FullPositionVector_DfDec(pstruAsnPathHistory->initialPosition, &(pstruWjPathHistory->struinitialPosition));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_FullPositionVector_DfDec is err");
            return false;
        }
        pstruWjPathHistory->u8initialPositionPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPathHistory->u8initialPositionPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnPathHistory->currGNSSstatus)
    {
        n32Ret = WJV2_GNSSstatus_DeDec(pstruAsnPathHistory->currGNSSstatus, &(pstruWjPathHistory->strbitcurrGNSSstatus));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_GNSSstatus_DeDec is err");
            return false;
        }
        pstruWjPathHistory->u8currGNSSstatusPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPathHistory->u8currGNSSstatusPresent = WJV2_ABSENT;
    }
    n32Ret = WJV2_PathHistoryPointList_DfDec(&(pstruAsnPathHistory->crumbData), &(pstruWjPathHistory->strucrumbData));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PathHistoryPointList_DfDec is err");
        return false;
    }
    return true;
}
/**
* @brief     WJV2_PathHistoryPoint_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PathHistoryPoint_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PathHistoryPoint *pstruWjPathHistoryPoint = (WJV2_STRU_PathHistoryPoint *)pvoidWjDf;
    PathHistoryPoint_t *pstruAsnPathHistoryPoint = (PathHistoryPoint_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_PositionOffsetLLV_DfEnc(&(pstruAsnPathHistoryPoint->llvOffset), &(pstruWjPathHistoryPoint->strullvOffset));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PositionOffsetLLV_DfEnc is err");
        return false;
    }
    if ((WJV2_MAX_TIMEOFFSET_SIZE < pstruWjPathHistoryPoint->n32timeOffset) || (WJV2_MIN_TIMEOFFSET_SIZE > pstruWjPathHistoryPoint->n32timeOffset))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPathHistoryPoint->n32timeOffset = %d",
                 pstruWjPathHistoryPoint->n32timeOffset);
        return false;
    }
    pstruAsnPathHistoryPoint->timeOffset = pstruWjPathHistoryPoint->n32timeOffset;
    if (WJV2_PRESENT == pstruWjPathHistoryPoint->u8speedPresent)
    {
        pstruAsnPathHistoryPoint->speed = CALLOC(1, sizeof(Speed_t));
        if (NULL == pstruAsnPathHistoryPoint->speed)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_SPEED_SIZE < pstruWjPathHistoryPoint->n32speed) || (WJV2_MIN_SPEED_SIZE > pstruWjPathHistoryPoint->n32speed))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjPathHistoryPoint->n32speed = %d",
                     pstruWjPathHistoryPoint->n32speed);
            return false;
        }
        *(pstruAsnPathHistoryPoint->speed) = pstruWjPathHistoryPoint->n32speed;
    }
    else
    {
        pstruAsnPathHistoryPoint->speed = NULL;
    }
    if (WJV2_PRESENT == pstruWjPathHistoryPoint->u8posAccuracyPresent)
    {
        pstruAsnPathHistoryPoint->posAccuracy = CALLOC(1, sizeof(struct PositionConfidenceSet));
        if (NULL == pstruAsnPathHistoryPoint->posAccuracy)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PositionConfidenceSet_DfEnc(pstruAsnPathHistoryPoint->posAccuracy, &(pstruWjPathHistoryPoint->struposAccuracy));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionConfidenceSet_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnPathHistoryPoint->posAccuracy = NULL;
    }
    if (WJV2_PRESENT == pstruWjPathHistoryPoint->u8headingPresent)
    {
        pstruAsnPathHistoryPoint->heading = CALLOC(1, sizeof(CoarseHeading_t));
        if (NULL == pstruAsnPathHistoryPoint->heading)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_COARSEHEADING_SIZE < pstruWjPathHistoryPoint->n32heading) || (WJV2_MIN_COARSEHEADING_SIZE > pstruWjPathHistoryPoint->n32heading))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjPathHistoryPoint->n32heading = %d",
                     pstruWjPathHistoryPoint->n32heading);
            return false;
        }
        *(pstruAsnPathHistoryPoint->heading) = pstruWjPathHistoryPoint->n32heading;
    }
    else
    {
        pstruAsnPathHistoryPoint->heading = NULL;
    }
    return true;
}
/**
* @brief     WJV2_PathHistoryPoint_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PathHistoryPoint_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PathHistoryPoint *pstruWjPathHistoryPoint = (WJV2_STRU_PathHistoryPoint *)pvoidWjDf;
    PathHistoryPoint_t *pstruAsnPathHistoryPoint = (PathHistoryPoint_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_PositionOffsetLLV_DfDec(&(pstruAsnPathHistoryPoint->llvOffset), &(pstruWjPathHistoryPoint->strullvOffset));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PositionOffsetLLV_DfDec is err");
        return false;
    }
    if ((WJV2_MAX_TIMEOFFSET_SIZE < pstruAsnPathHistoryPoint->timeOffset) || (WJV2_MIN_TIMEOFFSET_SIZE > pstruAsnPathHistoryPoint->timeOffset))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPathHistoryPoint->timeOffset = %d",
                 pstruAsnPathHistoryPoint->timeOffset);
        return false;
    }
    pstruWjPathHistoryPoint->n32timeOffset = pstruAsnPathHistoryPoint->timeOffset;
    if (NULL != pstruAsnPathHistoryPoint->speed)
    {
        if ((WJV2_MAX_SPEED_SIZE < *(pstruAsnPathHistoryPoint->speed)) || (WJV2_MIN_SPEED_SIZE > *(pstruAsnPathHistoryPoint->speed)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnPathHistoryPoint->speed) = %d",
                     *(pstruAsnPathHistoryPoint->speed));
            return false;
        }
        pstruWjPathHistoryPoint->n32speed = *(pstruAsnPathHistoryPoint->speed);
        pstruWjPathHistoryPoint->u8speedPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPathHistoryPoint->u8speedPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnPathHistoryPoint->posAccuracy)
    {
        n32Ret = WJV2_PositionConfidenceSet_DfDec(pstruAsnPathHistoryPoint->posAccuracy, &(pstruWjPathHistoryPoint->struposAccuracy));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionConfidenceSet_DfDec is err");
            return false;
        }
        pstruWjPathHistoryPoint->u8posAccuracyPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPathHistoryPoint->u8posAccuracyPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnPathHistoryPoint->heading)
    {
        if ((WJV2_MAX_HEADING_SIZE < *(pstruAsnPathHistoryPoint->heading)) || (WJV2_MIN_HEADING_SIZE > *(pstruAsnPathHistoryPoint->heading)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnPathHistoryPoint->heading) = %d",
                     *(pstruAsnPathHistoryPoint->heading));
            return false;
        }
        pstruWjPathHistoryPoint->n32heading = *(pstruAsnPathHistoryPoint->heading);
        pstruWjPathHistoryPoint->u8headingPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPathHistoryPoint->u8headingPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_PathHistoryPointList_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PathHistoryPointList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PathHistoryPointList *pstruWjPathHistoryPointList = (WJV2_STRU_PathHistoryPointList *)pvoidWjDf;
    PathHistoryPointList_t *pstruAsnPathHistoryPointList = (PathHistoryPointList_t *)pvoidAsnDf;
    PathHistoryPoint_t *pstruPathHistoryPoint_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_PATHHISTORYPOINT_LEN < pstruWjPathHistoryPointList->u8PathHistoryPointNum) || (WJV2_MIN_LIST_PATHHISTORYPOINT_LEN > pstruWjPathHistoryPointList->u8PathHistoryPointNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPathHistoryPointList->u8PathHistoryPointNum = %d",
                 pstruWjPathHistoryPointList->u8PathHistoryPointNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjPathHistoryPointList->u8PathHistoryPointNum; u32i++)
    {
        pstruPathHistoryPoint_node = CALLOC(1, sizeof(PathHistoryPoint_t));
        if (NULL == pstruPathHistoryPoint_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PathHistoryPoint_DfEnc(pstruPathHistoryPoint_node, &(pstruWjPathHistoryPointList->struPathHistoryPoint[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PathHistoryPoint_DfEnc is err");
            FREEMEM(pstruPathHistoryPoint_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnPathHistoryPointList->list), pstruPathHistoryPoint_node);
    }
    return true;
}
/**
* @brief     WJV2_PathHistoryPointList_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PathHistoryPointList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PathHistoryPointList *pstruWjPathHistoryPointList = (WJV2_STRU_PathHistoryPointList *)pvoidWjDf;
    PathHistoryPointList_t *pstruAsnPathHistoryPointList = (PathHistoryPointList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_PATHHISTORYPOINT_LEN < pstruAsnPathHistoryPointList->list.count) || (WJV2_MIN_LIST_PATHHISTORYPOINT_LEN > pstruAsnPathHistoryPointList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPathHistoryPointList->list.count = %d",
                 pstruAsnPathHistoryPointList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnPathHistoryPointList->list.count; u32i++)
    {
        n32Ret = WJV2_PathHistoryPoint_DfDec(pstruAsnPathHistoryPointList->list.array[u32i],
                                             &(pstruWjPathHistoryPointList->struPathHistoryPoint[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PathHistoryPoint_DfDec is err");
            return false;
        }
    }
    pstruWjPathHistoryPointList->u8PathHistoryPointNum = (uint8_t)u32i;
    return true;
}
/**
* @brief     WJV2_PathPointList_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PathPointList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PathPointList *pstruWjPathPointList = (WJV2_STRU_PathPointList *)pvoidWjDf;
    PathPointList_t *pstruAsnPathPointList = (PathPointList_t *)pvoidAsnDf;
    PositionOffsetLLV_t *pstruPositionOffsetLLV_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_POSITIONOFFSETLLV_LEN < pstruWjPathPointList->u8PositionOffsetLLVNum) || (WJV2_MIN_LIST_POSITIONOFFSETLLV_LEN > pstruWjPathPointList->u8PositionOffsetLLVNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPathPointList->u8PositionOffsetLLVNum = %d",
                 pstruWjPathPointList->u8PositionOffsetLLVNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjPathPointList->u8PositionOffsetLLVNum; u32i++)
    {
        pstruPositionOffsetLLV_node = CALLOC(1, sizeof(PositionOffsetLLV_t));
        if (NULL == pstruPositionOffsetLLV_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PositionOffsetLLV_DfEnc(pstruPositionOffsetLLV_node, &(pstruWjPathPointList->struPositionOffsetLLV[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionOffsetLLV_DfEnc is err");
            FREEMEM(pstruPositionOffsetLLV_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnPathPointList->list), pstruPositionOffsetLLV_node);
    }
    return true;
}
/**
* @brief     WJV2_PathPointList_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PathPointList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PathPointList *pstruWjPathPointList = (WJV2_STRU_PathPointList *)pvoidWjDf;
    PathPointList_t *pstruAsnPathPointList = (PathPointList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_POSITIONOFFSETLLV_LEN < pstruAsnPathPointList->list.count) || (WJV2_MIN_LIST_POSITIONOFFSETLLV_LEN > pstruAsnPathPointList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPathPointList->list.count = %d",
                 pstruAsnPathPointList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnPathPointList->list.count; u32i++)
    {
        n32Ret = WJV2_PositionOffsetLLV_DfDec(pstruAsnPathPointList->list.array[u32i],
                                              &(pstruWjPathPointList->struPositionOffsetLLV[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionOffsetLLV_DfDec is err");
            return false;
        }
    }
    pstruWjPathPointList->u8PositionOffsetLLVNum = (uint8_t)u32i;
    return true;
}
/**
* @brief     WJV2_PathPrediction_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PathPrediction_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PathPrediction *pstruWjPathPrediction = (WJV2_STRU_PathPrediction *)pvoidWjDf;
    PathPrediction_t *pstruAsnPathPrediction = (PathPrediction_t *)pvoidAsnDf;
    if ((WJV2_MAX_RADIUSOFCURVATURE_SIZE < pstruWjPathPrediction->n32radiusOfCurve) || (WJV2_MIN_RADIUSOFCURVATURE_SIZE > pstruWjPathPrediction->n32radiusOfCurve))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPathPrediction->n32radiusOfCurve = %d",
                 pstruWjPathPrediction->n32radiusOfCurve);
        return false;
    }
    pstruAsnPathPrediction->radiusOfCurve = pstruWjPathPrediction->n32radiusOfCurve;
    if ((WJV2_MAX_CONFIDENCE_SIZE < pstruWjPathPrediction->n32confidence) || (WJV2_MIN_CONFIDENCE_SIZE > pstruWjPathPrediction->n32confidence))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPathPrediction->n32confidence = %d",
                 pstruWjPathPrediction->n32confidence);
        return false;
    }
    pstruAsnPathPrediction->confidence = pstruWjPathPrediction->n32confidence;
    return true;
}
/**
* @brief     WJV2_PathPrediction_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PathPrediction_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PathPrediction *pstruWjPathPrediction = (WJV2_STRU_PathPrediction *)pvoidWjDf;
    PathPrediction_t *pstruAsnPathPrediction = (PathPrediction_t *)pvoidAsnDf;
    if ((WJV2_MAX_RADIUSOFCURVATURE_SIZE < pstruAsnPathPrediction->radiusOfCurve) || (WJV2_MIN_RADIUSOFCURVATURE_SIZE > pstruAsnPathPrediction->radiusOfCurve))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPathPrediction->radiusOfCurve = %d",
                 pstruAsnPathPrediction->radiusOfCurve);
        return false;
    }
    pstruWjPathPrediction->n32radiusOfCurve = pstruAsnPathPrediction->radiusOfCurve;
    if ((WJV2_MAX_CONFIDENCE_SIZE < pstruAsnPathPrediction->confidence) || (WJV2_MIN_CONFIDENCE_SIZE > pstruAsnPathPrediction->confidence))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPathPrediction->confidence = %d",
                 pstruAsnPathPrediction->confidence);
        return false;
    }
    pstruWjPathPrediction->n32confidence = pstruAsnPathPrediction->confidence;
    return true;
}
/**
* @brief     WJV2_Phase_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_Phase_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Phase *pstruWjPhase = (WJV2_STRU_Phase *)pvoidWjDf;
    Phase_t *pstruAsnPhase = (Phase_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_PHASEID_SIZE < pstruWjPhase->n32id) || (WJV2_MIN_PHASEID_SIZE > pstruWjPhase->n32id))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPhase->n32id = %d",
                 pstruWjPhase->n32id);
        return false;
    }
    pstruAsnPhase->id = pstruWjPhase->n32id;
    n32Ret = WJV2_PhaseStateList_DfEnc(&(pstruAsnPhase->phaseStates), &(pstruWjPhase->struphaseStates));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PhaseStateList_DfEnc is err");
        return false;
    }
    return true;
}
/**
* @brief     WJV2_Phase_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_Phase_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Phase *pstruWjPhase = (WJV2_STRU_Phase *)pvoidWjDf;
    Phase_t *pstruAsnPhase = (Phase_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_PHASEID_SIZE < pstruAsnPhase->id) || (WJV2_MIN_PHASEID_SIZE > pstruAsnPhase->id))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPhase->id = %d",
                 pstruAsnPhase->id);
        return false;
    }
    pstruWjPhase->n32id = pstruAsnPhase->id;
    n32Ret = WJV2_PhaseStateList_DfDec(&(pstruAsnPhase->phaseStates), &(pstruWjPhase->struphaseStates));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PhaseStateList_DfDec is err");
        return false;
    }
    return true;
}
/**
* @brief     WJV2_PhaseList_DfEnc编码函数
* @details   协议栈Df编解��中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PhaseList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PhaseList *pstruWjPhaseList = (WJV2_STRU_PhaseList *)pvoidWjDf;
    PhaseList_t *pstruAsnPhaseList = (PhaseList_t *)pvoidAsnDf;
    Phase_t *pstruPhase_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_PHASE_LEN < pstruWjPhaseList->u8PhaseNum) || (WJV2_MIN_LIST_PHASE_LEN > pstruWjPhaseList->u8PhaseNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPhaseList->u8PhaseNum = %d",
                 pstruWjPhaseList->u8PhaseNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjPhaseList->u8PhaseNum; u32i++)
    {
        pstruPhase_node = CALLOC(1, sizeof(Phase_t));
        if (NULL == pstruPhase_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_Phase_DfEnc(pstruPhase_node, &(pstruWjPhaseList->struPhase[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Phase_DfEnc is err");
            FREEMEM(pstruPhase_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnPhaseList->list), pstruPhase_node);
    }
    return true;
}
/**
* @brief     WJV2_PhaseList_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PhaseList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PhaseList *pstruWjPhaseList = (WJV2_STRU_PhaseList *)pvoidWjDf;
    PhaseList_t *pstruAsnPhaseList = (PhaseList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_PHASE_LEN < pstruAsnPhaseList->list.count) || (WJV2_MIN_LIST_PHASE_LEN > pstruAsnPhaseList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPhaseList->list.count = %d",
                 pstruAsnPhaseList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnPhaseList->list.count; u32i++)
    {
        n32Ret = WJV2_Phase_DfDec(pstruAsnPhaseList->list.array[u32i],
                                  &(pstruWjPhaseList->struPhase[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Phase_DfDec is err");
            return false;
        }
    }
    pstruWjPhaseList->u8PhaseNum = (uint8_t)u32i;
    return true;
}
/**
* @brief     WJV2_PhaseState_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PhaseState_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PhaseState *pstruWjPhaseState = (WJV2_STRU_PhaseState *)pvoidWjDf;
    PhaseState_t *pstruAsnPhaseState = (PhaseState_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    pstruAsnPhaseState->light = pstruWjPhaseState->enumlight;
    if (WJV2_PRESENT == pstruWjPhaseState->u8timingPresent)
    {
        pstruAsnPhaseState->timing = CALLOC(1, sizeof(struct TimeChangeDetails));
        if (NULL == pstruAsnPhaseState->timing)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_TimeChangeDetails_DfEnc(pstruAsnPhaseState->timing, &(pstruWjPhaseState->strutiming));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_TimeChangeDetails_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnPhaseState->timing = NULL;
    }
    return true;
}
/**
* @brief     WJV2_PhaseState_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PhaseState_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PhaseState *pstruWjPhaseState = (WJV2_STRU_PhaseState *)pvoidWjDf;
    PhaseState_t *pstruAsnPhaseState = (PhaseState_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    pstruWjPhaseState->enumlight = pstruAsnPhaseState->light;
    if (NULL != pstruAsnPhaseState->timing)
    {
        n32Ret = WJV2_TimeChangeDetails_DfDec(pstruAsnPhaseState->timing, &(pstruWjPhaseState->strutiming));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_TimeChangeDetails_DfDec is err");
            return false;
        }
        pstruWjPhaseState->u8timingPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPhaseState->u8timingPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_PhaseStateList_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PhaseStateList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PhaseStateList *pstruWjPhaseStateList = (WJV2_STRU_PhaseStateList *)pvoidWjDf;
    PhaseStateList_t *pstruAsnPhaseStateList = (PhaseStateList_t *)pvoidAsnDf;
    PhaseState_t *pstruPhaseState_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_PHASESTATE_LEN < pstruWjPhaseStateList->u8PhaseStateNum) || (WJV2_MIN_LIST_PHASESTATE_LEN > pstruWjPhaseStateList->u8PhaseStateNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPhaseStateList->u8PhaseStateNum = %d",
                 pstruWjPhaseStateList->u8PhaseStateNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjPhaseStateList->u8PhaseStateNum; u32i++)
    {
        pstruPhaseState_node = CALLOC(1, sizeof(PhaseState_t));
        if (NULL == pstruPhaseState_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PhaseState_DfEnc(pstruPhaseState_node, &(pstruWjPhaseStateList->struPhaseState[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PhaseState_DfEnc is err");
            FREEMEM(pstruPhaseState_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnPhaseStateList->list), pstruPhaseState_node);
    }
    return true;
}
/**
* @brief     WJV2_PhaseStateList_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PhaseStateList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PhaseStateList *pstruWjPhaseStateList = (WJV2_STRU_PhaseStateList *)pvoidWjDf;
    PhaseStateList_t *pstruAsnPhaseStateList = (PhaseStateList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_PHASESTATE_LEN < pstruAsnPhaseStateList->list.count) || (WJV2_MIN_LIST_PHASESTATE_LEN > pstruAsnPhaseStateList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPhaseStateList->list.count = %d",
                 pstruAsnPhaseStateList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnPhaseStateList->list.count; u32i++)
    {
        n32Ret = WJV2_PhaseState_DfDec(pstruAsnPhaseStateList->list.array[u32i],
                                       &(pstruWjPhaseStateList->struPhaseState[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PhaseState_DfDec is err");
            return false;
        }
    }
    pstruWjPhaseStateList->u8PhaseStateNum = (uint8_t)u32i;
    return true;
}
/**
* @brief     WJV2_PointList_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PointList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PointList *pstruWjPointList = (WJV2_STRU_PointList *)pvoidWjDf;
    PointList_t *pstruAsnPointList = (PointList_t *)pvoidAsnDf;
    RoadPoint_t *pstruRoadPoint_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_ROADPOINT_LEN < pstruWjPointList->u8RoadPointNum) || (WJV2_MIN_LIST_ROADPOINT_LEN > pstruWjPointList->u8RoadPointNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPointList->u8RoadPointNum = %d",
                 pstruWjPointList->u8RoadPointNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjPointList->u8RoadPointNum; u32i++)
    {
        pstruRoadPoint_node = CALLOC(1, sizeof(RoadPoint_t));
        if (NULL == pstruRoadPoint_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_RoadPoint_DfEnc(pstruRoadPoint_node, &(pstruWjPointList->struRoadPoint[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RoadPoint_DfEnc is err");
            FREEMEM(pstruRoadPoint_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnPointList->list), pstruRoadPoint_node);
    }
    return true;
}
/**
* @brief     WJV2_PointList_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PointList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PointList *pstruWjPointList = (WJV2_STRU_PointList *)pvoidWjDf;
    PointList_t *pstruAsnPointList = (PointList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_ROADPOINT_LEN < pstruAsnPointList->list.count) || (WJV2_MIN_LIST_ROADPOINT_LEN > pstruAsnPointList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPointList->list.count = %d",
                 pstruAsnPointList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnPointList->list.count; u32i++)
    {
        n32Ret = WJV2_RoadPoint_DfDec(pstruAsnPointList->list.array[u32i],
                                      &(pstruWjPointList->struRoadPoint[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RoadPoint_DfDec is err");
            return false;
        }
    }
    pstruWjPointList->u8RoadPointNum = (uint8_t)u32i;
    return true;
}
/**
* @brief     WJV2_PositionLL24B_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PositionLL24B_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PositionLL24B *pstruWjPositionLL24B = (WJV2_STRU_PositionLL24B *)pvoidWjDf;
    Position_LL_24B_t *pstruAsnPositionLL24B = (Position_LL_24B_t *)pvoidAsnDf;
    if ((WJV2_MAX_OFFSETLLB12_SIZE < pstruWjPositionLL24B->n32lon) || (WJV2_MIN_OFFSETLLB12_SIZE > pstruWjPositionLL24B->n32lon))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPositionLL24B->n32lon = %d",
                 pstruWjPositionLL24B->n32lon);
        return false;
    }
    pstruAsnPositionLL24B->lon = pstruWjPositionLL24B->n32lon;
    if ((WJV2_MAX_OFFSETLLB12_SIZE < pstruWjPositionLL24B->n32lat) || (WJV2_MIN_OFFSETLLB12_SIZE > pstruWjPositionLL24B->n32lat))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPositionLL24B->n32lat = %d",
                 pstruWjPositionLL24B->n32lat);
        return false;
    }
    pstruAsnPositionLL24B->lat = pstruWjPositionLL24B->n32lat;
    return true;
}
/**
* @brief     WJV2_PositionLL24B_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PositionLL24B_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PositionLL24B *pstruWjPositionLL24B = (WJV2_STRU_PositionLL24B *)pvoidWjDf;
    Position_LL_24B_t *pstruAsnPositionLL24B = (Position_LL_24B_t *)pvoidAsnDf;
    if ((WJV2_MAX_OFFSETLLB12_SIZE < pstruAsnPositionLL24B->lon) || (WJV2_MIN_OFFSETLLB12_SIZE > pstruAsnPositionLL24B->lon))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPositionLL24B->lon = %d",
                 pstruAsnPositionLL24B->lon);
        return false;
    }
    pstruWjPositionLL24B->n32lon = pstruAsnPositionLL24B->lon;
    if ((WJV2_MAX_OFFSETLLB12_SIZE < pstruAsnPositionLL24B->lat) || (WJV2_MIN_OFFSETLLB12_SIZE > pstruAsnPositionLL24B->lat))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPositionLL24B->lat = %d",
                 pstruAsnPositionLL24B->lat);
        return false;
    }
    pstruWjPositionLL24B->n32lat = pstruAsnPositionLL24B->lat;
    return true;
}
/**
* @brief     WJV2_PositionLL28B_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PositionLL28B_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PositionLL28B *pstruWjPositionLL28B = (WJV2_STRU_PositionLL28B *)pvoidWjDf;
    Position_LL_28B_t *pstruAsnPositionLL28B = (Position_LL_28B_t *)pvoidAsnDf;
    if ((WJV2_MAX_OFFSETLLB14_SIZE < pstruWjPositionLL28B->n32lon) || (WJV2_MIN_OFFSETLLB14_SIZE > pstruWjPositionLL28B->n32lon))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPositionLL28B->n32lon = %d",
                 pstruWjPositionLL28B->n32lon);
        return false;
    }
    pstruAsnPositionLL28B->lon = pstruWjPositionLL28B->n32lon;
    if ((WJV2_MAX_OFFSETLLB14_SIZE < pstruWjPositionLL28B->n32lat) || (WJV2_MIN_OFFSETLLB14_SIZE > pstruWjPositionLL28B->n32lat))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPositionLL28B->n32lat = %d",
                 pstruWjPositionLL28B->n32lat);
        return false;
    }
    pstruAsnPositionLL28B->lat = pstruWjPositionLL28B->n32lat;
    return true;
}
/**
* @brief     WJV2_PositionLL28B_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PositionLL28B_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PositionLL28B *pstruWjPositionLL28B = (WJV2_STRU_PositionLL28B *)pvoidWjDf;
    Position_LL_28B_t *pstruAsnPositionLL28B = (Position_LL_28B_t *)pvoidAsnDf;
    if ((WJV2_MAX_OFFSETLLB14_SIZE < pstruAsnPositionLL28B->lon) || (WJV2_MIN_OFFSETLLB14_SIZE > pstruAsnPositionLL28B->lon))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPositionLL28B->lon = %d",
                 pstruAsnPositionLL28B->lon);
        return false;
    }
    pstruWjPositionLL28B->n32lon = pstruAsnPositionLL28B->lon;
    if ((WJV2_MAX_OFFSETLLB14_SIZE < pstruAsnPositionLL28B->lat) || (WJV2_MIN_OFFSETLLB14_SIZE > pstruAsnPositionLL28B->lat))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPositionLL28B->lat = %d",
                 pstruAsnPositionLL28B->lat);
        return false;
    }
    pstruWjPositionLL28B->n32lat = pstruAsnPositionLL28B->lat;
    return true;
}
/**
* @brief     WJV2_PositionLL32B_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PositionLL32B_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PositionLL32B *pstruWjPositionLL32B = (WJV2_STRU_PositionLL32B *)pvoidWjDf;
    Position_LL_32B_t *pstruAsnPositionLL32B = (Position_LL_32B_t *)pvoidAsnDf;
    if ((WJV2_MAX_OFFSETLLB16_SIZE < pstruWjPositionLL32B->n32lon) || (WJV2_MIN_OFFSETLLB16_SIZE > pstruWjPositionLL32B->n32lon))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPositionLL32B->n32lon = %d",
                 pstruWjPositionLL32B->n32lon);
        return false;
    }
    pstruAsnPositionLL32B->lon = pstruWjPositionLL32B->n32lon;
    if ((WJV2_MAX_OFFSETLLB16_SIZE < pstruWjPositionLL32B->n32lat) || (WJV2_MIN_OFFSETLLB16_SIZE > pstruWjPositionLL32B->n32lat))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPositionLL32B->n32lat = %d",
                 pstruWjPositionLL32B->n32lat);
        return false;
    }
    pstruAsnPositionLL32B->lat = pstruWjPositionLL32B->n32lat;
    return true;
}
/**
* @brief     WJV2_PositionLL32B_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PositionLL32B_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PositionLL32B *pstruWjPositionLL32B = (WJV2_STRU_PositionLL32B *)pvoidWjDf;
    Position_LL_32B_t *pstruAsnPositionLL32B = (Position_LL_32B_t *)pvoidAsnDf;
    if ((WJV2_MAX_OFFSETLLB16_SIZE < pstruAsnPositionLL32B->lon) || (WJV2_MIN_OFFSETLLB16_SIZE > pstruAsnPositionLL32B->lon))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPositionLL32B->lon = %d",
                 pstruAsnPositionLL32B->lon);
        return false;
    }
    pstruWjPositionLL32B->n32lon = pstruAsnPositionLL32B->lon;
    if ((WJV2_MAX_OFFSETLLB16_SIZE < pstruAsnPositionLL32B->lat) || (WJV2_MIN_OFFSETLLB16_SIZE > pstruAsnPositionLL32B->lat))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPositionLL32B->lat = %d",
                 pstruAsnPositionLL32B->lat);
        return false;
    }
    pstruWjPositionLL32B->n32lat = pstruAsnPositionLL32B->lat;
    return true;
}
/**
* @brief     WJV2_PositionLL36B_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PositionLL36B_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PositionLL36B *pstruWjPositionLL36B = (WJV2_STRU_PositionLL36B *)pvoidWjDf;
    Position_LL_36B_t *pstruAsnPositionLL36B = (Position_LL_36B_t *)pvoidAsnDf;
    if ((WJV2_MAX_OFFSETLLB18_SIZE < pstruWjPositionLL36B->n32lon) || (WJV2_MIN_OFFSETLLB18_SIZE > pstruWjPositionLL36B->n32lon))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPositionLL36B->n32lon = %d",
                 pstruWjPositionLL36B->n32lon);
        return false;
    }
    pstruAsnPositionLL36B->lon = pstruWjPositionLL36B->n32lon;
    if ((WJV2_MAX_OFFSETLLB18_SIZE < pstruWjPositionLL36B->n32lat) || (WJV2_MIN_OFFSETLLB18_SIZE > pstruWjPositionLL36B->n32lat))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPositionLL36B->n32lat = %d",
                 pstruWjPositionLL36B->n32lat);
        return false;
    }
    pstruAsnPositionLL36B->lat = pstruWjPositionLL36B->n32lat;
    return true;
}
/**
* @brief     WJV2_PositionLL36B_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PositionLL36B_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PositionLL36B *pstruWjPositionLL36B = (WJV2_STRU_PositionLL36B *)pvoidWjDf;
    Position_LL_36B_t *pstruAsnPositionLL36B = (Position_LL_36B_t *)pvoidAsnDf;
    if ((WJV2_MAX_OFFSETLLB18_SIZE < pstruAsnPositionLL36B->lon) || (WJV2_MIN_OFFSETLLB18_SIZE > pstruAsnPositionLL36B->lon))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPositionLL36B->lon = %d",
                 pstruAsnPositionLL36B->lon);
        return false;
    }
    pstruWjPositionLL36B->n32lon = pstruAsnPositionLL36B->lon;
    if ((WJV2_MAX_OFFSETLLB18_SIZE < pstruAsnPositionLL36B->lat) || (WJV2_MIN_OFFSETLLB18_SIZE > pstruAsnPositionLL36B->lat))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPositionLL36B->lat = %d",
                 pstruAsnPositionLL36B->lat);
        return false;
    }
    pstruWjPositionLL36B->n32lat = pstruAsnPositionLL36B->lat;
    return true;
}
/**
* @brief     WJV2_PositionLL44B_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PositionLL44B_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PositionLL44B *pstruWjPositionLL44B = (WJV2_STRU_PositionLL44B *)pvoidWjDf;
    Position_LL_44B_t *pstruAsnPositionLL44B = (Position_LL_44B_t *)pvoidAsnDf;
    if ((WJV2_MAX_OFFSETLLB22_SIZE < pstruWjPositionLL44B->n32lon) || (WJV2_MIN_OFFSETLLB22_SIZE > pstruWjPositionLL44B->n32lon))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPositionLL44B->n32lon = %d",
                 pstruWjPositionLL44B->n32lon);
        return false;
    }
    pstruAsnPositionLL44B->lon = pstruWjPositionLL44B->n32lon;
    if ((WJV2_MAX_OFFSETLLB22_SIZE < pstruWjPositionLL44B->n32lat) || (WJV2_MIN_OFFSETLLB22_SIZE > pstruWjPositionLL44B->n32lat))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPositionLL44B->n32lat = %d",
                 pstruWjPositionLL44B->n32lat);
        return false;
    }
    pstruAsnPositionLL44B->lat = pstruWjPositionLL44B->n32lat;
    return true;
}
/**
* @brief     WJV2_PositionLL44B_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PositionLL44B_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PositionLL44B *pstruWjPositionLL44B = (WJV2_STRU_PositionLL44B *)pvoidWjDf;
    Position_LL_44B_t *pstruAsnPositionLL44B = (Position_LL_44B_t *)pvoidAsnDf;
    if ((WJV2_MAX_OFFSETLLB22_SIZE < pstruAsnPositionLL44B->lon) || (WJV2_MIN_OFFSETLLB22_SIZE > pstruAsnPositionLL44B->lon))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPositionLL44B->lon = %d",
                 pstruAsnPositionLL44B->lon);
        return false;
    }
    pstruWjPositionLL44B->n32lon = pstruAsnPositionLL44B->lon;
    if ((WJV2_MAX_OFFSETLLB22_SIZE < pstruAsnPositionLL44B->lat) || (WJV2_MIN_OFFSETLLB22_SIZE > pstruAsnPositionLL44B->lat))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPositionLL44B->lat = %d",
                 pstruAsnPositionLL44B->lat);
        return false;
    }
    pstruWjPositionLL44B->n32lat = pstruAsnPositionLL44B->lat;
    return true;
}
/**
* @brief     WJV2_PositionLL48B_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PositionLL48B_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PositionLL48B *pstruWjPositionLL48B = (WJV2_STRU_PositionLL48B *)pvoidWjDf;
    Position_LL_48B_t *pstruAsnPositionLL48B = (Position_LL_48B_t *)pvoidAsnDf;
    if ((WJV2_MAX_OFFSETLLB24_SIZE < pstruWjPositionLL48B->n32lon) || (WJV2_MIN_OFFSETLLB24_SIZE > pstruWjPositionLL48B->n32lon))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPositionLL48B->n32lon = %d",
                 pstruWjPositionLL48B->n32lon);
        return false;
    }
    pstruAsnPositionLL48B->lon = pstruWjPositionLL48B->n32lon;
    if ((WJV2_MAX_OFFSETLLB24_SIZE < pstruWjPositionLL48B->n32lat) || (WJV2_MIN_OFFSETLLB24_SIZE > pstruWjPositionLL48B->n32lat))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPositionLL48B->n32lat = %d",
                 pstruWjPositionLL48B->n32lat);
        return false;
    }
    pstruAsnPositionLL48B->lat = pstruWjPositionLL48B->n32lat;
    return true;
}
/**
* @brief     WJV2_PositionLL48B_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PositionLL48B_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PositionLL48B *pstruWjPositionLL48B = (WJV2_STRU_PositionLL48B *)pvoidWjDf;
    Position_LL_48B_t *pstruAsnPositionLL48B = (Position_LL_48B_t *)pvoidAsnDf;
    if ((WJV2_MAX_OFFSETLLB24_SIZE < pstruAsnPositionLL48B->lon) || (WJV2_MIN_OFFSETLLB24_SIZE > pstruAsnPositionLL48B->lon))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPositionLL48B->lon = %d",
                 pstruAsnPositionLL48B->lon);
        return false;
    }
    pstruWjPositionLL48B->n32lon = pstruAsnPositionLL48B->lon;
    if ((WJV2_MAX_OFFSETLLB24_SIZE < pstruAsnPositionLL48B->lat) || (WJV2_MIN_OFFSETLLB24_SIZE > pstruAsnPositionLL48B->lat))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPositionLL48B->lat = %d",
                 pstruAsnPositionLL48B->lat);
        return false;
    }
    pstruWjPositionLL48B->n32lat = pstruAsnPositionLL48B->lat;
    return true;
}
/**
* @brief     WJV2_PositionLLmD64b_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PositionLLmD64b_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PositionLLmD64b *pstruWjPositionLLmD64b = (WJV2_STRU_PositionLLmD64b *)pvoidWjDf;
    Position_LLmD_64b_t *pstruAsnPositionLLmD64b = (Position_LLmD_64b_t *)pvoidAsnDf;
    if ((WJV2_MAX_LONGITUDE_SIZE < pstruWjPositionLLmD64b->n32lon) || (WJV2_MIN_LONGITUDE_SIZE > pstruWjPositionLLmD64b->n32lon))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPositionLLmD64b->n32lon = %d",
                 pstruWjPositionLLmD64b->n32lon);
        return false;
    }
    pstruAsnPositionLLmD64b->lon = pstruWjPositionLLmD64b->n32lon;
    if ((WJV2_MAX_LATITUDE_SIZE < pstruWjPositionLLmD64b->n32lat) || (WJV2_MIN_LATITUDE_SIZE > pstruWjPositionLLmD64b->n32lat))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPositionLLmD64b->n32lat = %d",
                 pstruWjPositionLLmD64b->n32lat);
        return false;
    }
    pstruAsnPositionLLmD64b->lat = pstruWjPositionLLmD64b->n32lat;
    return true;
}
/**
* @brief     WJV2_PositionLLmD64b_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PositionLLmD64b_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PositionLLmD64b *pstruWjPositionLLmD64b = (WJV2_STRU_PositionLLmD64b *)pvoidWjDf;
    Position_LLmD_64b_t *pstruAsnPositionLLmD64b = (Position_LLmD_64b_t *)pvoidAsnDf;
    if ((WJV2_MAX_LONGITUDE_SIZE < pstruAsnPositionLLmD64b->lon) || (WJV2_MIN_LONGITUDE_SIZE > pstruAsnPositionLLmD64b->lon))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPositionLLmD64b->lon = %d",
                 pstruAsnPositionLLmD64b->lon);
        return false;
    }
    pstruWjPositionLLmD64b->n32lon = pstruAsnPositionLLmD64b->lon;
    if ((WJV2_MAX_LATITUDE_SIZE < pstruAsnPositionLLmD64b->lat) || (WJV2_MIN_LATITUDE_SIZE > pstruAsnPositionLLmD64b->lat))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPositionLLmD64b->lat = %d",
                 pstruAsnPositionLLmD64b->lat);
        return false;
    }
    pstruWjPositionLLmD64b->n32lat = pstruAsnPositionLLmD64b->lat;
    return true;
}
/**
* @brief     WJV2_Position3D_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_Position3D_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Position3D *pstruWjPosition3D = (WJV2_STRU_Position3D *)pvoidWjDf;
    Position3D_t *pstruAsnPosition3D = (Position3D_t *)pvoidAsnDf;
    if ((WJV2_MAX_LATITUDE_SIZE < pstruWjPosition3D->n32lat) || (WJV2_MIN_LATITUDE_SIZE > pstruWjPosition3D->n32lat))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPosition3D->n32lat = %d",
                 pstruWjPosition3D->n32lat);
        return false;
    }
    pstruAsnPosition3D->lat = pstruWjPosition3D->n32lat;
    if ((WJV2_MAX_LONGITUDE_SIZE < pstruWjPosition3D->n32long) || (WJV2_MIN_LONGITUDE_SIZE > pstruWjPosition3D->n32long))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPosition3D->n32long = %d",
                 pstruWjPosition3D->n32long);
        return false;
    }
    pstruAsnPosition3D->Long = pstruWjPosition3D->n32long;
    if (WJV2_PRESENT == pstruWjPosition3D->u8elevationPresent)
    {
        pstruAsnPosition3D->elevation = CALLOC(1, sizeof(Elevation_t));
        if (NULL == pstruAsnPosition3D->elevation)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnPosition3D->elevation) = pstruWjPosition3D->n32elevation;
    }
    else
    {
        pstruAsnPosition3D->elevation = NULL;
    }
    return true;
}
/**
* @brief     WJV2_Position3D_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_Position3D_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Position3D *pstruWjPosition3D = (WJV2_STRU_Position3D *)pvoidWjDf;
    Position3D_t *pstruAsnPosition3D = (Position3D_t *)pvoidAsnDf;
    if ((WJV2_MAX_LATITUDE_SIZE < pstruAsnPosition3D->lat) || (WJV2_MIN_LATITUDE_SIZE > pstruAsnPosition3D->lat))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPosition3D->lat = %d",
                 pstruAsnPosition3D->lat);
        return false;
    }
    pstruWjPosition3D->n32lat = pstruAsnPosition3D->lat;
    if ((WJV2_MAX_LONGITUDE_SIZE < pstruAsnPosition3D->Long) || (WJV2_MIN_LONGITUDE_SIZE > pstruAsnPosition3D->Long))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPosition3D->Long = %d",
                 pstruAsnPosition3D->Long);
        return false;
    }
    pstruWjPosition3D->n32long = pstruAsnPosition3D->Long;
    if (NULL != pstruAsnPosition3D->elevation)
    {
        if ((WJV2_MAX_ELEVATION_SIZE < *(pstruAsnPosition3D->elevation)) || (WJV2_MIN_ELEVATION_SIZE > *(pstruAsnPosition3D->elevation)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnPosition3D->elevation) = %d",
                     *(pstruAsnPosition3D->elevation));
            return false;
        };
        pstruWjPosition3D->n32elevation = *(pstruAsnPosition3D->elevation);
    }
    else
    {
        pstruAsnPosition3D->elevation = NULL;
    }
    return true;
}
/**
* @brief     WJV2_PositionalAccuracy_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PositionalAccuracy_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PositionalAccuracy *pstruWjPositionalAccuracy = (WJV2_STRU_PositionalAccuracy *)pvoidWjDf;
    PositionalAccuracy_t *pstruAsnPositionalAccuracy = (PositionalAccuracy_t *)pvoidAsnDf;
    if ((WJV2_MAX_SEMIMAJORAXISACCURACY_SIZE < pstruWjPositionalAccuracy->n32semiMajor) || (WJV2_MIN_SEMIMAJORAXISACCURACY_SIZE > pstruWjPositionalAccuracy->n32semiMajor))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPositionalAccuracy->n32semiMajor = %d",
                 pstruWjPositionalAccuracy->n32semiMajor);
        return false;
    }
    pstruAsnPositionalAccuracy->semiMajor = pstruWjPositionalAccuracy->n32semiMajor;
    if ((WJV2_MAX_SEMIMINORAXISACCURACY_SIZE < pstruWjPositionalAccuracy->n32semiMinor) || (WJV2_MIN_SEMIMINORAXISACCURACY_SIZE > pstruWjPositionalAccuracy->n32semiMinor))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPositionalAccuracy->n32semiMinor = %d",
                 pstruWjPositionalAccuracy->n32semiMinor);
        return false;
    }
    pstruAsnPositionalAccuracy->semiMinor = pstruWjPositionalAccuracy->n32semiMinor;
    if ((WJV2_MAX_SEMIMAJORAXISORIENTATION_SIZE < pstruWjPositionalAccuracy->n32orientation) || (WJV2_MIN_SEMIMAJORAXISORIENTATION_SIZE > pstruWjPositionalAccuracy->n32orientation))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPositionalAccuracy->n32orientation = %d",
                 pstruWjPositionalAccuracy->n32orientation);
        return false;
    }
    pstruAsnPositionalAccuracy->orientation = pstruWjPositionalAccuracy->n32orientation;
    return true;
}
/**
* @brief     WJV2_PositionalAccuracy_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PositionalAccuracy_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PositionalAccuracy *pstruWjPositionalAccuracy = (WJV2_STRU_PositionalAccuracy *)pvoidWjDf;
    PositionalAccuracy_t *pstruAsnPositionalAccuracy = (PositionalAccuracy_t *)pvoidAsnDf;
    if ((WJV2_MAX_SEMIMAJORAXISACCURACY_SIZE < pstruAsnPositionalAccuracy->semiMajor) || (WJV2_MIN_SEMIMAJORAXISACCURACY_SIZE > pstruAsnPositionalAccuracy->semiMajor))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPositionalAccuracy->semiMajor = %d",
                 pstruAsnPositionalAccuracy->semiMajor);
        return false;
    }
    pstruWjPositionalAccuracy->n32semiMajor = pstruAsnPositionalAccuracy->semiMajor;
    if ((WJV2_MAX_SEMIMINORAXISACCURACY_SIZE < pstruAsnPositionalAccuracy->semiMinor) || (WJV2_MIN_SEMIMINORAXISACCURACY_SIZE > pstruAsnPositionalAccuracy->semiMinor))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPositionalAccuracy->semiMinor = %d",
                 pstruAsnPositionalAccuracy->semiMinor);
        return false;
    }
    pstruWjPositionalAccuracy->n32semiMinor = pstruAsnPositionalAccuracy->semiMinor;
    if ((WJV2_MAX_SEMIMAJORAXISORIENTATION_SIZE < pstruAsnPositionalAccuracy->orientation) || (WJV2_MIN_SEMIMAJORAXISORIENTATION_SIZE > pstruAsnPositionalAccuracy->orientation))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPositionalAccuracy->orientation = %d",
                 pstruAsnPositionalAccuracy->orientation);
        return false;
    }
    pstruWjPositionalAccuracy->n32orientation = pstruAsnPositionalAccuracy->orientation;
    return true;
}
/**
* @brief     WJV2_PositionConfidenceSet_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PositionConfidenceSet_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PositionConfidenceSet *pstruWjPositionConfidenceSet = (WJV2_STRU_PositionConfidenceSet *)pvoidWjDf;
    PositionConfidenceSet_t *pstruAsnPositionConfidenceSet = (PositionConfidenceSet_t *)pvoidAsnDf;
    pstruAsnPositionConfidenceSet->pos = pstruWjPositionConfidenceSet->enumpos;
    if (WJV2_PRESENT == pstruWjPositionConfidenceSet->u8elevationPresent)
    {
        pstruAsnPositionConfidenceSet->elevation = CALLOC(1, sizeof(ElevationConfidence_t));
        if (NULL == pstruAsnPositionConfidenceSet->elevation)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnPositionConfidenceSet->elevation) = pstruWjPositionConfidenceSet->enumelevation;
    }
    else
    {
        pstruAsnPositionConfidenceSet->elevation = NULL;
    }
    return true;
}
/**
* @brief     WJV2_PositionConfidenceSet_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PositionConfidenceSet_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PositionConfidenceSet *pstruWjPositionConfidenceSet = (WJV2_STRU_PositionConfidenceSet *)pvoidWjDf;
    PositionConfidenceSet_t *pstruAsnPositionConfidenceSet = (PositionConfidenceSet_t *)pvoidAsnDf;
    pstruWjPositionConfidenceSet->enumpos = pstruAsnPositionConfidenceSet->pos;
    if (NULL != pstruAsnPositionConfidenceSet->elevation)
    {
        pstruWjPositionConfidenceSet->u8elevationPresent = WJV2_PRESENT;
        *(pstruAsnPositionConfidenceSet->elevation) = pstruWjPositionConfidenceSet->enumelevation;
    }
    else
    {
        pstruWjPositionConfidenceSet->u8elevationPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_PositionOffsetLL_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PositionOffsetLL_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PositionOffsetLL *pstruWjPositionOffsetLL = (WJV2_STRU_PositionOffsetLL *)pvoidWjDf;
    PositionOffsetLL_t *pstruAsnPositionOffsetLL = (PositionOffsetLL_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (WJV2_PositionLL24B == pstruWjPositionOffsetLL->enumPositionOffsetLLChoice)
    {
        n32Ret = WJV2_PositionLL24B_DfEnc(&(pstruAsnPositionOffsetLL->choice.position_LL1), &(pstruWjPositionOffsetLL->u.strupositionLL1));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionLL24B_DfEnc is err");
            return false;
        }
        pstruAsnPositionOffsetLL->present = PositionOffsetLL_PR_position_LL1;
    }
    else if (WJV2_PositionLL28B == pstruWjPositionOffsetLL->enumPositionOffsetLLChoice)
    {
        n32Ret = WJV2_PositionLL28B_DfEnc(&(pstruAsnPositionOffsetLL->choice.position_LL2), &(pstruWjPositionOffsetLL->u.strupositionLL2));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionLL28B_DfEnc is err");
            return false;
        }
        pstruAsnPositionOffsetLL->present = PositionOffsetLL_PR_position_LL2;
    }
    else if (WJV2_PositionLL32B == pstruWjPositionOffsetLL->enumPositionOffsetLLChoice)
    {
        n32Ret = WJV2_PositionLL32B_DfEnc(&(pstruAsnPositionOffsetLL->choice.position_LL3), &(pstruWjPositionOffsetLL->u.strupositionLL3));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionLL32B_DfEnc is err");
            return false;
        }
        pstruAsnPositionOffsetLL->present = PositionOffsetLL_PR_position_LL3;
    }
    else if (WJV2_PositionLL36B == pstruWjPositionOffsetLL->enumPositionOffsetLLChoice)
    {
        n32Ret = WJV2_PositionLL36B_DfEnc(&(pstruAsnPositionOffsetLL->choice.position_LL4), &(pstruWjPositionOffsetLL->u.strupositionLL4));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionLL36B_DfEnc is err");
            return false;
        }
        pstruAsnPositionOffsetLL->present = PositionOffsetLL_PR_position_LL4;
    }
    else if (WJV2_PositionLL44B == pstruWjPositionOffsetLL->enumPositionOffsetLLChoice)
    {
        n32Ret = WJV2_PositionLL44B_DfEnc(&(pstruAsnPositionOffsetLL->choice.position_LL5), &(pstruWjPositionOffsetLL->u.strupositionLL5));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionLL44B_DfEnc is err");
            return false;
        }
        pstruAsnPositionOffsetLL->present = PositionOffsetLL_PR_position_LL5;
    }
    else if (WJV2_PositionLL48B == pstruWjPositionOffsetLL->enumPositionOffsetLLChoice)
    {
        n32Ret = WJV2_PositionLL48B_DfEnc(&(pstruAsnPositionOffsetLL->choice.position_LL6), &(pstruWjPositionOffsetLL->u.strupositionLL6));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionLL48B_DfEnc is err");
            return false;
        }
        pstruAsnPositionOffsetLL->present = PositionOffsetLL_PR_position_LL6;
    }
    else if (WJV2_PositionLLmD64b == pstruWjPositionOffsetLL->enumPositionOffsetLLChoice)
    {
        n32Ret = WJV2_PositionLLmD64b_DfEnc(&(pstruAsnPositionOffsetLL->choice.position_LatLon), &(pstruWjPositionOffsetLL->u.strupositionLatLon));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionLLmD64b_DfEnc is err");
            return false;
        }
        pstruAsnPositionOffsetLL->present = PositionOffsetLL_PR_position_LatLon;
    }
    else
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "choice is err pstruWjPositionOffsetLL->enumPositionOffsetLLChoice = %d",
                 pstruWjPositionOffsetLL->enumPositionOffsetLLChoice);
        return false;
    }
    return true;
}
/**
* @brief     WJV2_PositionOffsetLL_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PositionOffsetLL_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PositionOffsetLL *pstruWjPositionOffsetLL = (WJV2_STRU_PositionOffsetLL *)pvoidWjDf;
    PositionOffsetLL_t *pstruAsnPositionOffsetLL = (PositionOffsetLL_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (PositionOffsetLL_PR_position_LL1 == pstruAsnPositionOffsetLL->present)
    {
        n32Ret = WJV2_PositionLL24B_DfDec(&(pstruAsnPositionOffsetLL->choice.position_LL1), &(pstruWjPositionOffsetLL->u.strupositionLL1));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionLL24B_DfDec is err");
            return false;
        }
        pstruWjPositionOffsetLL->enumPositionOffsetLLChoice = WJV2_PositionLL24B;
    }
    else if (PositionOffsetLL_PR_position_LL2 == pstruAsnPositionOffsetLL->present)
    {
        n32Ret = WJV2_PositionLL28B_DfDec(&(pstruAsnPositionOffsetLL->choice.position_LL2), &(pstruWjPositionOffsetLL->u.strupositionLL2));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionLL28B_DfDec is err");
            return false;
        }
        pstruWjPositionOffsetLL->enumPositionOffsetLLChoice = WJV2_PositionLL28B;
    }
    else if (PositionOffsetLL_PR_position_LL3 == pstruAsnPositionOffsetLL->present)
    {
        n32Ret = WJV2_PositionLL32B_DfDec(&(pstruAsnPositionOffsetLL->choice.position_LL3), &(pstruWjPositionOffsetLL->u.strupositionLL3));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionLL32B_DfDec is err");
            return false;
        }
        pstruWjPositionOffsetLL->enumPositionOffsetLLChoice = WJV2_PositionLL32B;
    }
    else if (PositionOffsetLL_PR_position_LL4 == pstruAsnPositionOffsetLL->present)
    {
        n32Ret = WJV2_PositionLL36B_DfDec(&(pstruAsnPositionOffsetLL->choice.position_LL4), &(pstruWjPositionOffsetLL->u.strupositionLL4));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionLL36B_DfDec is err");
            return false;
        }
        pstruWjPositionOffsetLL->enumPositionOffsetLLChoice = WJV2_PositionLL36B;
    }
    else if (PositionOffsetLL_PR_position_LL5 == pstruAsnPositionOffsetLL->present)
    {
        n32Ret = WJV2_PositionLL44B_DfDec(&(pstruAsnPositionOffsetLL->choice.position_LL5), &(pstruWjPositionOffsetLL->u.strupositionLL5));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionLL44B_DfDec is err");
            return false;
        }
        pstruWjPositionOffsetLL->enumPositionOffsetLLChoice = WJV2_PositionLL44B;
    }
    else if (PositionOffsetLL_PR_position_LL6 == pstruAsnPositionOffsetLL->present)
    {
        n32Ret = WJV2_PositionLL48B_DfDec(&(pstruAsnPositionOffsetLL->choice.position_LL6), &(pstruWjPositionOffsetLL->u.strupositionLL6));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionLL48B_DfDec is err");
            return false;
        }
        pstruWjPositionOffsetLL->enumPositionOffsetLLChoice = WJV2_PositionLL48B;
    }
    else if (PositionOffsetLL_PR_position_LatLon == pstruAsnPositionOffsetLL->present)
    {
        n32Ret = WJV2_PositionLLmD64b_DfDec(&(pstruAsnPositionOffsetLL->choice.position_LatLon), &(pstruWjPositionOffsetLL->u.strupositionLatLon));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionLLmD64b_DfDec is err");
            return false;
        }
        pstruWjPositionOffsetLL->enumPositionOffsetLLChoice = WJV2_PositionLLmD64b;
    }
    else
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "choice is err pstruAsnPositionOffsetLL->present = %d",
                 pstruAsnPositionOffsetLL->present);
        return false;
    }
    return true;
}
/**
* @brief     WJV2_PositionOffsetLLV_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PositionOffsetLLV_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PositionOffsetLLV *pstruWjPositionOffsetLLV = (WJV2_STRU_PositionOffsetLLV *)pvoidWjDf;
    PositionOffsetLLV_t *pstruAsnPositionOffsetLLV = (PositionOffsetLLV_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_PositionOffsetLL_DfEnc(&(pstruAsnPositionOffsetLLV->offsetLL), &(pstruWjPositionOffsetLLV->struoffsetLL));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PositionOffsetLL_DfEnc is err");
        return false;
    }
    if (WJV2_PRESENT == pstruWjPositionOffsetLLV->u8offsetVPresent)
    {
        pstruAsnPositionOffsetLLV->offsetV = CALLOC(1, sizeof(struct VerticalOffset));
        if (NULL == pstruAsnPositionOffsetLLV->offsetV)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_VerticalOffset_DfEnc(pstruAsnPositionOffsetLLV->offsetV, &(pstruWjPositionOffsetLLV->struoffsetV));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_VerticalOffset_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnPositionOffsetLLV->offsetV = NULL;
    }
    return true;
}
/**
* @brief     WJV2_PositionOffsetLLV_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_PositionOffsetLLV_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PositionOffsetLLV *pstruWjPositionOffsetLLV = (WJV2_STRU_PositionOffsetLLV *)pvoidWjDf;
    PositionOffsetLLV_t *pstruAsnPositionOffsetLLV = (PositionOffsetLLV_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_PositionOffsetLL_DfDec(&(pstruAsnPositionOffsetLLV->offsetLL), &(pstruWjPositionOffsetLLV->struoffsetLL));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PositionOffsetLL_DfDec is err");
        return false;
    }
    if (NULL != pstruAsnPositionOffsetLLV->offsetV)
    {
        n32Ret = WJV2_VerticalOffset_DfDec(pstruAsnPositionOffsetLLV->offsetV, &(pstruWjPositionOffsetLLV->struoffsetV));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_VerticalOffset_DfDec is err");
            return false;
        }
        pstruWjPositionOffsetLLV->u8offsetVPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPositionOffsetLLV->u8offsetVPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_ReferenceLink_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_ReferenceLink_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ReferenceLink *pstruWjReferenceLink = (WJV2_STRU_ReferenceLink *)pvoidWjDf;
    ReferenceLink_t *pstruAsnReferenceLink = (ReferenceLink_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_NodeReferenceID_DfEnc(&(pstruAsnReferenceLink->upstreamNodeId), &(pstruWjReferenceLink->struupstreamNodeId));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfEnc is err");
        return false;
    }
    n32Ret = WJV2_NodeReferenceID_DfEnc(&(pstruAsnReferenceLink->downstreamNodeId), &(pstruWjReferenceLink->strudownstreamNodeId));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfEnc is err");
        return false;
    }
    if (WJV2_PRESENT == pstruWjReferenceLink->u8referenceLanesPresent)
    {
        pstruAsnReferenceLink->referenceLanes = CALLOC(1, sizeof(ReferenceLanes_t));
        if (NULL == pstruAsnReferenceLink->referenceLanes)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ReferenceLanes_DeEnc(pstruAsnReferenceLink->referenceLanes, &(pstruWjReferenceLink->strbitreferenceLanes));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferenceLanes_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnReferenceLink->referenceLanes = NULL;
    }
    return true;
}
/**
* @brief     WJV2_ReferenceLink_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_ReferenceLink_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ReferenceLink *pstruWjReferenceLink = (WJV2_STRU_ReferenceLink *)pvoidWjDf;
    ReferenceLink_t *pstruAsnReferenceLink = (ReferenceLink_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_NodeReferenceID_DfDec(&(pstruAsnReferenceLink->upstreamNodeId), &(pstruWjReferenceLink->struupstreamNodeId));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfDec is err");
        return false;
    }
    n32Ret = WJV2_NodeReferenceID_DfDec(&(pstruAsnReferenceLink->downstreamNodeId), &(pstruWjReferenceLink->strudownstreamNodeId));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfDec is err");
        return false;
    }
    if (NULL != pstruAsnReferenceLink->referenceLanes)
    {
        n32Ret = WJV2_ReferenceLanes_DeDec(pstruAsnReferenceLink->referenceLanes, &(pstruWjReferenceLink->strbitreferenceLanes));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferenceLanes_DeDec is err");
            return false;
        }
        pstruWjReferenceLink->u8referenceLanesPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjReferenceLink->u8referenceLanesPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_ReferenceLinkList_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_ReferenceLinkList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ReferenceLinkList *pstruWjReferenceLinkList = (WJV2_STRU_ReferenceLinkList *)pvoidWjDf;
    ReferenceLinkList_t *pstruAsnReferenceLinkList = (ReferenceLinkList_t *)pvoidAsnDf;
    ReferenceLink_t *pstruReferenceLink_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_REFERENCELINK_LEN < pstruWjReferenceLinkList->u8ReferenceLinkNum) || (WJV2_MIN_LIST_REFERENCELINK_LEN > pstruWjReferenceLinkList->u8ReferenceLinkNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjReferenceLinkList->u8ReferenceLinkNum = %d",
                 pstruWjReferenceLinkList->u8ReferenceLinkNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjReferenceLinkList->u8ReferenceLinkNum; u32i++)
    {
        pstruReferenceLink_node = CALLOC(1, sizeof(ReferenceLink_t));
        if (NULL == pstruReferenceLink_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ReferenceLink_DfEnc(pstruReferenceLink_node, &(pstruWjReferenceLinkList->struReferenceLink[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferenceLink_DfEnc is err");
            FREEMEM(pstruReferenceLink_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnReferenceLinkList->list), pstruReferenceLink_node);
    }
    return true;
}
/**
* @brief     WJV2_ReferenceLinkList_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_ReferenceLinkList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ReferenceLinkList *pstruWjReferenceLinkList = (WJV2_STRU_ReferenceLinkList *)pvoidWjDf;
    ReferenceLinkList_t *pstruAsnReferenceLinkList = (ReferenceLinkList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_REFERENCELINK_LEN < pstruAsnReferenceLinkList->list.count) || (WJV2_MIN_LIST_REFERENCELINK_LEN > pstruAsnReferenceLinkList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnReferenceLinkList->list.count = %d",
                 pstruAsnReferenceLinkList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnReferenceLinkList->list.count; u32i++)
    {
        n32Ret = WJV2_ReferenceLink_DfDec(pstruAsnReferenceLinkList->list.array[u32i],
                                          &(pstruWjReferenceLinkList->struReferenceLink[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferenceLink_DfDec is err");
            return false;
        }
    }
    pstruWjReferenceLinkList->u8ReferenceLinkNum = (uint8_t)u32i;
    return true;
}
/**
* @brief     WJV2_ReferencePath_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_ReferencePath_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ReferencePath *pstruWjReferencePath = (WJV2_STRU_ReferencePath *)pvoidWjDf;
    ReferencePath_t *pstruAsnReferencePath = (ReferencePath_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_PathPointList_DfEnc(&(pstruAsnReferencePath->activePath), &(pstruWjReferencePath->struactivePath));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PathPointList_DfEnc is err");
        return false;
    }
    if ((WJV2_MAX_RADIUS_SIZE < pstruWjReferencePath->n32pathRadius) || (WJV2_MIN_RADIUS_SIZE > pstruWjReferencePath->n32pathRadius))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjReferencePath->n32pathRadius = %d",
                 pstruWjReferencePath->n32pathRadius);
        return false;
    }
    pstruAsnReferencePath->pathRadius = pstruWjReferencePath->n32pathRadius;
    return true;
}
/**
* @brief     WJV2_ReferencePath_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_ReferencePath_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ReferencePath *pstruWjReferencePath = (WJV2_STRU_ReferencePath *)pvoidWjDf;
    ReferencePath_t *pstruAsnReferencePath = (ReferencePath_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_PathPointList_DfDec(&(pstruAsnReferencePath->activePath), &(pstruWjReferencePath->struactivePath));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PathPointList_DfDec is err");
        return false;
    }
    if ((WJV2_MAX_RADIUS_SIZE < pstruAsnReferencePath->pathRadius) || (WJV2_MIN_RADIUS_SIZE > pstruAsnReferencePath->pathRadius))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnReferencePath->pathRadius = %d",
                 pstruAsnReferencePath->pathRadius);
        return false;
    }
    pstruWjReferencePath->n32pathRadius = pstruAsnReferencePath->pathRadius;
    return true;
}
/**
* @brief     WJV2_ReferencePathList_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_ReferencePathList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ReferencePathList *pstruWjReferencePathList = (WJV2_STRU_ReferencePathList *)pvoidWjDf;
    ReferencePathList_t *pstruAsnReferencePathList = (ReferencePathList_t *)pvoidAsnDf;
    ReferencePath_t *pstruReferencePath_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_REFERENCEPATH_LEN < pstruWjReferencePathList->u8ReferencePathNum) || (WJV2_MIN_LIST_REFERENCEPATH_LEN > pstruWjReferencePathList->u8ReferencePathNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjReferencePathList->u8ReferencePathNum = %d",
                 pstruWjReferencePathList->u8ReferencePathNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjReferencePathList->u8ReferencePathNum; u32i++)
    {
        pstruReferencePath_node = CALLOC(1, sizeof(ReferencePath_t));
        if (NULL == pstruReferencePath_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ReferencePath_DfEnc(pstruReferencePath_node, &(pstruWjReferencePathList->struReferencePath[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferencePath_DfEnc is err");
            FREEMEM(pstruReferencePath_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnReferencePathList->list), pstruReferencePath_node);
    }
    return true;
}
/**
* @brief     WJV2_ReferencePathList_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_ReferencePathList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ReferencePathList *pstruWjReferencePathList = (WJV2_STRU_ReferencePathList *)pvoidWjDf;
    ReferencePathList_t *pstruAsnReferencePathList = (ReferencePathList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_REFERENCEPATH_LEN < pstruAsnReferencePathList->list.count) || (WJV2_MIN_LIST_REFERENCEPATH_LEN > pstruAsnReferencePathList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnReferencePathList->list.count = %d",
                 pstruAsnReferencePathList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnReferencePathList->list.count; u32i++)
    {
        n32Ret = WJV2_ReferencePath_DfDec(pstruAsnReferencePathList->list.array[u32i],
                                          &(pstruWjReferencePathList->struReferencePath[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferencePath_DfDec is err");
            return false;
        }
    }
    pstruWjReferencePathList->u8ReferencePathNum = (uint8_t)u32i;
    return true;
}
/**
* @brief     WJV2_RegulatorySpeedLimit_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_RegulatorySpeedLimit_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_RegulatorySpeedLimit *pstruWjRegulatorySpeedLimit = (WJV2_STRU_RegulatorySpeedLimit *)pvoidWjDf;
    RegulatorySpeedLimit_t *pstruAsnRegulatorySpeedLimit = (RegulatorySpeedLimit_t *)pvoidAsnDf;
    pstruAsnRegulatorySpeedLimit->type = pstruWjRegulatorySpeedLimit->enumtype;
    if ((WJV2_MAX_SPEED_SIZE < pstruWjRegulatorySpeedLimit->n32speed) || (WJV2_MIN_SPEED_SIZE > pstruWjRegulatorySpeedLimit->n32speed))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjRegulatorySpeedLimit->n32speed = %d",
                 pstruWjRegulatorySpeedLimit->n32speed);
        return false;
    }
    pstruAsnRegulatorySpeedLimit->speed = pstruWjRegulatorySpeedLimit->n32speed;
    return true;
}
/**
* @brief     WJV2_RegulatorySpeedLimit_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_RegulatorySpeedLimit_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_RegulatorySpeedLimit *pstruWjRegulatorySpeedLimit = (WJV2_STRU_RegulatorySpeedLimit *)pvoidWjDf;
    RegulatorySpeedLimit_t *pstruAsnRegulatorySpeedLimit = (RegulatorySpeedLimit_t *)pvoidAsnDf;
    pstruWjRegulatorySpeedLimit->enumtype = pstruAsnRegulatorySpeedLimit->type;
    if ((WJV2_MAX_SPEED_SIZE < pstruAsnRegulatorySpeedLimit->speed) || (WJV2_MIN_SPEED_SIZE > pstruAsnRegulatorySpeedLimit->speed))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnRegulatorySpeedLimit->speed = %d",
                 pstruAsnRegulatorySpeedLimit->speed);
        return false;
    }
    pstruWjRegulatorySpeedLimit->n32speed = pstruAsnRegulatorySpeedLimit->speed;
    return true;
}
/**
* @brief     WJV2_RSITimeDetails_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_RSITimeDetails_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_RSITimeDetails *pstruWjRSITimeDetails = (WJV2_STRU_RSITimeDetails *)pvoidWjDf;
    RSITimeDetails_t *pstruAsnRSITimeDetails = (RSITimeDetails_t *)pvoidAsnDf;
    if (WJV2_PRESENT == pstruWjRSITimeDetails->u8startTimePresent)
    {
        pstruAsnRSITimeDetails->startTime = CALLOC(1, sizeof(MinuteOfTheYear_t));
        if (NULL == pstruAsnRSITimeDetails->startTime)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_MINUTEOFTHEYEAR_SIZE < pstruWjRSITimeDetails->n32startTime) || (WJV2_MIN_MINUTEOFTHEYEAR_SIZE > pstruWjRSITimeDetails->n32startTime))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjRSITimeDetails->n32startTime = %d",
                     pstruWjRSITimeDetails->n32startTime);
            return false;
        }
        *(pstruAsnRSITimeDetails->startTime) = pstruWjRSITimeDetails->n32startTime;
    }
    else
    {
        pstruAsnRSITimeDetails->startTime = NULL;
    }
    if (WJV2_PRESENT == pstruWjRSITimeDetails->u8endTimePresent)
    {
        pstruAsnRSITimeDetails->endTime = CALLOC(1, sizeof(MinuteOfTheYear_t));
        if (NULL == pstruAsnRSITimeDetails->endTime)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_MINUTEOFTHEYEAR_SIZE < pstruWjRSITimeDetails->n32endTime) || (WJV2_MIN_MINUTEOFTHEYEAR_SIZE > pstruWjRSITimeDetails->n32endTime))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjRSITimeDetails->n32endTime = %d",
                     pstruWjRSITimeDetails->n32endTime);
            return false;
        }
        *(pstruAsnRSITimeDetails->endTime) = pstruWjRSITimeDetails->n32endTime;
    }
    else
    {
        pstruAsnRSITimeDetails->endTime = NULL;
    }
    if (WJV2_PRESENT == pstruWjRSITimeDetails->u8endTimeConfidencePresent)
    {
        pstruAsnRSITimeDetails->endTimeConfidence = CALLOC(1, sizeof(TimeConfidence_t));
        if (NULL == pstruAsnRSITimeDetails->endTimeConfidence)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnRSITimeDetails->endTimeConfidence) = pstruWjRSITimeDetails->enumendTimeConfidence;
    }
    else
    {
        pstruAsnRSITimeDetails->endTimeConfidence = NULL;
    }
    return true;
}
/**
* @brief     WJV2_RSITimeDetails_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_RSITimeDetails_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_RSITimeDetails *pstruWjRSITimeDetails = (WJV2_STRU_RSITimeDetails *)pvoidWjDf;
    RSITimeDetails_t *pstruAsnRSITimeDetails = (RSITimeDetails_t *)pvoidAsnDf;
    if (NULL != pstruAsnRSITimeDetails->startTime)
    {
        if ((WJV2_MAX_MINUTEOFTHEYEAR_SIZE < *(pstruAsnRSITimeDetails->startTime)) || (WJV2_MIN_MINUTEOFTHEYEAR_SIZE > *(pstruAsnRSITimeDetails->startTime)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnRSITimeDetails->startTime) = %d",
                     *(pstruAsnRSITimeDetails->startTime));
            return false;
        }
        pstruWjRSITimeDetails->n32startTime = *(pstruAsnRSITimeDetails->startTime);
        pstruWjRSITimeDetails->u8startTimePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjRSITimeDetails->u8startTimePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnRSITimeDetails->endTime)
    {
        if ((WJV2_MAX_MINUTEOFTHEYEAR_SIZE < *(pstruAsnRSITimeDetails->endTime)) || (WJV2_MIN_MINUTEOFTHEYEAR_SIZE > *(pstruAsnRSITimeDetails->endTime)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnRSITimeDetails->endTime) = %d",
                     *(pstruAsnRSITimeDetails->endTime));
            return false;
        }
        pstruWjRSITimeDetails->n32endTime = *(pstruAsnRSITimeDetails->endTime);
        pstruWjRSITimeDetails->u8endTimePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjRSITimeDetails->u8endTimePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnRSITimeDetails->endTimeConfidence)
    {
        pstruWjRSITimeDetails->enumendTimeConfidence = *(pstruAsnRSITimeDetails->endTimeConfidence);
        pstruWjRSITimeDetails->u8endTimeConfidencePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjRSITimeDetails->u8endTimeConfidencePresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_RTEData_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_RTEData_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_RTEData *pstruWjRTEData = (WJV2_STRU_RTEData *)pvoidWjDf;
    RTEData_t *pstruAsnRTEData = (RTEData_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_RTEID_SIZE < pstruWjRTEData->u8rteId) || (WJV2_MIN_RTEID_SIZE > pstruWjRTEData->u8rteId))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjRTEData->u8rteId = %d",
                 pstruWjRTEData->u8rteId);
        return false;
    }
    pstruAsnRTEData->rteId = pstruWjRTEData->u8rteId;
    if ((WJV2_MAX_EVENTTYPE_SIZE < pstruWjRTEData->n32eventType) || (WJV2_MIN_EVENTTYPE_SIZE > pstruWjRTEData->n32eventType))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjRTEData->n32eventType = %d",
                 pstruWjRTEData->n32eventType);
        return false;
    }
    pstruAsnRTEData->eventType = pstruWjRTEData->n32eventType;
    pstruAsnRTEData->eventSource = pstruWjRTEData->enumeventSource;
    if (WJV2_PRESENT == pstruWjRTEData->u8eventPosPresent)
    {
        pstruAsnRTEData->eventPos = CALLOC(1, sizeof(struct PositionOffsetLLV));
        if (NULL == pstruAsnRTEData->eventPos)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PositionOffsetLLV_DfEnc(pstruAsnRTEData->eventPos, &(pstruWjRTEData->strueventPos));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionOffsetLLV_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnRTEData->eventPos = NULL;
    }
    if (WJV2_PRESENT == pstruWjRTEData->u8eventRadiusPresent)
    {
        pstruAsnRTEData->eventRadius = CALLOC(1, sizeof(Radius_t));
        if (NULL == pstruAsnRTEData->eventRadius)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_RADIUS_SIZE < pstruWjRTEData->n32eventRadius) || (WJV2_MIN_RADIUS_SIZE > pstruWjRTEData->n32eventRadius))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjRTEData->n32eventRadius = %d",
                     pstruWjRTEData->n32eventRadius);
            return false;
        }
        *(pstruAsnRTEData->eventRadius) = pstruWjRTEData->n32eventRadius;
    }
    else
    {
        pstruAsnRTEData->eventPos = NULL;
    }
    if (WJV2_PRESENT == pstruWjRTEData->u8descriptionPresent)
    {
        pstruAsnRTEData->description = CALLOC(1, sizeof(struct Description));
        if (NULL == pstruAsnRTEData->description)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_Description_DfEnc(pstruAsnRTEData->description, &(pstruWjRTEData->strudescription));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Description_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnRTEData->description = NULL;
    }
    if (WJV2_PRESENT == pstruWjRTEData->u8timeDetailsPresent)
    {
        pstruAsnRTEData->timeDetails = CALLOC(1, sizeof(struct RSITimeDetails));
        if (NULL == pstruAsnRTEData->timeDetails)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_RSITimeDetails_DfEnc(pstruAsnRTEData->timeDetails, &(pstruWjRTEData->strutimeDetails));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RSITimeDetails_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnRTEData->timeDetails = NULL;
    }
    if (WJV2_PRESENT == pstruWjRTEData->u8priorityPresent)
    {
        pstruAsnRTEData->priority = CALLOC(1, sizeof(RSIPriority_t));
        if (NULL == pstruAsnRTEData->priority)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_RSIPriority_DeEnc(pstruAsnRTEData->priority, &(pstruWjRTEData->stria5priority));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RSIPriority_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnRTEData->priority = NULL;
    }
    if (WJV2_PRESENT == pstruWjRTEData->u8referencePathsPresent)
    {
        pstruAsnRTEData->referencePaths = CALLOC(1, sizeof(struct ReferencePathList));
        if (NULL == pstruAsnRTEData->referencePaths)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ReferencePathList_DfEnc(pstruAsnRTEData->referencePaths, &(pstruWjRTEData->strureferencePaths));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferencePathList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnRTEData->referencePaths = NULL;
    }
    if (WJV2_PRESENT == pstruWjRTEData->u8referenceLinksPresent)
    {
        pstruAsnRTEData->referenceLinks = CALLOC(1, sizeof(struct ReferenceLinkList));
        if (NULL == pstruAsnRTEData->referenceLinks)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ReferenceLinkList_DfEnc(pstruAsnRTEData->referenceLinks, &(pstruWjRTEData->strureferenceLinks));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferenceLinkList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnRTEData->referenceLinks = NULL;
    }
    if (WJV2_PRESENT == pstruWjRTEData->u8eventConfidencePresent)
    {
        pstruAsnRTEData->eventConfidence = CALLOC(1, sizeof(Confidence_t));
        if (NULL == pstruAsnRTEData->eventConfidence)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_CONFIDENCE_SIZE < pstruWjRTEData->n32eventConfidence) || (WJV2_MIN_CONFIDENCE_SIZE > pstruWjRTEData->n32eventConfidence))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjRTEData->n32eventConfidence = %d",
                     pstruWjRTEData->n32eventConfidence);
            return false;
        }
        *(pstruAsnRTEData->eventConfidence) = pstruWjRTEData->n32eventConfidence;
    }
    else
    {
        pstruAsnRTEData->eventConfidence = NULL;
    }
    return true;
}
/**
* @brief     WJV2_RTEData_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_RTEData_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_RTEData *pstruWjRTEData = (WJV2_STRU_RTEData *)pvoidWjDf;
    RTEData_t *pstruAsnRTEData = (RTEData_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_RTEID_SIZE < pstruAsnRTEData->rteId) || (WJV2_MIN_RTEID_SIZE > pstruAsnRTEData->rteId))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnRTEData->rteId = %d",
                 pstruAsnRTEData->rteId);
        return false;
    }
    pstruWjRTEData->u8rteId = pstruAsnRTEData->rteId;
    if ((WJV2_MAX_EVENTTYPE_SIZE < pstruAsnRTEData->eventType) || (WJV2_MIN_EVENTTYPE_SIZE > pstruAsnRTEData->eventType))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnRTEData->eventType = %d",
                 pstruAsnRTEData->eventType);
        return false;
    }
    pstruWjRTEData->n32eventType = pstruAsnRTEData->eventType;
    pstruWjRTEData->enumeventSource = pstruAsnRTEData->eventSource;
    if (NULL != pstruAsnRTEData->eventPos)
    {
        n32Ret = WJV2_PositionOffsetLLV_DfDec(pstruAsnRTEData->eventPos, &(pstruWjRTEData->strueventPos));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionOffsetLLV_DfDec is err");
            return false;
        }
        pstruWjRTEData->u8eventPosPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjRTEData->u8eventPosPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnRTEData->eventRadius)
    {
        if ((WJV2_MAX_RADIUS_SIZE < *(pstruAsnRTEData->eventRadius)) || (WJV2_MIN_RADIUS_SIZE > *(pstruAsnRTEData->eventRadius)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnRTEData->eventRadius) = %d",
                     *(pstruAsnRTEData->eventRadius));
            return false;
        }
        pstruWjRTEData->n32eventRadius = *(pstruAsnRTEData->eventRadius);
        pstruWjRTEData->u8eventRadiusPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjRTEData->u8eventRadiusPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnRTEData->description)
    {
        n32Ret = WJV2_Description_DfDec(pstruAsnRTEData->description, &(pstruWjRTEData->strudescription));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Description_DfDec is err");
            return false;
        }
        pstruWjRTEData->u8descriptionPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjRTEData->u8descriptionPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnRTEData->timeDetails)
    {
        n32Ret = WJV2_RSITimeDetails_DfDec(pstruAsnRTEData->timeDetails, &(pstruWjRTEData->strutimeDetails));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RSITimeDetails_DfDec is err");
            return false;
        }
        pstruWjRTEData->u8timeDetailsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjRTEData->u8timeDetailsPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnRTEData->priority)
    {
        n32Ret = WJV2_RSIPriority_DeDec(pstruAsnRTEData->priority, &(pstruWjRTEData->stria5priority));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RSIPriority_DeDec is err");
            return false;
        }
        pstruWjRTEData->u8priorityPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjRTEData->u8priorityPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnRTEData->referencePaths)
    {
        n32Ret = WJV2_ReferencePathList_DfDec(pstruAsnRTEData->referencePaths, &(pstruWjRTEData->strureferencePaths));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferencePathList_DfDec is err");
            return false;
        }
        pstruWjRTEData->u8referencePathsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjRTEData->u8referencePathsPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnRTEData->referenceLinks)
    {
        n32Ret = WJV2_ReferenceLinkList_DfDec(pstruAsnRTEData->referenceLinks, &(pstruWjRTEData->strureferenceLinks));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferenceLinkList_DfDec is err");
            return false;
        }
        pstruWjRTEData->u8referenceLinksPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjRTEData->u8referenceLinksPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnRTEData->eventConfidence)
    {
        if ((WJV2_MAX_CONFIDENCE_SIZE < *(pstruAsnRTEData->eventConfidence)) || (WJV2_MIN_CONFIDENCE_SIZE > *(pstruAsnRTEData->eventConfidence)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnRTEData->eventConfidence) = %d",
                     *(pstruAsnRTEData->eventConfidence));
            return false;
        }
        pstruWjRTEData->n32eventConfidence = *(pstruAsnRTEData->eventConfidence);
        pstruWjRTEData->u8eventConfidencePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjRTEData->u8eventConfidencePresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_RTEList_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_RTEList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_RTEList *pstruWjRTEList = (WJV2_STRU_RTEList *)pvoidWjDf;
    RTEList_t *pstruAsnRTEList = (RTEList_t *)pvoidAsnDf;
    RTEData_t *pstruRTEData_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_RTEDATA_LEN < pstruWjRTEList->u8RTEDataNum) || (WJV2_MIN_LIST_RTEDATA_LEN > pstruWjRTEList->u8RTEDataNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjRTEList->u8RTEDataNum = %d",
                 pstruWjRTEList->u8RTEDataNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjRTEList->u8RTEDataNum; u32i++)
    {
        pstruRTEData_node = CALLOC(1, sizeof(RTEData_t));
        if (NULL == pstruRTEData_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_RTEData_DfEnc(pstruRTEData_node, &(pstruWjRTEList->struRTEData[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RTEData_DfEnc is err");
            FREEMEM(pstruRTEData_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnRTEList->list), pstruRTEData_node);
    }
    return true;
}
/**
* @brief     WJV2_RTEList_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_RTEList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_RTEList *pstruWjRTEList = (WJV2_STRU_RTEList *)pvoidWjDf;
    RTEList_t *pstruAsnRTEList = (RTEList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_RTEDATA_LEN < pstruAsnRTEList->list.count) || (WJV2_MIN_LIST_RTEDATA_LEN > pstruAsnRTEList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnRTEList->list.count = %d",
                 pstruAsnRTEList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnRTEList->list.count; u32i++)
    {
        n32Ret = WJV2_RTEData_DfDec(pstruAsnRTEList->list.array[u32i],
                                    &(pstruWjRTEList->struRTEData[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RTEData_DfDec is err");
            return false;
        }
    }
    pstruWjRTEList->u8RTEDataNum = (uint8_t)u32i;
    return true;
}
/**
* @brief     WJV2_RTSData_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_RTSData_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_RTSData *pstruWjRTSData = (WJV2_STRU_RTSData *)pvoidWjDf;
    RTSData_t *pstruAsnRTSData = (RTSData_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_RTSID_SIZE < pstruWjRTSData->u8rtsId) || (WJV2_MIN_RTSID_SIZE > pstruWjRTSData->u8rtsId))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjRTSData->u8rtsId = %d",
                 pstruWjRTSData->u8rtsId);
        return false;
    }
    pstruAsnRTSData->rtsId = pstruWjRTSData->u8rtsId;
    if ((WJV2_MAX_SIGNTYPE_SIZE < pstruWjRTSData->n32signType) || (WJV2_MIN_SIGNTYPE_SIZE > pstruWjRTSData->n32signType))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjRTSData->n32signType = %d",
                 pstruWjRTSData->n32signType);
        return false;
    }
    pstruAsnRTSData->signType = pstruWjRTSData->n32signType;
    if (WJV2_PRESENT == pstruWjRTSData->u8signPosPresent)
    {
        pstruAsnRTSData->signPos = CALLOC(1, sizeof(struct PositionOffsetLLV));
        if (NULL == pstruAsnRTSData->signPos)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PositionOffsetLLV_DfEnc(pstruAsnRTSData->signPos, &(pstruWjRTSData->strusignPos));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionOffsetLLV_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnRTSData->signPos = NULL;
    }
    if (WJV2_PRESENT == pstruWjRTSData->u8descriptionPresent)
    {
        pstruAsnRTSData->description = CALLOC(1, sizeof(struct Description));
        if (NULL == pstruAsnRTSData->description)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_Description_DfEnc(pstruAsnRTSData->description, &(pstruWjRTSData->strudescription));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Description_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnRTSData->description = NULL;
    }
    if (WJV2_PRESENT == pstruWjRTSData->u8timeDetailsPresent)
    {
        pstruAsnRTSData->timeDetails = CALLOC(1, sizeof(struct RSITimeDetails));
        if (NULL == pstruAsnRTSData->timeDetails)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_RSITimeDetails_DfEnc(pstruAsnRTSData->timeDetails, &(pstruWjRTSData->strutimeDetails));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RSITimeDetails_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnRTSData->timeDetails = NULL;
    }
    if (WJV2_PRESENT == pstruWjRTSData->u8priorityPresent)
    {
        pstruAsnRTSData->priority = CALLOC(1, sizeof(RSIPriority_t));
        if (NULL == pstruAsnRTSData->priority)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_RSIPriority_DeEnc(pstruAsnRTSData->priority, &(pstruWjRTSData->stria5priority));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RSIPriority_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnRTSData->priority = NULL;
    }
    if (WJV2_PRESENT == pstruWjRTSData->u8referencePathsPresent)
    {
        pstruAsnRTSData->referencePaths = CALLOC(1, sizeof(struct ReferencePathList));
        if (NULL == pstruAsnRTSData->referencePaths)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ReferencePathList_DfEnc(pstruAsnRTSData->referencePaths, &(pstruWjRTSData->strureferencePaths));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferencePathList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnRTSData->referencePaths = NULL;
    }
    if (WJV2_PRESENT == pstruWjRTSData->u8referenceLinksPresent)
    {
        pstruAsnRTSData->referenceLinks = CALLOC(1, sizeof(struct ReferenceLinkList));
        if (NULL == pstruAsnRTSData->referenceLinks)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ReferenceLinkList_DfEnc(pstruAsnRTSData->referenceLinks, &(pstruWjRTSData->strureferenceLinks));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferenceLinkList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnRTSData->referenceLinks = NULL;
    }
    return true;
}
/**
* @brief     WJV2_RTSData_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_RTSData_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_RTSData *pstruWjRTSData = (WJV2_STRU_RTSData *)pvoidWjDf;
    RTSData_t *pstruAsnRTSData = (RTSData_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_RTSID_SIZE < pstruAsnRTSData->rtsId) || (WJV2_MIN_RTSID_SIZE > pstruAsnRTSData->rtsId))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnRTSData->rtsId = %d",
                 pstruAsnRTSData->rtsId);
        return false;
    }
    pstruWjRTSData->u8rtsId = pstruAsnRTSData->rtsId;
    if ((WJV2_MAX_SIGNTYPE_SIZE < pstruAsnRTSData->signType) || (WJV2_MIN_SIGNTYPE_SIZE > pstruAsnRTSData->signType))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnRTSData->signType = %d",
                 pstruAsnRTSData->signType);
        return false;
    }
    pstruWjRTSData->n32signType = pstruAsnRTSData->signType;
    if (NULL != pstruAsnRTSData->signPos)
    {
        n32Ret = WJV2_PositionOffsetLLV_DfDec(pstruAsnRTSData->signPos, &(pstruWjRTSData->strusignPos));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionOffsetLLV_DfDec is err");
            return false;
        }
        pstruWjRTSData->u8signPosPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjRTSData->u8signPosPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnRTSData->description)
    {
        n32Ret = WJV2_Description_DfDec(pstruAsnRTSData->description, &(pstruWjRTSData->strudescription));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Description_DfDec is err");
            return false;
        }
        pstruWjRTSData->u8descriptionPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjRTSData->u8descriptionPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnRTSData->timeDetails)
    {
        n32Ret = WJV2_RSITimeDetails_DfDec(pstruAsnRTSData->timeDetails, &(pstruWjRTSData->strutimeDetails));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RSITimeDetails_DfDec is err");
            return false;
        }
        pstruWjRTSData->u8timeDetailsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjRTSData->u8timeDetailsPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnRTSData->priority)
    {
        n32Ret = WJV2_RSIPriority_DeDec(pstruAsnRTSData->priority, &(pstruWjRTSData->stria5priority));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RSIPriority_DeDec is err");
            return false;
        }
        pstruWjRTSData->u8priorityPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjRTSData->u8priorityPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnRTSData->referencePaths)
    {
        n32Ret = WJV2_ReferencePathList_DfDec(pstruAsnRTSData->referencePaths, &(pstruWjRTSData->strureferencePaths));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferencePathList_DfDec is err");
            return false;
        }
        pstruWjRTSData->u8referencePathsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjRTSData->u8referencePathsPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnRTSData->referenceLinks)
    {
        n32Ret = WJV2_ReferenceLinkList_DfDec(pstruAsnRTSData->referenceLinks, &(pstruWjRTSData->strureferenceLinks));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferenceLinkList_DfDec is err");
            return false;
        }
        pstruWjRTSData->u8referenceLinksPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjRTSData->u8referenceLinksPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_RTSList_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_RTSList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_RTSList *pstruWjRTSList = (WJV2_STRU_RTSList *)pvoidWjDf;
    RTSList_t *pstruAsnRTSList = (RTSList_t *)pvoidAsnDf;
    RTSData_t *pstruRTSData_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_RTSDATA_LEN < pstruWjRTSList->u8RTSDataNum) || (WJV2_MIN_LIST_RTSDATA_LEN > pstruWjRTSList->u8RTSDataNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjRTSList->u8RTSDataNum = %d",
                 pstruWjRTSList->u8RTSDataNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjRTSList->u8RTSDataNum; u32i++)
    {
        pstruRTSData_node = CALLOC(1, sizeof(RTSData_t));
        if (NULL == pstruRTSData_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_RTSData_DfEnc(pstruRTSData_node, &(pstruWjRTSList->struRTSData[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RTSData_DfEnc is err");
            FREEMEM(pstruRTSData_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnRTSList->list), pstruRTSData_node);
    }
    return true;
}
/**
* @brief     WJV2_RTSList_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_RTSList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_RTSList *pstruWjRTSList = (WJV2_STRU_RTSList *)pvoidWjDf;
    RTSList_t *pstruAsnRTSList = (RTSList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_RTSDATA_LEN < pstruAsnRTSList->list.count) || (WJV2_MIN_LIST_RTSDATA_LEN > pstruAsnRTSList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnRTSList->list.count = %d",
                 pstruAsnRTSList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnRTSList->list.count; u32i++)
    {
        n32Ret = WJV2_RTSData_DfDec(pstruAsnRTSList->list.array[u32i],
                                    &(pstruWjRTSList->struRTSData[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RTSData_DfDec is err");
            return false;
        }
    }
    pstruWjRTSList->u8RTSDataNum = (uint8_t)u32i;
    return true;
}
/**
* @brief     WJV2_RoadPoint_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_RoadPoint_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_RoadPoint *pstruWjRoadPoint = (WJV2_STRU_RoadPoint *)pvoidWjDf;
    RoadPoint_t *pstruAsnRoadPoint = (RoadPoint_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_PositionOffsetLLV_DfEnc(&(pstruAsnRoadPoint->posOffset), &(pstruWjRoadPoint->struposOffset));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PositionOffsetLLV_DfEnc is err");
        return false;
    }
    return true;
}
/**
* @brief     WJV2_RoadPoint_DfDec解码函数
* @details   协议栈Df编解中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_RoadPoint_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_RoadPoint *pstruWjRoadPoint = (WJV2_STRU_RoadPoint *)pvoidWjDf;
    RoadPoint_t *pstruAsnRoadPoint = (RoadPoint_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_PositionOffsetLLV_DfDec(&(pstruAsnRoadPoint->posOffset), &(pstruWjRoadPoint->struposOffset));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PositionOffsetLLV_DfDec is err");
        return false;
    }
    return true;
}
/**
* @brief     WJV2_SpeedLimitList_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_SpeedLimitList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_SpeedLimitList *pstruWjSpeedLimitList = (WJV2_STRU_SpeedLimitList *)pvoidWjDf;
    SpeedLimitList_t *pstruAsnSpeedLimitList = (SpeedLimitList_t *)pvoidAsnDf;
    RegulatorySpeedLimit_t *pstruRegulatorySpeedLimit_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_REGULATORYSPEEDLIMITNUM_LEN < pstruWjSpeedLimitList->u8RegulatorySpeedLimitNum) || (WJV2_MIN_LIST_REGULATORYSPEEDLIMITNUM_LEN > pstruWjSpeedLimitList->u8RegulatorySpeedLimitNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjSpeedLimitList->u8RegulatorySpeedLimitNum = %d",
                 pstruWjSpeedLimitList->u8RegulatorySpeedLimitNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjSpeedLimitList->u8RegulatorySpeedLimitNum; u32i++)
    {
        pstruRegulatorySpeedLimit_node = CALLOC(1, sizeof(RegulatorySpeedLimit_t));
        if (NULL == pstruRegulatorySpeedLimit_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_RegulatorySpeedLimit_DfEnc(pstruRegulatorySpeedLimit_node, &(pstruWjSpeedLimitList->struRegulatorySpeedLimit[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RegulatorySpeedLimit_DfEnc is err");
            FREEMEM(pstruRegulatorySpeedLimit_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnSpeedLimitList->list), pstruRegulatorySpeedLimit_node);
    }
    return true;
}
/**
* @brief     WJV2_SpeedLimitList_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_SpeedLimitList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_SpeedLimitList *pstruWjSpeedLimitList = (WJV2_STRU_SpeedLimitList *)pvoidWjDf;
    SpeedLimitList_t *pstruAsnSpeedLimitList = (SpeedLimitList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_REGULATORYSPEEDLIMITNUM_LEN < pstruAsnSpeedLimitList->list.count) || (WJV2_MIN_LIST_REGULATORYSPEEDLIMITNUM_LEN > pstruAsnSpeedLimitList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnSpeedLimitList->list.count = %d",
                 pstruAsnSpeedLimitList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnSpeedLimitList->list.count; u32i++)
    {
        n32Ret = WJV2_RegulatorySpeedLimit_DfDec(pstruAsnSpeedLimitList->list.array[u32i],
                                                 &(pstruWjSpeedLimitList->struRegulatorySpeedLimit[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RegulatorySpeedLimit_DfDec is err");
            return false;
        }
    }
    pstruWjSpeedLimitList->u8RegulatorySpeedLimitNum = (uint8_t)u32i;
    return true;
}
/**
* @brief     WJV2_TimeChangeDetails_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_TimeChangeDetails_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_TimeChangeDetails *pstruWjTimeChangeDetails = (WJV2_STRU_TimeChangeDetails *)pvoidWjDf;
    TimeChangeDetails_t *pstruAsnTimeChangeDetails = (TimeChangeDetails_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (WJV2_TimeChangeDetailsDOWN == pstruWjTimeChangeDetails->enumTimeChangeDetails)
    {
        n32Ret = WJV2_TimeCountingDown_DfEnc(&(pstruAsnTimeChangeDetails->choice.counting),
                                             &(pstruWjTimeChangeDetails->u.strucounting));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_TimeCountingDown_DfEnc is err");
            return false;
        }
        pstruAsnTimeChangeDetails->present = TimeChangeDetails_PR_counting;
    }
    else if (WJV2_TimeChangeDetailsUTC == pstruWjTimeChangeDetails->enumTimeChangeDetails)
    {
        n32Ret = WJV2_UTCTiming_DfEnc(&(pstruAsnTimeChangeDetails->choice.utcTiming),
                                      &(pstruWjTimeChangeDetails->u.struutcTiming));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_UTCTiming_DfEnc is err");
            return false;
        }
        pstruAsnTimeChangeDetails->present = TimeChangeDetails_PR_utcTiming;
    }
    else
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "type is err pstruWjTimeChangeDetails->enumTimeChangeDetails = %d",
                 pstruWjTimeChangeDetails->enumTimeChangeDetails);
        return false;
    }
    return true;
}
/**
* @brief     WJV2_TimeChangeDetails_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_TimeChangeDetails_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_TimeChangeDetails *pstruWjTimeChangeDetails = (WJV2_STRU_TimeChangeDetails *)pvoidWjDf;
    TimeChangeDetails_t *pstruAsnTimeChangeDetails = (TimeChangeDetails_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (TimeChangeDetails_PR_counting == pstruAsnTimeChangeDetails->present)
    {
        n32Ret = WJV2_TimeCountingDown_DfDec(&(pstruAsnTimeChangeDetails->choice.counting),
                                             &(pstruWjTimeChangeDetails->u.strucounting));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_TimeCountingDown_DfDec is err");
            return false;
        }
        pstruWjTimeChangeDetails->enumTimeChangeDetails = WJV2_TimeChangeDetailsDOWN;
    }
    else if (TimeChangeDetails_PR_utcTiming == pstruAsnTimeChangeDetails->present)
    {
        n32Ret = WJV2_UTCTiming_DfDec(&(pstruAsnTimeChangeDetails->choice.utcTiming),
                                      &(pstruWjTimeChangeDetails->u.struutcTiming));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_UTCTiming_DfDec is err");
            return false;
        }
        pstruWjTimeChangeDetails->enumTimeChangeDetails = WJV2_TimeChangeDetailsUTC;
    }
    else
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "type is err pstruAsnTimeChangeDetails->present = %d",
                 pstruAsnTimeChangeDetails->present);
        return false;
    }
    return true;
}
/**
* @brief     WJV2_TimeCountingDown_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_TimeCountingDown_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_TimeCountingDown *pstruWjTimeCountingDown = (WJV2_STRU_TimeCountingDown *)pvoidWjDf;
    TimeCountingDown_t *pstruAsnTimeCountingDown = (TimeCountingDown_t *)pvoidAsnDf;
    if ((WJV2_MAX_TIMEMARK_SIZE < pstruWjTimeCountingDown->n32startTime) || (WJV2_MIN_TIMEMARK_SIZE > pstruWjTimeCountingDown->n32startTime))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjTimeCountingDown->n32startTime = %d",
                 pstruWjTimeCountingDown->n32startTime);
        return false;
    }
    pstruAsnTimeCountingDown->startTime = pstruWjTimeCountingDown->n32startTime;
    if (WJV2_PRESENT == pstruWjTimeCountingDown->u8minEndTimePresent)
    {
        pstruAsnTimeCountingDown->minEndTime = CALLOC(1, sizeof(TimeMark_t));
        if (NULL == pstruAsnTimeCountingDown->minEndTime)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_TIMEMARK_SIZE < pstruWjTimeCountingDown->n32minEndTime) || (WJV2_MIN_TIMEMARK_SIZE > pstruWjTimeCountingDown->n32minEndTime))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjTimeCountingDown->n32minEndTime = %d",
                     pstruWjTimeCountingDown->n32minEndTime);
            return false;
        }
        *(pstruAsnTimeCountingDown->minEndTime) = pstruWjTimeCountingDown->n32minEndTime;
    }
    else
    {
        pstruAsnTimeCountingDown->minEndTime = NULL;
    }
    if (WJV2_PRESENT == pstruWjTimeCountingDown->u8maxEndTimePresent)
    {
        pstruAsnTimeCountingDown->maxEndTime = CALLOC(1, sizeof(TimeMark_t));
        if (NULL == pstruAsnTimeCountingDown->maxEndTime)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_TIMEMARK_SIZE < pstruWjTimeCountingDown->n32maxEndTime) || (WJV2_MIN_TIMEMARK_SIZE > pstruWjTimeCountingDown->n32maxEndTime))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjTimeCountingDown->n32maxEndTime = %d",
                     pstruWjTimeCountingDown->n32maxEndTime);
            return false;
        }
        *(pstruAsnTimeCountingDown->maxEndTime) = pstruWjTimeCountingDown->n32maxEndTime;
    }
    else
    {
        pstruAsnTimeCountingDown->maxEndTime = NULL;
    }
    if ((WJV2_MAX_TIMEMARK_SIZE < pstruWjTimeCountingDown->n32likelyEndTime) || (WJV2_MIN_TIMEMARK_SIZE > pstruWjTimeCountingDown->n32likelyEndTime))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjTimeCountingDown->n32likelyEndTime = %d",
                 pstruWjTimeCountingDown->n32likelyEndTime);
        return false;
    }
    pstruAsnTimeCountingDown->likelyEndTime = pstruWjTimeCountingDown->n32likelyEndTime;
    if (WJV2_PRESENT == pstruWjTimeCountingDown->u8timeConfidencePresent)
    {
        pstruAsnTimeCountingDown->timeConfidence = CALLOC(1, sizeof(Confidence_t));
        if (NULL == pstruAsnTimeCountingDown->timeConfidence)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_CONFIDENCE_SIZE < pstruWjTimeCountingDown->n32timeConfidence) || (WJV2_MIN_CONFIDENCE_SIZE > pstruWjTimeCountingDown->n32timeConfidence))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjTimeCountingDown->n32timeConfidence = %d",
                     pstruWjTimeCountingDown->n32timeConfidence);
            return false;
        }
        *(pstruAsnTimeCountingDown->timeConfidence) = pstruWjTimeCountingDown->n32timeConfidence;
    }
    else
    {
        pstruAsnTimeCountingDown->timeConfidence = NULL;
    }
    if (WJV2_PRESENT == pstruWjTimeCountingDown->u8nextStartTimePresent)
    {
        pstruAsnTimeCountingDown->nextStartTime = CALLOC(1, sizeof(TimeMark_t));
        if (NULL == pstruAsnTimeCountingDown->nextStartTime)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_TIMEMARK_SIZE < pstruWjTimeCountingDown->n32nextStartTime) || (WJV2_MIN_TIMEMARK_SIZE > pstruWjTimeCountingDown->n32nextStartTime))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjTimeCountingDown->n32nextStartTime = %d",
                     pstruWjTimeCountingDown->n32nextStartTime);
            return false;
        }
        *(pstruAsnTimeCountingDown->nextStartTime) = pstruWjTimeCountingDown->n32nextStartTime;
    }
    else
    {
        pstruAsnTimeCountingDown->nextStartTime = NULL;
    }
    if (WJV2_PRESENT == pstruWjTimeCountingDown->u8nextDurationPresent)
    {
        pstruAsnTimeCountingDown->nextDuration = CALLOC(1, sizeof(TimeMark_t));
        if (NULL == pstruAsnTimeCountingDown->nextDuration)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_TIMEMARK_SIZE < pstruWjTimeCountingDown->n32nextDuration) || (WJV2_MIN_TIMEMARK_SIZE > pstruWjTimeCountingDown->n32nextDuration))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjTimeCountingDown->n32nextDuration = %d",
                     pstruWjTimeCountingDown->n32nextDuration);
            return false;
        }
        *(pstruAsnTimeCountingDown->nextDuration) = pstruWjTimeCountingDown->n32nextDuration;
    }
    else
    {
        pstruAsnTimeCountingDown->nextDuration = NULL;
    }
    return true;
}
/**
* @brief     WJV2_TimeCountingDown_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_TimeCountingDown_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_TimeCountingDown *pstruWjTimeCountingDown = (WJV2_STRU_TimeCountingDown *)pvoidWjDf;
    TimeCountingDown_t *pstruAsnTimeCountingDown = (TimeCountingDown_t *)pvoidAsnDf;
    if ((WJV2_MAX_TIMEMARK_SIZE < pstruAsnTimeCountingDown->startTime) || (WJV2_MIN_TIMEMARK_SIZE > pstruAsnTimeCountingDown->startTime))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnTimeCountingDown->startTime = %d",
                 pstruAsnTimeCountingDown->startTime);
        return false;
    }
    pstruWjTimeCountingDown->n32startTime = pstruAsnTimeCountingDown->startTime;
    if (NULL != pstruAsnTimeCountingDown->minEndTime)
    {
        if ((WJV2_MAX_TIMEMARK_SIZE < *(pstruAsnTimeCountingDown->minEndTime)) || (WJV2_MIN_TIMEMARK_SIZE > *(pstruAsnTimeCountingDown->minEndTime)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnTimeCountingDown->minEndTime) = %d",
                     *(pstruAsnTimeCountingDown->minEndTime));
            return false;
        }
        pstruWjTimeCountingDown->n32minEndTime = *(pstruAsnTimeCountingDown->minEndTime);
        pstruWjTimeCountingDown->u8minEndTimePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjTimeCountingDown->u8minEndTimePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnTimeCountingDown->maxEndTime)
    {
        if ((WJV2_MAX_TIMEMARK_SIZE < *(pstruAsnTimeCountingDown->maxEndTime)) || (WJV2_MIN_TIMEMARK_SIZE > *(pstruAsnTimeCountingDown->maxEndTime)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnTimeCountingDown->maxEndTime) = %d",
                     *(pstruAsnTimeCountingDown->maxEndTime));
            return false;
        }
        pstruWjTimeCountingDown->n32maxEndTime = *(pstruAsnTimeCountingDown->maxEndTime);
        pstruWjTimeCountingDown->u8maxEndTimePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjTimeCountingDown->u8maxEndTimePresent = WJV2_ABSENT;
    }
    if ((WJV2_MAX_TIMEMARK_SIZE < pstruAsnTimeCountingDown->likelyEndTime) || (WJV2_MIN_TIMEMARK_SIZE > pstruAsnTimeCountingDown->likelyEndTime))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnTimeCountingDown->likelyEndTime = %d",
                 pstruAsnTimeCountingDown->likelyEndTime);
        return false;
    }
    pstruWjTimeCountingDown->n32likelyEndTime = pstruAsnTimeCountingDown->likelyEndTime;
    if (NULL != pstruAsnTimeCountingDown->timeConfidence)
    {
        if ((WJV2_MAX_CONFIDENCE_SIZE < *(pstruAsnTimeCountingDown->timeConfidence)) || (WJV2_MIN_CONFIDENCE_SIZE > *(pstruAsnTimeCountingDown->timeConfidence)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnTimeCountingDown->timeConfidence) = %d",
                     *(pstruAsnTimeCountingDown->timeConfidence));
            return false;
        }
        pstruWjTimeCountingDown->n32timeConfidence = *(pstruAsnTimeCountingDown->timeConfidence);
        pstruWjTimeCountingDown->u8timeConfidencePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjTimeCountingDown->u8timeConfidencePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnTimeCountingDown->nextStartTime)
    {
        if ((WJV2_MAX_TIMEMARK_SIZE < *(pstruAsnTimeCountingDown->nextStartTime)) || (WJV2_MIN_TIMEMARK_SIZE > *(pstruAsnTimeCountingDown->nextStartTime)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnTimeCountingDown->nextStartTime) = %d",
                     *(pstruAsnTimeCountingDown->nextStartTime));
            return false;
        }
        pstruWjTimeCountingDown->n32nextStartTime = *(pstruAsnTimeCountingDown->nextStartTime);
        pstruWjTimeCountingDown->u8nextStartTimePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjTimeCountingDown->u8nextStartTimePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnTimeCountingDown->nextDuration)
    {
        if ((WJV2_MAX_TIMEMARK_SIZE < *(pstruAsnTimeCountingDown->nextDuration)) || (WJV2_MIN_TIMEMARK_SIZE > *(pstruAsnTimeCountingDown->nextDuration)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnTimeCountingDown->nextDuration) = %d",
                     *(pstruAsnTimeCountingDown->nextDuration));
            return false;
        }
        pstruWjTimeCountingDown->n32nextDuration = *(pstruAsnTimeCountingDown->nextDuration);
        pstruWjTimeCountingDown->u8nextDurationPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjTimeCountingDown->u8nextDurationPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_UTCTiming_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_UTCTiming_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_UTCTiming *pstruWjUTCTiming = (WJV2_STRU_UTCTiming *)pvoidWjDf;
    UTCTiming_t *pstruAsnUTCTiming = (UTCTiming_t *)pvoidAsnDf;
    if ((WJV2_MAX_TIMEMARK_SIZE < pstruWjUTCTiming->n32startUTCTime) || (WJV2_MIN_TIMEMARK_SIZE > pstruWjUTCTiming->n32startUTCTime))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjUTCTiming->n32startUTCTime = %d",
                 pstruWjUTCTiming->n32startUTCTime);
        return false;
    }
    pstruAsnUTCTiming->startUTCTime = pstruWjUTCTiming->n32startUTCTime;
    if (WJV2_PRESENT == pstruWjUTCTiming->u8minEndUTCTimePresent)
    {
        pstruAsnUTCTiming->minEndUTCTime = CALLOC(1, sizeof(TimeMark_t));
        if (NULL == pstruAsnUTCTiming->minEndUTCTime)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_TIMEMARK_SIZE < pstruWjUTCTiming->n32minEndUTCTime) || (WJV2_MIN_TIMEMARK_SIZE > pstruWjUTCTiming->n32minEndUTCTime))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjUTCTiming->n32minEndUTCTime = %d",
                     pstruWjUTCTiming->n32minEndUTCTime);
            return false;
        }
        *(pstruAsnUTCTiming->minEndUTCTime) = pstruWjUTCTiming->n32minEndUTCTime;
    }
    else
    {
        pstruAsnUTCTiming->minEndUTCTime = NULL;
    }
    if (WJV2_PRESENT == pstruWjUTCTiming->u8maxEndUTCTimePresent)
    {
        pstruAsnUTCTiming->maxEndUTCTime = CALLOC(1, sizeof(TimeMark_t));
        if (NULL == pstruAsnUTCTiming->maxEndUTCTime)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_TIMEMARK_SIZE < pstruWjUTCTiming->n32maxEndUTCTime) || (WJV2_MIN_TIMEMARK_SIZE > pstruWjUTCTiming->n32maxEndUTCTime))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjUTCTiming->n32maxEndUTCTime = %d",
                     pstruWjUTCTiming->n32maxEndUTCTime);
            return false;
        }
        *(pstruAsnUTCTiming->maxEndUTCTime) = pstruWjUTCTiming->n32maxEndUTCTime;
    }
    else
    {
        pstruAsnUTCTiming->maxEndUTCTime = NULL;
    }
    if ((WJV2_MAX_TIMEMARK_SIZE < pstruWjUTCTiming->n32likelyEndUTCTime) || (WJV2_MIN_TIMEMARK_SIZE > pstruWjUTCTiming->n32likelyEndUTCTime))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjUTCTiming->n32likelyEndUTCTime = %d",
                 pstruWjUTCTiming->n32likelyEndUTCTime);
        return false;
    }
    pstruAsnUTCTiming->likelyEndUTCTime = pstruWjUTCTiming->n32likelyEndUTCTime;
    if (WJV2_PRESENT == pstruWjUTCTiming->u8timeConfidencePresent)
    {
        pstruAsnUTCTiming->timeConfidence = CALLOC(1, sizeof(Confidence_t));
        if (NULL == pstruAsnUTCTiming->timeConfidence)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_CONFIDENCE_SIZE < pstruWjUTCTiming->n32timeConfidence) || (WJV2_MIN_CONFIDENCE_SIZE > pstruWjUTCTiming->n32timeConfidence))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjUTCTiming->n32timeConfidence = %d",
                     pstruWjUTCTiming->n32timeConfidence);
            return false;
        }
        *(pstruAsnUTCTiming->timeConfidence) = pstruWjUTCTiming->n32timeConfidence;
    }
    else
    {
        pstruAsnUTCTiming->timeConfidence = NULL;
    }
    if (WJV2_PRESENT == pstruWjUTCTiming->u8nextStartUTCTimePresent)
    {
        pstruAsnUTCTiming->nextStartUTCTime = CALLOC(1, sizeof(TimeMark_t));
        if (NULL == pstruAsnUTCTiming->nextStartUTCTime)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_TIMEMARK_SIZE < pstruWjUTCTiming->n32nextStartUTCTime) || (WJV2_MIN_TIMEMARK_SIZE > pstruWjUTCTiming->n32nextStartUTCTime))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjUTCTiming->n32nextStartUTCTime = %d",
                     pstruWjUTCTiming->n32nextStartUTCTime);
            return false;
        }
        *(pstruAsnUTCTiming->nextStartUTCTime) = pstruWjUTCTiming->n32nextStartUTCTime;
    }
    else
    {
        pstruAsnUTCTiming->nextStartUTCTime = NULL;
    }
    if (WJV2_PRESENT == pstruWjUTCTiming->u8nextEndUTCTimePresent)
    {
        pstruAsnUTCTiming->nextEndUTCTime = CALLOC(1, sizeof(TimeMark_t));
        if (NULL == pstruAsnUTCTiming->nextEndUTCTime)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_TIMEMARK_SIZE < pstruWjUTCTiming->n32nextEndUTCTime) || (WJV2_MIN_TIMEMARK_SIZE > pstruWjUTCTiming->n32nextEndUTCTime))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjUTCTiming->n32nextEndUTCTime = %d",
                     pstruWjUTCTiming->n32nextEndUTCTime);
            return false;
        }
        *(pstruAsnUTCTiming->nextEndUTCTime) = pstruWjUTCTiming->n32nextEndUTCTime;
    }
    else
    {
        pstruAsnUTCTiming->nextEndUTCTime = NULL;
    }
    return true;
}
/**
* @brief     WJV2_UTCTiming_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_UTCTiming_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_UTCTiming *pstruWjUTCTiming = (WJV2_STRU_UTCTiming *)pvoidWjDf;
    UTCTiming_t *pstruAsnUTCTiming = (UTCTiming_t *)pvoidAsnDf;
    if ((WJV2_MAX_TIMEMARK_SIZE < pstruAsnUTCTiming->startUTCTime) || (WJV2_MIN_TIMEMARK_SIZE > pstruAsnUTCTiming->startUTCTime))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnUTCTiming->startUTCTime = %d",
                 pstruAsnUTCTiming->startUTCTime);
        return false;
    }
    pstruWjUTCTiming->n32startUTCTime = pstruAsnUTCTiming->startUTCTime;
    if (NULL != pstruAsnUTCTiming->minEndUTCTime)
    {
        if ((WJV2_MAX_TIMEMARK_SIZE < *(pstruAsnUTCTiming->minEndUTCTime)) || (WJV2_MIN_TIMEMARK_SIZE > *(pstruAsnUTCTiming->minEndUTCTime)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnUTCTiming->minEndUTCTime) = %d",
                     *(pstruAsnUTCTiming->minEndUTCTime));
            return false;
        }
        pstruWjUTCTiming->n32minEndUTCTime = *(pstruAsnUTCTiming->minEndUTCTime);
        pstruWjUTCTiming->u8minEndUTCTimePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjUTCTiming->u8minEndUTCTimePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnUTCTiming->maxEndUTCTime)
    {
        if ((WJV2_MAX_TIMEMARK_SIZE < *(pstruAsnUTCTiming->maxEndUTCTime)) || (WJV2_MIN_TIMEMARK_SIZE > *(pstruAsnUTCTiming->maxEndUTCTime)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnUTCTiming->maxEndUTCTime) = %d",
                     *(pstruAsnUTCTiming->maxEndUTCTime));
            return false;
        }
        pstruWjUTCTiming->n32maxEndUTCTime = *(pstruAsnUTCTiming->maxEndUTCTime);
        pstruWjUTCTiming->u8maxEndUTCTimePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjUTCTiming->u8maxEndUTCTimePresent = WJV2_ABSENT;
    }
    if ((WJV2_MAX_TIMEMARK_SIZE < pstruAsnUTCTiming->likelyEndUTCTime) || (WJV2_MIN_TIMEMARK_SIZE > pstruAsnUTCTiming->likelyEndUTCTime))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnUTCTiming->likelyEndUTCTime = %d",
                 pstruAsnUTCTiming->likelyEndUTCTime);
        return false;
    }
    pstruWjUTCTiming->n32likelyEndUTCTime = pstruAsnUTCTiming->likelyEndUTCTime;
    if (NULL != pstruAsnUTCTiming->timeConfidence)
    {
        if ((WJV2_MAX_CONFIDENCE_SIZE < *(pstruAsnUTCTiming->timeConfidence)) || (WJV2_MIN_CONFIDENCE_SIZE > *(pstruAsnUTCTiming->timeConfidence)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnUTCTiming->timeConfidence) = %d",
                     *(pstruAsnUTCTiming->timeConfidence));
            return false;
        }
        pstruWjUTCTiming->n32timeConfidence = *(pstruAsnUTCTiming->timeConfidence);
        pstruWjUTCTiming->u8timeConfidencePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjUTCTiming->u8timeConfidencePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnUTCTiming->nextStartUTCTime)
    {
        if ((WJV2_MAX_TIMEMARK_SIZE < *(pstruAsnUTCTiming->nextStartUTCTime)) || (WJV2_MIN_TIMEMARK_SIZE > *(pstruAsnUTCTiming->nextStartUTCTime)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnUTCTiming->nextStartUTCTime) = %d",
                     *(pstruAsnUTCTiming->nextStartUTCTime));
            return false;
        }
        pstruWjUTCTiming->n32nextStartUTCTime = *(pstruAsnUTCTiming->nextStartUTCTime);
        pstruWjUTCTiming->u8nextStartUTCTimePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjUTCTiming->u8nextStartUTCTimePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnUTCTiming->nextEndUTCTime)
    {
        if ((WJV2_MAX_TIMEMARK_SIZE < *(pstruAsnUTCTiming->nextEndUTCTime)) || (WJV2_MIN_TIMEMARK_SIZE > *(pstruAsnUTCTiming->nextEndUTCTime)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnUTCTiming->nextEndUTCTime) = %d",
                     *(pstruAsnUTCTiming->nextEndUTCTime));
            return false;
        }
        pstruWjUTCTiming->n32nextEndUTCTime = *(pstruAsnUTCTiming->nextEndUTCTime);
        pstruWjUTCTiming->u8nextEndUTCTimePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjUTCTiming->u8nextEndUTCTimePresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_VehicleClassification_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_VehicleClassification_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_VehicleClassification *pstruWjVehicleClassification = (WJV2_STRU_VehicleClassification *)pvoidWjDf;
    VehicleClassification_t *pstruAsnVehicleClassification = (VehicleClassification_t *)pvoidAsnDf;
    if ((WJV2_MAX_BASICVEHICLECLASS_SIZE < pstruWjVehicleClassification->n32classification) || (WJV2_MIN_BASICVEHICLECLASS_SIZE > pstruWjVehicleClassification->n32classification))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjVehicleClassification->n32classification = %d",
                 pstruWjVehicleClassification->n32classification);
        return false;
    }
    pstruAsnVehicleClassification->classification = pstruWjVehicleClassification->n32classification;
    if (WJV2_PRESENT == pstruWjVehicleClassification->u8fuelTypePresent)
    {
        pstruAsnVehicleClassification->fuelType = CALLOC(1, sizeof(FuelType_t));
        if (NULL == pstruAsnVehicleClassification->fuelType)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_FUELTYPE_SIZE < pstruWjVehicleClassification->n32fuelType) ||
            (WJV2_MIN_FUELTYPE_SIZE > pstruWjVehicleClassification->n32fuelType))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjVehicleClassification->n32fuelType = %d",
                     pstruWjVehicleClassification->n32fuelType);
            return false;
        }
        *(pstruAsnVehicleClassification->fuelType) = pstruWjVehicleClassification->n32fuelType;
    }
    else
    {
        pstruAsnVehicleClassification->fuelType = NULL;
    }
    return true;
}
/**
* @brief     WJV2_VehicleClassification_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_VehicleClassification_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_VehicleClassification *pstruWjVehicleClassification = (WJV2_STRU_VehicleClassification *)pvoidWjDf;
    VehicleClassification_t *pstruAsnVehicleClassification = (VehicleClassification_t *)pvoidAsnDf;
    if ((WJV2_MAX_BASICVEHICLECLASS_SIZE < pstruAsnVehicleClassification->classification) || (WJV2_MIN_BASICVEHICLECLASS_SIZE > pstruAsnVehicleClassification->classification))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnVehicleClassification->classification = %d",
                 pstruAsnVehicleClassification->classification);
        return false;
    }
    pstruWjVehicleClassification->n32classification = pstruAsnVehicleClassification->classification;
    if (NULL != pstruAsnVehicleClassification->fuelType)
    {
        if ((WJV2_MAX_FUELTYPE_SIZE < *(pstruAsnVehicleClassification->fuelType)) || (WJV2_MIN_FUELTYPE_SIZE > *(pstruAsnVehicleClassification->fuelType)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnVehicleClassification->fuelType) = %d",
                     *(pstruAsnVehicleClassification->fuelType));
            return false;
        }
        pstruWjVehicleClassification->n32fuelType = *(pstruAsnVehicleClassification->fuelType);
        pstruWjVehicleClassification->u8fuelTypePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjVehicleClassification->u8fuelTypePresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_VehicleEmergencyExtensions_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_VehicleEmergencyExtensions_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_VehicleEmergencyExtensions *pstruWjVehicleEmergencyExtensions = (WJV2_STRU_VehicleEmergencyExtensions *)pvoidWjDf;
    VehicleEmergencyExtensions_t *pstruAsnVehicleEmergencyExtensions = (VehicleEmergencyExtensions_t *)pvoidAsnDf;
    if (WJV2_PRESENT == pstruWjVehicleEmergencyExtensions->u8responseTypePresent)
    {
        pstruAsnVehicleEmergencyExtensions->responseType = CALLOC(1, sizeof(ResponseType_t));
        if (NULL == pstruAsnVehicleEmergencyExtensions->responseType)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnVehicleEmergencyExtensions->responseType) = pstruWjVehicleEmergencyExtensions->enumresponseType;
    }
    else
    {
        pstruAsnVehicleEmergencyExtensions->responseType = NULL;
    }
    if (WJV2_PRESENT == pstruWjVehicleEmergencyExtensions->u8sirenUsePresent)
    {
        pstruAsnVehicleEmergencyExtensions->sirenUse = CALLOC(1, sizeof(SirenInUse_t));
        if (NULL == pstruAsnVehicleEmergencyExtensions->sirenUse)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnVehicleEmergencyExtensions->sirenUse) = pstruWjVehicleEmergencyExtensions->enumsirenUse;
    }
    else
    {
        pstruAsnVehicleEmergencyExtensions->sirenUse = NULL;
    }
    if (WJV2_PRESENT == pstruWjVehicleEmergencyExtensions->u8lightsUsePresent)
    {
        pstruAsnVehicleEmergencyExtensions->lightsUse = CALLOC(1, sizeof(LightbarInUse_t));
        if (NULL == pstruAsnVehicleEmergencyExtensions->lightsUse)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnVehicleEmergencyExtensions->lightsUse) = pstruWjVehicleEmergencyExtensions->enumlightsUse;
    }
    else
    {
        pstruAsnVehicleEmergencyExtensions->lightsUse = NULL;
    }
    return true;
}
/**
* @brief     WJV2_VehicleEmergencyExtensions_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_VehicleEmergencyExtensions_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_VehicleEmergencyExtensions *pstruWjVehicleEmergencyExtensions = (WJV2_STRU_VehicleEmergencyExtensions *)pvoidWjDf;
    VehicleEmergencyExtensions_t *pstruAsnVehicleEmergencyExtensions = (VehicleEmergencyExtensions_t *)pvoidAsnDf;
    if (NULL != pstruAsnVehicleEmergencyExtensions->responseType)
    {
        pstruWjVehicleEmergencyExtensions->enumresponseType = *(pstruAsnVehicleEmergencyExtensions->responseType);
        pstruWjVehicleEmergencyExtensions->u8responseTypePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjVehicleEmergencyExtensions->u8responseTypePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnVehicleEmergencyExtensions->sirenUse)
    {
        pstruWjVehicleEmergencyExtensions->enumsirenUse = *(pstruAsnVehicleEmergencyExtensions->sirenUse);
        pstruWjVehicleEmergencyExtensions->u8sirenUsePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjVehicleEmergencyExtensions->u8sirenUsePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnVehicleEmergencyExtensions->lightsUse)
    {
        pstruWjVehicleEmergencyExtensions->enumlightsUse = *(pstruAsnVehicleEmergencyExtensions->lightsUse);
        pstruWjVehicleEmergencyExtensions->u8lightsUsePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjVehicleEmergencyExtensions->u8lightsUsePresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_VehicleSafetyExtensions_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_VehicleSafetyExtensions_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_VehicleSafetyExtensions *pstruWjVehicleSafetyExtensions = (WJV2_STRU_VehicleSafetyExtensions *)pvoidWjDf;
    VehicleSafetyExtensions_t *pstruAsnVehicleSafetyExtensions = (VehicleSafetyExtensions_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (WJV2_PRESENT == pstruWjVehicleSafetyExtensions->u8eventsPresent)
    {
        pstruAsnVehicleSafetyExtensions->events = CALLOC(1, sizeof(VehicleEventFlags_t));
        if (NULL == pstruAsnVehicleSafetyExtensions->events)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_VehicleEventFlags_DeEnc(pstruAsnVehicleSafetyExtensions->events,
                                              &(pstruWjVehicleSafetyExtensions->strbitevents));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_VehicleEventFlags_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnVehicleSafetyExtensions->events = NULL;
    }
    if (WJV2_PRESENT == pstruWjVehicleSafetyExtensions->u8pathHistoryPresent)
    {
        pstruAsnVehicleSafetyExtensions->pathHistory = CALLOC(1, sizeof(struct PathHistory));
        if (NULL == pstruAsnVehicleSafetyExtensions->pathHistory)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PathHistory_DfEnc(pstruAsnVehicleSafetyExtensions->pathHistory,
                                        &(pstruWjVehicleSafetyExtensions->strupathHistory));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PathHistory_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnVehicleSafetyExtensions->pathHistory = NULL;
    }
    if (WJV2_PRESENT == pstruWjVehicleSafetyExtensions->u8pathPredictionPresent)
    {
        pstruAsnVehicleSafetyExtensions->pathPrediction = CALLOC(1, sizeof(struct PathPrediction));
        if (NULL == pstruAsnVehicleSafetyExtensions->pathPrediction)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PathPrediction_DfEnc(pstruAsnVehicleSafetyExtensions->pathPrediction,
                                           &(pstruWjVehicleSafetyExtensions->strupathPrediction));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PathPrediction_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnVehicleSafetyExtensions->pathPrediction = NULL;
    }
    if (WJV2_PRESENT == pstruWjVehicleSafetyExtensions->u8lightsPresent)
    {
        pstruAsnVehicleSafetyExtensions->lights = CALLOC(1, sizeof(ExteriorLights_t));
        if (NULL == pstruAsnVehicleSafetyExtensions->lights)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ExteriorLights_DeEnc(pstruAsnVehicleSafetyExtensions->lights,
                                           &(pstruWjVehicleSafetyExtensions->strbitlights));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ExteriorLights_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnVehicleSafetyExtensions->lights = NULL;
    }
    return true;
}
/**
* @brief     WJV2_VehicleSafetyExtensions_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_VehicleSafetyExtensions_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_VehicleSafetyExtensions *pstruWjVehicleSafetyExtensions = (WJV2_STRU_VehicleSafetyExtensions *)pvoidWjDf;
    VehicleSafetyExtensions_t *pstruAsnVehicleSafetyExtensions = (VehicleSafetyExtensions_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (NULL != pstruAsnVehicleSafetyExtensions->events)
    {
        n32Ret = WJV2_VehicleEventFlags_DeDec(pstruAsnVehicleSafetyExtensions->events,
                                              &(pstruWjVehicleSafetyExtensions->strbitevents));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_VehicleEventFlags_DeDec is err");
            return false;
        }
        pstruWjVehicleSafetyExtensions->u8eventsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjVehicleSafetyExtensions->u8eventsPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnVehicleSafetyExtensions->pathHistory)
    {
        n32Ret = WJV2_PathHistory_DfDec(pstruAsnVehicleSafetyExtensions->pathHistory,
                                        &(pstruWjVehicleSafetyExtensions->strupathHistory));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PathHistory_DfDec is err");
            return false;
        }
        pstruWjVehicleSafetyExtensions->u8pathHistoryPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjVehicleSafetyExtensions->u8pathHistoryPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnVehicleSafetyExtensions->pathPrediction)
    {
        n32Ret = WJV2_PathPrediction_DfDec(pstruAsnVehicleSafetyExtensions->pathPrediction,
                                           &(pstruWjVehicleSafetyExtensions->strupathPrediction));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PathPrediction_DfDec is err");
            return false;
        }
        pstruWjVehicleSafetyExtensions->u8pathPredictionPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjVehicleSafetyExtensions->u8pathPredictionPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnVehicleSafetyExtensions->lights)
    {
        n32Ret = WJV2_ExteriorLights_DeDec(pstruAsnVehicleSafetyExtensions->lights,
                                           &(pstruWjVehicleSafetyExtensions->strbitlights));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ExteriorLights_DeDec is err");
            return false;
        }
        pstruWjVehicleSafetyExtensions->u8lightsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjVehicleSafetyExtensions->u8lightsPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_VehicleSize_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_VehicleSize_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_VehicleSize *pstruWjVehicleSize = (WJV2_STRU_VehicleSize *)pvoidWjDf;
    VehicleSize_t *pstruAsnVehicleSize = (VehicleSize_t *)pvoidAsnDf;
    if ((WJV2_MAX_VEHICLEWIDTH_SIZE < pstruWjVehicleSize->n32width) || (WJV2_MIN_VEHICLEWIDTH_SIZE > pstruWjVehicleSize->n32width))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjVehicleSize->n32width = %d",
                 pstruWjVehicleSize->n32width);
        return false;
    }
    pstruAsnVehicleSize->width = pstruWjVehicleSize->n32width;
    if ((WJV2_MAX_VEHICLELENGTH_SIZE < pstruWjVehicleSize->n32length) || (WJV2_MIN_VEHICLELENGTH_SIZE > pstruWjVehicleSize->n32length))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjVehicleSize->n32length = %d",
                 pstruWjVehicleSize->n32length);
        return false;
    }
    pstruAsnVehicleSize->length = pstruWjVehicleSize->n32length;
    if (WJV2_PRESENT == pstruWjVehicleSize->u8heightPresent)
    {
        pstruAsnVehicleSize->height = CALLOC(1, sizeof(VehicleHeight_t));
        if (NULL == pstruAsnVehicleSize->height)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_VEHICLEHEIGHT_SIZE < pstruWjVehicleSize->n32height) || (WJV2_MIN_VEHICLEHEIGHT_SIZE > pstruWjVehicleSize->n32height))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjVehicleSize->n32height = %d",
                     pstruWjVehicleSize->n32height);
            return false;
        }
        *(pstruAsnVehicleSize->height) = pstruWjVehicleSize->n32height;
    }
    else
    {
        pstruAsnVehicleSize->height = NULL;
    }
    return true;
}
/**
* @brief     WJV2_VehicleSize_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_VehicleSize_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_VehicleSize *pstruWjVehicleSize = (WJV2_STRU_VehicleSize *)pvoidWjDf;
    VehicleSize_t *pstruAsnVehicleSize = (VehicleSize_t *)pvoidAsnDf;
    if ((WJV2_MAX_VEHICLEWIDTH_SIZE < pstruAsnVehicleSize->width) || (WJV2_MIN_VEHICLEWIDTH_SIZE > pstruAsnVehicleSize->width))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnVehicleSize->width = %d",
                 pstruAsnVehicleSize->width);
        return false;
    }
    pstruWjVehicleSize->n32width = pstruAsnVehicleSize->width;
    if ((WJV2_MAX_VEHICLELENGTH_SIZE < pstruAsnVehicleSize->length) || (WJV2_MIN_VEHICLELENGTH_SIZE > pstruAsnVehicleSize->length))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnVehicleSize->length = %d",
                 pstruAsnVehicleSize->length);
        return false;
    }
    pstruWjVehicleSize->n32length = pstruAsnVehicleSize->length;
    if (NULL != pstruAsnVehicleSize->height)
    {
        if ((WJV2_MAX_VEHICLEHEIGHT_SIZE < *(pstruAsnVehicleSize->height)) || (WJV2_MIN_VEHICLEHEIGHT_SIZE > *(pstruAsnVehicleSize->height)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnVehicleSize->height) = %d",
                     *(pstruAsnVehicleSize->height));
            return false;
        }
        pstruWjVehicleSize->n32height = *(pstruAsnVehicleSize->height);
        pstruWjVehicleSize->u8heightPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjVehicleSize->u8heightPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_VerticalOffset_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_VerticalOffset_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_VerticalOffset *pstruWjVerticalOffset = (WJV2_STRU_VerticalOffset *)pvoidWjDf;
    VerticalOffset_t *pstruAsnVerticalOffset = (VerticalOffset_t *)pvoidAsnDf;
    if (WJV2_VertOffsetB07 == pstruWjVerticalOffset->enumVerticalOffsetChoice)
    {
        if ((WJV2_MAX_VERTOFFSETB07_SIZE < pstruWjVerticalOffset->u.n32offset1) || (WJV2_MIN_VERTOFFSETB07_SIZE > pstruWjVerticalOffset->u.n32offset1))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjVerticalOffset->u.n32offset1 = %d",
                     pstruWjVerticalOffset->u.n32offset1);
            return false;
        }
        pstruAsnVerticalOffset->choice.offset1 = pstruWjVerticalOffset->u.n32offset1;
        pstruAsnVerticalOffset->present = VerticalOffset_PR_offset1;
    }
    else if (WJV2_VertOffsetB08 == pstruWjVerticalOffset->enumVerticalOffsetChoice)
    {
        if ((WJV2_MAX_VERTOFFSETB08_SIZE < pstruWjVerticalOffset->u.n32offset2) || (WJV2_MIN_VERTOFFSETB08_SIZE > pstruWjVerticalOffset->u.n32offset2))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjVerticalOffset->u.n32offset2 = %d",
                     pstruWjVerticalOffset->u.n32offset2);
            return false;
        }
        pstruAsnVerticalOffset->choice.offset2 = pstruWjVerticalOffset->u.n32offset2;
        pstruAsnVerticalOffset->present = VerticalOffset_PR_offset2;
    }
    else if (WJV2_VertOffsetB09 == pstruWjVerticalOffset->enumVerticalOffsetChoice)
    {
        if ((WJV2_MAX_VERTOFFSETB09_SIZE < pstruWjVerticalOffset->u.n32offset3) || (WJV2_MIN_VERTOFFSETB09_SIZE > pstruWjVerticalOffset->u.n32offset3))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjVerticalOffset->u.n32offset3 = %d",
                     pstruWjVerticalOffset->u.n32offset3);
            return false;
        }
        pstruAsnVerticalOffset->choice.offset3 = pstruWjVerticalOffset->u.n32offset3;
        pstruAsnVerticalOffset->present = VerticalOffset_PR_offset3;
    }
    else if (WJV2_VertOffsetB10 == pstruWjVerticalOffset->enumVerticalOffsetChoice)
    {
        if ((WJV2_MAX_VERTOFFSETB10_SIZE < pstruWjVerticalOffset->u.n32offset4) || (WJV2_MIN_VERTOFFSETB10_SIZE > pstruWjVerticalOffset->u.n32offset4))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjVerticalOffset->u.n32offset4 = %d",
                     pstruWjVerticalOffset->u.n32offset4);
            return false;
        }
        pstruAsnVerticalOffset->choice.offset4 = pstruWjVerticalOffset->u.n32offset4;
        pstruAsnVerticalOffset->present = VerticalOffset_PR_offset4;
    }
    else if (WJV2_VertOffsetB11 == pstruWjVerticalOffset->enumVerticalOffsetChoice)
    {
        if ((WJV2_MAX_VERTOFFSETB11_SIZE < pstruWjVerticalOffset->u.n32offset5) || (WJV2_MIN_VERTOFFSETB11_SIZE > pstruWjVerticalOffset->u.n32offset5))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjVerticalOffset->u.n32offset5 = %d",
                     pstruWjVerticalOffset->u.n32offset5);
            return false;
        }
        pstruAsnVerticalOffset->choice.offset5 = pstruWjVerticalOffset->u.n32offset5;
        pstruAsnVerticalOffset->present = VerticalOffset_PR_offset5;
    }
    else if (WJV2_VertOffsetB12 == pstruWjVerticalOffset->enumVerticalOffsetChoice)
    {
        if ((WJV2_MAX_VERTOFFSETB12_SIZE < pstruWjVerticalOffset->u.n32offset6) || (WJV2_MIN_VERTOFFSETB12_SIZE > pstruWjVerticalOffset->u.n32offset6))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjVerticalOffset->u.n32offset6 = %d",
                     pstruWjVerticalOffset->u.n32offset6);
            return false;
        }
        pstruAsnVerticalOffset->choice.offset6 = pstruWjVerticalOffset->u.n32offset6;
        pstruAsnVerticalOffset->present = VerticalOffset_PR_offset6;
    }
    else if (WJV2_Elevation == pstruWjVerticalOffset->enumVerticalOffsetChoice)
    {
        if ((WJV2_MAX_ELEVATION_SIZE < pstruWjVerticalOffset->u.n32elevation) || (WJV2_MIN_ELEVATION_SIZE > pstruWjVerticalOffset->u.n32elevation))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjVerticalOffset->u.n32elevation = %d",
                     pstruWjVerticalOffset->u.n32elevation);
            return false;
        }
        pstruAsnVerticalOffset->choice.elevation = pstruWjVerticalOffset->u.n32elevation;
        pstruAsnVerticalOffset->present = VerticalOffset_PR_elevation;
    }
    else
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "type is err pstruWjVerticalOffset->enumVerticalOffsetChoice = %d",
                 pstruWjVerticalOffset->enumVerticalOffsetChoice);
        return false;
    }
    return true;
}
/**
* @brief     WJV2_VerticalOffset_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-18  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_VerticalOffset_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_VerticalOffset *pstruWjVerticalOffset = (WJV2_STRU_VerticalOffset *)pvoidWjDf;
    VerticalOffset_t *pstruAsnVerticalOffset = (VerticalOffset_t *)pvoidAsnDf;
    if (VerticalOffset_PR_offset1 == pstruAsnVerticalOffset->present)
    {
        if ((WJV2_MAX_VERTOFFSETB07_SIZE < pstruAsnVerticalOffset->choice.offset1) || (WJV2_MIN_VERTOFFSETB07_SIZE > pstruAsnVerticalOffset->choice.offset1))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruAsnVerticalOffset->choice.offset1 = %d",
                     pstruAsnVerticalOffset->choice.offset1);
            return false;
        }
        pstruWjVerticalOffset->u.n32offset1 = pstruAsnVerticalOffset->choice.offset1;
        pstruWjVerticalOffset->enumVerticalOffsetChoice = pstruAsnVerticalOffset->present;
    }
    else if (VerticalOffset_PR_offset2 == pstruAsnVerticalOffset->present)
    {
        if ((WJV2_MAX_VERTOFFSETB08_SIZE < pstruAsnVerticalOffset->choice.offset2) || (WJV2_MIN_VERTOFFSETB08_SIZE > pstruAsnVerticalOffset->choice.offset2))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruAsnVerticalOffset->choice.offset2 = %d",
                     pstruAsnVerticalOffset->choice.offset2);
            return false;
        }
        pstruWjVerticalOffset->u.n32offset2 = pstruAsnVerticalOffset->choice.offset2;
        pstruWjVerticalOffset->enumVerticalOffsetChoice = pstruAsnVerticalOffset->present;
    }
    else if (VerticalOffset_PR_offset3 == pstruAsnVerticalOffset->present)
    {
        if ((WJV2_MAX_VERTOFFSETB09_SIZE < pstruAsnVerticalOffset->choice.offset3) || (WJV2_MIN_VERTOFFSETB09_SIZE > pstruAsnVerticalOffset->choice.offset3))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruAsnVerticalOffset->choice.offset3 = %d",
                     pstruAsnVerticalOffset->choice.offset3);
            return false;
        }
        pstruWjVerticalOffset->u.n32offset3 = pstruAsnVerticalOffset->choice.offset3;
        pstruWjVerticalOffset->enumVerticalOffsetChoice = pstruAsnVerticalOffset->present;
    }
    else if (VerticalOffset_PR_offset4 == pstruAsnVerticalOffset->present)
    {
        if ((WJV2_MAX_VERTOFFSETB10_SIZE < pstruAsnVerticalOffset->choice.offset4) || (WJV2_MIN_VERTOFFSETB10_SIZE > pstruAsnVerticalOffset->choice.offset4))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruAsnVerticalOffset->choice.offset4 = %d",
                     pstruAsnVerticalOffset->choice.offset4);
            return false;
        }
        pstruWjVerticalOffset->u.n32offset4 = pstruAsnVerticalOffset->choice.offset4;
        pstruWjVerticalOffset->enumVerticalOffsetChoice = pstruAsnVerticalOffset->present;
    }
    else if (VerticalOffset_PR_offset5 == pstruAsnVerticalOffset->present)
    {
        if ((WJV2_MAX_VERTOFFSETB11_SIZE < pstruAsnVerticalOffset->choice.offset5) || (WJV2_MIN_VERTOFFSETB11_SIZE > pstruAsnVerticalOffset->choice.offset5))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruAsnVerticalOffset->choice.offset5 = %d",
                     pstruAsnVerticalOffset->choice.offset5);
            return false;
        }
        pstruWjVerticalOffset->u.n32offset5 = pstruAsnVerticalOffset->choice.offset5;
        pstruWjVerticalOffset->enumVerticalOffsetChoice = pstruAsnVerticalOffset->present;
    }
    else if (VerticalOffset_PR_offset6 == pstruAsnVerticalOffset->present)
    {
        if ((WJV2_MAX_VERTOFFSETB12_SIZE < pstruAsnVerticalOffset->choice.offset6) || (WJV2_MIN_VERTOFFSETB12_SIZE > pstruAsnVerticalOffset->choice.offset6))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruAsnVerticalOffset->choice.offset6 = %d",
                     pstruAsnVerticalOffset->choice.offset6);
            return false;
        }
        pstruWjVerticalOffset->u.n32offset6 = pstruAsnVerticalOffset->choice.offset6;
        pstruWjVerticalOffset->enumVerticalOffsetChoice = pstruAsnVerticalOffset->present;
    }
    else if (VerticalOffset_PR_elevation == pstruAsnVerticalOffset->present)
    {
        if ((WJV2_MAX_ELEVATION_SIZE < pstruAsnVerticalOffset->choice.elevation) || (WJV2_MIN_ELEVATION_SIZE > pstruAsnVerticalOffset->choice.elevation))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruAsnVerticalOffset->choice.elevation = %d",
                     pstruAsnVerticalOffset->choice.elevation);
            return false;
        }
        pstruWjVerticalOffset->u.n32elevation = pstruAsnVerticalOffset->choice.elevation;
        pstruWjVerticalOffset->enumVerticalOffsetChoice = pstruAsnVerticalOffset->present;
    }
    else
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "type is err pstruAsnVerticalOffset->present = %d",
                 pstruAsnVerticalOffset->present);
        return false;
    }
    return true;
}
/***** 文件结束 *****/

/**
* @brief     WJV2_AccountInfo_DfEnc编码函数
* @details   协议栈AccountInfo编解码中 统一AccountInfo的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_AccountInfo_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_OCT_AccountInfoData *pstruWjAccountInfo = (WJV2_OCT_AccountInfoData *)pvoidWjDf;
    AccountInfo_t *pstruAsnAccountInfo = (AccountInfo_t *)pvoidAsnDf;
    if ((WJV2_MAX_OCTAccountInfo_SIZE < pstruWjAccountInfo->u8OCTAccountInfoNum) ||
        (WJV2_MIN_OCTAccountInfo_SIZE < pstruWjAccountInfo->u8OCTAccountInfoNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjAccountInfo->u8OCTAccountInfoNum = %d",
                 pstruWjAccountInfo->u8OCTAccountInfoNum);
        return false;
    }

    pstruAsnAccountInfo->account.size = pstruWjAccountInfo->u8OCTAccountInfoNum;
    pstruAsnAccountInfo->account.buf = CALLOC(1, pstruAsnAccountInfo->account.size);
    if (NULL == pstruAsnAccountInfo->account.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruAsnAccountInfo->account.buf, pstruWjAccountInfo->u8OCTAccountInfo, pstruAsnAccountInfo->account.size);

    return true;
}
/**
* @brief     WJV2_AccountInfo_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_AccountInfo_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    WJV2_OCT_AccountInfoData *pstruWjAccountInfo = (WJV2_OCT_AccountInfoData *)pvoidWjDf;
    AccountInfo_t *pstruAsnAccountInfo = (AccountInfo_t *)pvoidAsnDf;
    if ((WJV2_MAX_OCTAccountInfo_SIZE < pstruAsnAccountInfo->account.size) ||
        (WJV2_MIN_OCTAccountInfo_SIZE < pstruAsnAccountInfo->account.size))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnAccountInfo->account.size = %d",
                 pstruAsnAccountInfo->account.size);
        return false;
    }

    if (NULL == pstruAsnAccountInfo->account.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    pstruWjAccountInfo->u8OCTAccountInfoNum = pstruAsnAccountInfo->account.size;
    memcpy(pstruWjAccountInfo->u8OCTAccountInfo, pstruAsnAccountInfo->account.buf, pstruAsnAccountInfo->account.size);

    return true;
}
/**
* @brief     WJV2_AccSet4WayConfidence_DfEnc编码函数
* @details   协议栈AccSet4WayConfidence编解码中 统一AccSet4WayConfidence的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_AccSet4WayConfidence_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_AccSet4WayConfidence *pstruWjAccSet4WayConfidence = (WJV2_STRU_AccSet4WayConfidence *)pvoidWjDf;
    AccSet4WayConfidence_t *pstruAsnAccSet4WayConfidence = (AccSet4WayConfidence_t *)pvoidAsnDf;
    pstruAsnAccSet4WayConfidence->latAccConfidence = pstruWjAccSet4WayConfidence->enumlatAccConfidence;
    pstruAsnAccSet4WayConfidence->lonAccConfidence = pstruWjAccSet4WayConfidence->enumlonAccConfidence;
    pstruAsnAccSet4WayConfidence->vertAccConfidence = pstruWjAccSet4WayConfidence->enumvertAccConfidence;
    pstruAsnAccSet4WayConfidence->yawRateCon = pstruWjAccSet4WayConfidence->enumyawRateCon;

    return true;
}
/**
* @brief     WJV2_AccSet4WayConfidence_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_AccSet4WayConfidence_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_AccSet4WayConfidence *pstruWjAccSet4WayConfidence = (WJV2_STRU_AccSet4WayConfidence *)pvoidWjDf;
    AccSet4WayConfidence_t *pstruAsnAccSet4WayConfidence = (AccSet4WayConfidence_t *)pvoidAsnDf;
    pstruWjAccSet4WayConfidence->enumlatAccConfidence = pstruAsnAccSet4WayConfidence->latAccConfidence;
    pstruWjAccSet4WayConfidence->enumlonAccConfidence = pstruAsnAccSet4WayConfidence->lonAccConfidence;
    pstruWjAccSet4WayConfidence->enumvertAccConfidence = pstruAsnAccSet4WayConfidence->vertAccConfidence;
    pstruWjAccSet4WayConfidence->enumyawRateCon = pstruAsnAccSet4WayConfidence->yawRateCon;

    return true;
}
/**
* @brief     WJV2_ActionRequest_DfEnc编码函数
* @details   协议栈ActionRequest编解码中 统一ActionRequest的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ActionRequest_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    Action_Request_t *pstruAsnActionRequest = (Action_Request_t *)pvoidAsnDf;
    WJV2_STRU_Action_Request *pstruWjActionRequest = (WJV2_STRU_Action_Request *)pvoidWjDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_DDateTime_DfEnc(&(pstruAsnActionRequest->time), &(pstruWjActionRequest->strutime));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV4_DDateTime_DfEnc is err");
        return false;
    }
    pstruAsnActionRequest->mode = pstruWjActionRequest->n32mode;

    if ((WJV2_MAX_OCTsourceId_SIZE != pstruWjActionRequest->u8OCTsourceIdNum) /*||
        (1 > pstruWjActionRequest->u8OCTsourceIdNum)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjActionRequest->u8OCTsourceIdNum = %d",
                 pstruWjActionRequest->u8OCTsourceIdNum);
        return false;
    }
    pstruAsnActionRequest->sourceId.size = pstruWjActionRequest->u8OCTsourceIdNum;
    pstruAsnActionRequest->sourceId.buf = CALLOC(1, pstruAsnActionRequest->sourceId.size);
    if (NULL == pstruAsnActionRequest->sourceId.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruAsnActionRequest->sourceId.buf, pstruWjActionRequest->u8OCTsourceId, pstruAsnActionRequest->sourceId.size);

    if (WJV2_PRESENT == pstruWjActionRequest->u8targetIdPresent)
    {
        if ((WJV2_MAX_OCTtargetId_SIZE != pstruWjActionRequest->u8OCTtargetIdNum) /*||
            (1 > pstruWjActionRequest->u8OCTtargetIdNum)*/
        )
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjActionRequest->u8OCTtargetIdNum = %d",
                     pstruWjActionRequest->u8OCTtargetIdNum);
            return false;
        }

        pstruAsnActionRequest->targetId = CALLOC(1, sizeof(OCTET_STRING_t));
        if (NULL == pstruAsnActionRequest->targetId)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        pstruAsnActionRequest->targetId->size = pstruWjActionRequest->u8OCTtargetIdNum;
        pstruAsnActionRequest->targetId->buf = CALLOC(1, pstruAsnActionRequest->sourceId.size);
        if (NULL == pstruAsnActionRequest->targetId->buf)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        memcpy(pstruAsnActionRequest->targetId->buf, pstruWjActionRequest->u8OCTtargetId, pstruAsnActionRequest->targetId->size);
    }
    else
    {
        pstruAsnActionRequest->targetId = NULL;
    }
    pstruAsnActionRequest->paymentEntityId = pstruWjActionRequest->enumpaymentEntityId;

    n32Ret = WJV2_TransInfo_DfEnc(&(pstruAsnActionRequest->actionParameter), &(pstruWjActionRequest->struactionParameter));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_TransInfo_DfEnc is err");
        return false;
    }

    if (WJV2_PRESENT == pstruWjActionRequest->u8accessCredentialsPresent)
    {
        if ((WJV2_MAX_OCTaccessCredentials_SIZE != pstruWjActionRequest->u8OCTaccessCredentialsNum) /*||
            (1 > pstruWjActionRequest->u8OCTaccessCredentialsNum)*/
        )
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjActionRequest->u8OCTaccessCredentialsNum = %d",
                     pstruWjActionRequest->u8OCTaccessCredentialsNum);
            return false;
        }

        pstruAsnActionRequest->accessCredentials = CALLOC(1, sizeof(OCTET_STRING_t));
        if (NULL == pstruAsnActionRequest->accessCredentials)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        pstruAsnActionRequest->accessCredentials->size = pstruWjActionRequest->u8OCTaccessCredentialsNum;
        pstruAsnActionRequest->accessCredentials->buf = CALLOC(1, pstruAsnActionRequest->sourceId.size);
        if (NULL == pstruAsnActionRequest->accessCredentials->buf)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        memcpy(pstruAsnActionRequest->accessCredentials->buf, pstruWjActionRequest->u8OCTaccessCredentials, pstruAsnActionRequest->accessCredentials->size);
    }
    else
    {
        pstruAsnActionRequest->accessCredentials = NULL;
    }

    return true;
}
/**
* @brief     WJV2_ActionRequest_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ActionRequest_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    Action_Request_t *pstruAsnActionRequest = (Action_Request_t *)pvoidAsnDf;
    WJV2_STRU_Action_Request *pstruWjActionRequest = (WJV2_STRU_Action_Request *)pvoidWjDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_DDateTime_DfDec(&(pstruAsnActionRequest->time), &(pstruWjActionRequest->strutime));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_DDateTime_DfDec is err");
        return false;
    }
    pstruWjActionRequest->n32mode = pstruAsnActionRequest->mode;

    if ((WJV2_MAX_OCTsourceId_SIZE != pstruAsnActionRequest->sourceId.size) /*||
        (1 > pstruAsnActionRequest->sourceId.size)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnActionRequest->sourceId.size = %d",
                 pstruAsnActionRequest->sourceId.size);
        return false;
    }
    pstruWjActionRequest->u8OCTsourceIdNum = pstruAsnActionRequest->sourceId.size;

    if (NULL == pstruAsnActionRequest->sourceId.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruWjActionRequest->u8OCTsourceId, pstruAsnActionRequest->sourceId.buf, pstruAsnActionRequest->sourceId.size);

    if (NULL != pstruAsnActionRequest->targetId)
    {
        if ((WJV2_MAX_OCTtargetId_SIZE != pstruAsnActionRequest->targetId->size) /*||
            (1 > pstruAsnActionRequest->targetId->size)*/
        )
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruAsnActionRequest->targetId->size = %d",
                     pstruAsnActionRequest->targetId->size);
            return false;
        }

        pstruWjActionRequest->u8OCTtargetIdNum = pstruAsnActionRequest->targetId->size;

        if (NULL == pstruAsnActionRequest->targetId->buf)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        memcpy(pstruWjActionRequest->u8OCTtargetId, pstruAsnActionRequest->targetId->buf, pstruAsnActionRequest->targetId->size);
        pstruWjActionRequest->u8targetIdPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjActionRequest->u8targetIdPresent = WJV2_ABSENT;
    }
    pstruWjActionRequest->enumpaymentEntityId = pstruAsnActionRequest->paymentEntityId;

    n32Ret = WJV2_TransInfo_DfDec(&(pstruAsnActionRequest->actionParameter), &(pstruWjActionRequest->struactionParameter));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_TransInfo_DfDec is err");
        return false;
    }

    if (NULL != pstruAsnActionRequest->accessCredentials)
    {
        if ((WJV2_MAX_OCTaccessCredentials_SIZE != pstruAsnActionRequest->accessCredentials->size) /*||
            (1 > pstruAsnActionRequest->accessCredentials->size)*/
        )
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruAsnActionRequest->accessCredentials->size = %d",
                     pstruAsnActionRequest->accessCredentials->size);
            return false;
        }

        pstruWjActionRequest->u8OCTaccessCredentialsNum = pstruAsnActionRequest->accessCredentials->size;

        if (NULL == pstruAsnActionRequest->accessCredentials->buf)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        memcpy(pstruWjActionRequest->u8OCTaccessCredentials, pstruAsnActionRequest->accessCredentials->buf, pstruAsnActionRequest->accessCredentials->size);
        pstruWjActionRequest->u8accessCredentialsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjActionRequest->u8accessCredentialsPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_ActionResponse_DfEnc编码函数
* @details   协议栈ActionResponse编解码中 统一ActionResponse的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ActionResponse_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    Action_Response_t *pstruAsnActionResponse = (Action_Response_t *)pvoidAsnDf;
    WJV2_STRU_Action_Response *pstruWjActionResponse = (WJV2_STRU_Action_Response *)pvoidWjDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_DDateTime_DfEnc(&(pstruAsnActionResponse->time), &(pstruWjActionResponse->strutime));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV4_DDateTime_DfEnc is err");
        return false;
    }

    if ((WJV2_MAX_OCTsourceId_SIZE != pstruWjActionResponse->u8OCTsourceIdNum) /*||
        (1 > pstruWjActionResponse->u8OCTsourceIdNum)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjActionResponse->u8OCTsourceIdNum = %d",
                 pstruWjActionResponse->u8OCTsourceIdNum);
        return false;
    }
    pstruAsnActionResponse->sourceId.size = pstruWjActionResponse->u8OCTsourceIdNum;
    pstruAsnActionResponse->sourceId.buf = CALLOC(1, pstruAsnActionResponse->sourceId.size);
    if (NULL == pstruAsnActionResponse->sourceId.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruAsnActionResponse->sourceId.buf, pstruWjActionResponse->u8OCTsourceId, pstruAsnActionResponse->sourceId.size);

    if (WJV2_PRESENT == pstruWjActionResponse->u8targetIdPresent)
    {
        if ((WJV2_MAX_OCTtargetId_SIZE != pstruWjActionResponse->u8OCTtargetIdNum) /*||
            (1 > pstruWjActionResponse->u8OCTtargetIdNum)*/
        )
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjActionResponse->u8OCTtargetIdNum = %d",
                     pstruWjActionResponse->u8OCTtargetIdNum);
            return false;
        }

        pstruAsnActionResponse->targetId = CALLOC(1, sizeof(OCTET_STRING_t));
        if (NULL == pstruAsnActionResponse->targetId)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        pstruAsnActionResponse->targetId->size = pstruWjActionResponse->u8OCTtargetIdNum;
        pstruAsnActionResponse->targetId->buf = CALLOC(1, pstruAsnActionResponse->sourceId.size);
        if (NULL == pstruAsnActionResponse->targetId->buf)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        memcpy(pstruAsnActionResponse->targetId->buf, pstruWjActionResponse->u8OCTtargetId, pstruAsnActionResponse->targetId->size);
    }
    else
    {
        pstruAsnActionResponse->targetId = NULL;
    }
    pstruAsnActionResponse->paymentEntityId = pstruWjActionResponse->enumpaymentEntityId;

    if (WJV2_PRESENT == pstruWjActionResponse->u8responseParameterPresent)
    {
        pstruAsnActionResponse->responseParameter = CALLOC(1, sizeof(TransInfo_t));
        if (NULL == pstruAsnActionResponse->responseParameter)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_TransInfo_DfEnc((pstruAsnActionResponse->responseParameter), &(pstruWjActionResponse->struresponseParameter));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_TransInfo_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnActionResponse->responseParameter = NULL;
    }

    pstruAsnActionResponse->ret = pstruWjActionResponse->enumret;

    return true;
}
/**
* @brief     WJV2_ActionResponse_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ActionResponse_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    Action_Response_t *pstruAsnActionResponse = (Action_Response_t *)pvoidAsnDf;
    WJV2_STRU_Action_Response *pstruWjActionResponse = (WJV2_STRU_Action_Response *)pvoidWjDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_DDateTime_DfDec(&(pstruAsnActionResponse->time), &(pstruWjActionResponse->strutime));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_DDateTime_DfDec is err");
        return false;
    }

    if ((WJV2_MAX_OCTsourceId_SIZE != pstruAsnActionResponse->sourceId.size) /*||
        (1 > pstruAsnActionResponse->sourceId.size)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnActionResponse->sourceId.size = %d",
                 pstruAsnActionResponse->sourceId.size);
        return false;
    }
    pstruWjActionResponse->u8OCTsourceIdNum = pstruAsnActionResponse->sourceId.size;

    if (NULL == pstruAsnActionResponse->sourceId.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruWjActionResponse->u8OCTsourceId, pstruAsnActionResponse->sourceId.buf, pstruAsnActionResponse->sourceId.size);

    if (NULL != pstruAsnActionResponse->targetId)
    {
        if ((WJV2_MAX_OCTtargetId_SIZE != pstruAsnActionResponse->targetId->size) /*||
            (1 > pstruAsnActionResponse->targetId->size)*/
        )
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruAsnActionResponse->targetId->size = %d",
                     pstruAsnActionResponse->targetId->size);
            return false;
        }

        pstruWjActionResponse->u8OCTtargetIdNum = pstruAsnActionResponse->targetId->size;

        if (NULL == pstruAsnActionResponse->targetId->buf)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        memcpy(pstruWjActionResponse->u8OCTtargetId, pstruAsnActionResponse->targetId->buf, pstruAsnActionResponse->targetId->size);
        pstruWjActionResponse->u8targetIdPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjActionResponse->u8targetIdPresent = WJV2_ABSENT;
    }
    pstruWjActionResponse->enumpaymentEntityId = pstruAsnActionResponse->paymentEntityId;

    if (NULL != pstruAsnActionResponse->responseParameter)
    {

        n32Ret = WJV2_TransInfo_DfDec((pstruAsnActionResponse->responseParameter), &(pstruWjActionResponse->struresponseParameter));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_TransInfo_DfDec is err");
            return false;
        }
        pstruWjActionResponse->u8responseParameterPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjActionResponse->u8responseParameterPresent = WJV2_ABSENT;
    }

    pstruWjActionResponse->enumret = pstruAsnActionResponse->ret;

    return true;
}
/**
* @brief     WJV2_AngularVelocity_DfEnc编码函数
* @details   协议栈AngularVelocity编解码中 统一AngularVelocity的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_AngularVelocity_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    AngularVelocity_t *pstruAsnAngularVelocity = (AngularVelocity_t *)pvoidAsnDf;
    WJV2_STRU_AngularVelocity *pstruWjAngularVelocity = (WJV2_STRU_AngularVelocity *)pvoidWjDf;

    if ((WJV2_MAX_PitchRate_SIZE < pstruWjAngularVelocity->n32pitchRate) ||
        (WJV2_MIN_PitchRate_SIZE > pstruWjAngularVelocity->n32pitchRate))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjAngularVelocity->n32pitchRate = %d",
                 pstruWjAngularVelocity->n32pitchRate);
        return false;
    }
    pstruAsnAngularVelocity->pitchRate = pstruWjAngularVelocity->n32pitchRate;

    if ((WJV2_MAX_RollRate_SIZE < pstruWjAngularVelocity->n32rollRate) ||
        (WJV2_MIN_RollRate_SIZE > pstruWjAngularVelocity->n32rollRate))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjAngularVelocity->n32rollRate = %d",
                 pstruWjAngularVelocity->n32rollRate);
        return false;
    }
    pstruAsnAngularVelocity->rollRate = pstruWjAngularVelocity->n32rollRate;

    if ((WJV2_MAX_YAWRATE_SIZE < pstruWjAngularVelocity->n32yawRate) ||
        (WJV2_MIN_YAWRATE_SIZE > pstruWjAngularVelocity->n32yawRate))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjAngularVelocity->n32yawRate = %d",
                 pstruWjAngularVelocity->n32yawRate);
        return false;
    }
    pstruAsnAngularVelocity->yawRate = pstruWjAngularVelocity->n32yawRate;

    return true;
}
/**
* @brief     WJV2_AngularVelocity_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_AngularVelocity_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    AngularVelocity_t *pstruAsnAngularVelocity = (AngularVelocity_t *)pvoidAsnDf;
    WJV2_STRU_AngularVelocity *pstruWjAngularVelocity = (WJV2_STRU_AngularVelocity *)pvoidWjDf;

    if ((WJV2_MAX_PitchRate_SIZE < pstruAsnAngularVelocity->pitchRate) ||
        (WJV2_MIN_PitchRate_SIZE > pstruAsnAngularVelocity->pitchRate))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth: pstruAsnAngularVelocity->pitchRate = %d",
                 pstruAsnAngularVelocity->pitchRate);
        return false;
    }
    pstruWjAngularVelocity->n32pitchRate = pstruAsnAngularVelocity->pitchRate;

    if ((WJV2_MAX_RollRate_SIZE < pstruAsnAngularVelocity->rollRate) ||
        (WJV2_MIN_RollRate_SIZE > pstruAsnAngularVelocity->rollRate))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnAngularVelocity->rollRate = %d",
                 pstruAsnAngularVelocity->rollRate);
        return false;
    }
    pstruWjAngularVelocity->n32rollRate = pstruAsnAngularVelocity->rollRate;

    if ((WJV2_MAX_YAWRATE_SIZE < pstruAsnAngularVelocity->yawRate) ||
        (WJV2_MIN_YAWRATE_SIZE > pstruAsnAngularVelocity->yawRate))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnAngularVelocity->yawRate = %d",
                 pstruAsnAngularVelocity->yawRate);
        return false;
    }
    pstruWjAngularVelocity->n32yawRate = pstruAsnAngularVelocity->yawRate;

    return true;
}
/**
* @brief     WJV2_AngularVelocityConfidence_DfEnc编码函数
* @details   协议栈AngularVelocityConfidence编解码中 统一AngularVelocityConfidence的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_AngularVelocityConfidence_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    AngularVelocityConfidence_t *pstruAsnAngularVelocityConfidence = (AngularVelocityConfidence_t *)pvoidAsnDf;
    WJV2_STRU_AngularVelocityConfidence *pstruWjAngularVelocityConfidence = (WJV2_STRU_AngularVelocityConfidence *)pvoidWjDf;

    pstruAsnAngularVelocityConfidence->pitchRate = pstruWjAngularVelocityConfidence->enumpitchRate;
    pstruAsnAngularVelocityConfidence->rollRate = pstruWjAngularVelocityConfidence->enumrollRate;
    pstruAsnAngularVelocityConfidence->yawRate = pstruWjAngularVelocityConfidence->enumyawRate;

    return true;
}
/**
* @brief     WJV2_AngularVelocityConfidence_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_AngularVelocityConfidence_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    AngularVelocityConfidence_t *pstruAsnAngularVelocityConfidence = (AngularVelocityConfidence_t *)pvoidAsnDf;
    WJV2_STRU_AngularVelocityConfidence *pstruWjAngularVelocityConfidence = (WJV2_STRU_AngularVelocityConfidence *)pvoidWjDf;

    pstruWjAngularVelocityConfidence->enumpitchRate = pstruAsnAngularVelocityConfidence->pitchRate;
    pstruWjAngularVelocityConfidence->enumrollRate = pstruAsnAngularVelocityConfidence->rollRate;
    pstruWjAngularVelocityConfidence->enumyawRate = pstruAsnAngularVelocityConfidence->yawRate;
    return true;
}
/**
* @brief     WJV2_ApplicationParameter_DfEnc编码函数
* @details   协议栈ApplicationParameter编解码中 统一ApplicationParameter的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ApplicationParameter_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    ApplicationParameter_t *pstruAsnApplicationParameter = (ApplicationParameter_t *)pvoidAsnDf;
    WJV2_STRU_ApplicationParameter *pstruWjApplicationParameter = (WJV2_STRU_ApplicationParameter *)pvoidWjDf;
    int32_t n32Ret = 0;
    pstruAsnApplicationParameter->pid = pstruWjApplicationParameter->enumpid;

    n32Ret = WJV2_PaymentInfo_DfEnc(&(pstruAsnApplicationParameter->paymentInfo), &(pstruWjApplicationParameter->strupaymentInfo));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PaymentInfo_DfEnc is err");
        return false;
    }

    return true;
}
/**
* @brief     WJV2_ApplicationParameter_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ApplicationParameter_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    ApplicationParameter_t *pstruAsnApplicationParameter = (ApplicationParameter_t *)pvoidAsnDf;
    WJV2_STRU_ApplicationParameter *pstruWjApplicationParameter = (WJV2_STRU_ApplicationParameter *)pvoidWjDf;
    int32_t n32Ret = 0;
    pstruWjApplicationParameter->enumpid = pstruAsnApplicationParameter->pid;

    n32Ret = WJV2_PaymentInfo_DfDec(&(pstruAsnApplicationParameter->paymentInfo), &(pstruWjApplicationParameter->strupaymentInfo));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PaymentInfo_DfDec is err");
        return false;
    }
    return true;
}
/**
* @brief     WJV2_Attitude_DfEnc编码函数
* @details   协议栈Attitude编解码中 统一Attitude的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_Attitude_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    Attitude_t *pstruAsnAttitude = (Attitude_t *)pvoidAsnDf;
    WJV2_STRU_Attitude *pstruWjAttitude = (WJV2_STRU_Attitude *)pvoidWjDf;

    if ((WJV2_MAX_Pitch_SIZE < pstruWjAttitude->n32pitch) ||
        (WJV2_MIN_Pitch_SIZE > pstruWjAttitude->n32pitch))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth: pstruWjAttitude->n32pitch = %d",
                 pstruWjAttitude->n32pitch);
        return false;
    }
    pstruAsnAttitude->pitch = pstruWjAttitude->n32pitch;

    if ((WJV2_MAX_Roll_SIZE < pstruWjAttitude->n32roll) ||
        (WJV2_MIN_Roll_SIZE > pstruWjAttitude->n32roll))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjAttitude->n32roll = %d",
                 pstruWjAttitude->n32roll);
        return false;
    }
    pstruAsnAttitude->roll = pstruWjAttitude->n32roll;

    if ((WJV2_MAX_Yaw_SIZE < pstruWjAttitude->n32yaw) ||
        (WJV2_MIN_Yaw_SIZE > pstruWjAttitude->n32yaw))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjAttitude->n32yaw = %d",
                 pstruWjAttitude->n32yaw);
        return false;
    }
    pstruAsnAttitude->yaw = pstruWjAttitude->n32yaw;

    return true;
}
/**
* @brief     WJV2_Attitude_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_Attitude_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    Attitude_t *pstruAsnAttitude = (Attitude_t *)pvoidAsnDf;
    WJV2_STRU_Attitude *pstruWjAttitude = (WJV2_STRU_Attitude *)pvoidWjDf;

    if ((WJV2_MAX_Pitch_SIZE < pstruAsnAttitude->pitch) ||
        (WJV2_MIN_Pitch_SIZE > pstruAsnAttitude->pitch))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth: pstruAsnAttitude->pitch = %d",
                 pstruAsnAttitude->pitch);
        return false;
    }
    pstruWjAttitude->n32pitch = pstruAsnAttitude->pitch;

    if ((WJV2_MAX_Roll_SIZE < pstruAsnAttitude->roll) ||
        (WJV2_MIN_Roll_SIZE > pstruAsnAttitude->roll))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnAttitude->roll = %d",
                 pstruAsnAttitude->roll);
        return false;
    }
    pstruWjAttitude->n32roll = pstruAsnAttitude->roll;

    if ((WJV2_MAX_Yaw_SIZE < pstruAsnAttitude->yaw) ||
        (WJV2_MIN_Yaw_SIZE > pstruAsnAttitude->yaw))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnAttitude->yaw = %d",
                 pstruAsnAttitude->yaw);
        return false;
    }
    pstruWjAttitude->n32yaw = pstruAsnAttitude->yaw;
    return true;
}
/**
* @brief     WJV2_AttitudeConfidence_DfEnc编码函数
* @details   协议栈AttitudeConfidence编解码中 统一AttitudeConfidence的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_AttitudeConfidence_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    AttitudeConfidence_t *pstruAsnAttitudeConfidence = (AttitudeConfidence_t *)pvoidAsnDf;
    WJV2_STRU_AttitudeConfidence *pstruWjAttitudeConfidence = (WJV2_STRU_AttitudeConfidence *)pvoidWjDf;
    pstruAsnAttitudeConfidence->pitchConfidence = pstruWjAttitudeConfidence->enumpitchConfidence;
    pstruAsnAttitudeConfidence->rollRateConfidence = pstruWjAttitudeConfidence->enumrollRateConfidence;
    pstruAsnAttitudeConfidence->yawRate = pstruWjAttitudeConfidence->enumyawRate;

    return true;
}
/**
* @brief     WJV2_AttitudeConfidence_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_AttitudeConfidence_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    AttitudeConfidence_t *pstruAsnAttitudeConfidence = (AttitudeConfidence_t *)pvoidAsnDf;
    WJV2_STRU_AttitudeConfidence *pstruWjAttitudeConfidence = (WJV2_STRU_AttitudeConfidence *)pvoidWjDf;
    pstruWjAttitudeConfidence->enumpitchConfidence = pstruAsnAttitudeConfidence->pitchConfidence;
    pstruWjAttitudeConfidence->enumrollRateConfidence = pstruAsnAttitudeConfidence->rollRateConfidence;
    pstruWjAttitudeConfidence->enumyawRate = pstruAsnAttitudeConfidence->yawRate;
    return true;
}
/**
* @brief     WJV2_ChannelRq_DfEnc编码函数
* @details   协议栈ChannelRq编解码中 统一ChannelRq的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ChannelRq_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    ChannelRq_t *pstruAsnChannelRq = (ChannelRq_t *)pvoidAsnDf;
    WJV2_STRU_ChannelRq *pstruWjChannelRq = (WJV2_STRU_ChannelRq *)pvoidWjDf;
    int32_t n32Ret = 0;
    pstruAsnChannelRq->channelid = pstruWjChannelRq->enumchannelid;
    n32Ret = WJV2_ApduList_DeEnc(&pstruAsnChannelRq->apdu,
                                 &(pstruWjChannelRq->struapdu));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_ApduList_DeEnc is err");
        return false;
    }

    return true;
}
/**
* @brief     WJV2_ChannelRq_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ChannelRq_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    ChannelRq_t *pstruAsnChannelRq = (ChannelRq_t *)pvoidAsnDf;
    WJV2_STRU_ChannelRq *pstruWjChannelRq = (WJV2_STRU_ChannelRq *)pvoidWjDf;
    int32_t n32Ret = 0;
    pstruWjChannelRq->enumchannelid = pstruAsnChannelRq->channelid;
    n32Ret = WJV2_ApduList_DeDec(&pstruAsnChannelRq->apdu,
                                 &(pstruWjChannelRq->struapdu));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_ApduList_DeDec is err");
        return false;
    }

    return true;
}
/**
* @brief     WJV2_ChannelRs_DfEnc编码函数
* @details   协议栈ChannelRs编解码中 统一ChannelRs的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ChannelRs_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    ChannelRs_t *pstruAsnChannelRs = (ChannelRs_t *)pvoidAsnDf;
    WJV2_STRU_ChannelRs *pstruWjChannelRs = (WJV2_STRU_ChannelRs *)pvoidWjDf;
    int32_t n32Ret = 0;
    pstruAsnChannelRs->channelid = pstruWjChannelRs->enumchannelid;
    n32Ret = WJV2_ApduList_DeEnc(&pstruAsnChannelRs->apdu,
                                 &(pstruWjChannelRs->struapdu));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_ApduList_DeEnc is err");
        return false;
    }

    return true;
}
/**
* @brief     WJV2_ChannelRs_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ChannelRs_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    ChannelRs_t *pstruAsnChannelRs = (ChannelRs_t *)pvoidAsnDf;
    WJV2_STRU_ChannelRs *pstruWjChannelRs = (WJV2_STRU_ChannelRs *)pvoidWjDf;
    int32_t n32Ret = 0;
    pstruWjChannelRs->enumchannelid = pstruAsnChannelRs->channelid;
    n32Ret = WJV2_ApduList_DeDec(&pstruAsnChannelRs->apdu,
                                 &(pstruWjChannelRs->struapdu));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_ApduList_DeDec is err");
        return false;
    }
    return true;
}
/**
* @brief     WJV2_AuxiliarySign_DfEnc编码函数
* @details   协议栈AuxiliarySign编解码中 统一AuxiliarySign的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_AuxiliarySign_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    AuxiliarySign_t *pstruAsnAuxiliarySign = (AuxiliarySign_t *)pvoidAsnDf;
    WJV2_STRU_AuxiliarySign *pstruWjAuxiliarySign = (WJV2_STRU_AuxiliarySign *)pvoidWjDf;
    int32_t n32Ret = 0;
    if (WJV2_PRESENT == pstruWjAuxiliarySign->u8signWithVehicleTypePresent)
    {
        pstruAsnAuxiliarySign->signWithVehicleType = CALLOC(1, sizeof(AuxiliarySignVehicleType_t));
        if (NULL == pstruAsnAuxiliarySign->signWithVehicleType)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_AuxiliarySignVehicleType_DeEnc(pstruAsnAuxiliarySign->signWithVehicleType,
                                                     &(pstruWjAuxiliarySign->bitsignWithVehicleType));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AuxiliarySignVehicleType_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnAuxiliarySign->signWithVehicleType = NULL;
    }

    if (WJV2_PRESENT == pstruWjAuxiliarySign->u8signDirectionPresent)
    {
        pstruAsnAuxiliarySign->signDirection = CALLOC(1, sizeof(AuxiliarySignDirection_t));
        if (NULL == pstruAsnAuxiliarySign->signDirection)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }

        *pstruAsnAuxiliarySign->signDirection = pstruWjAuxiliarySign->enumsignDirection;
    }
    else
    {
        pstruAsnAuxiliarySign->signDirection = NULL;
    }

    return true;
}
/**
* @brief     WJV2_AuxiliarySign_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_AuxiliarySign_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    AuxiliarySign_t *pstruAsnAuxiliarySign = (AuxiliarySign_t *)pvoidAsnDf;
    WJV2_STRU_AuxiliarySign *pstruWjAuxiliarySign = (WJV2_STRU_AuxiliarySign *)pvoidWjDf;
    int32_t n32Ret = 0;
    if (NULL != pstruAsnAuxiliarySign->signWithVehicleType)
    {

        n32Ret = WJV2_AuxiliarySignVehicleType_DeDec(pstruAsnAuxiliarySign->signWithVehicleType,
                                                     &(pstruWjAuxiliarySign->bitsignWithVehicleType));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AuxiliarySignVehicleType_DeDec is err");
            return false;
        }
        pstruWjAuxiliarySign->u8signWithVehicleTypePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjAuxiliarySign->u8signWithVehicleTypePresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnAuxiliarySign->signDirection)
    {
        pstruWjAuxiliarySign->enumsignDirection = *pstruAsnAuxiliarySign->signDirection;
        pstruWjAuxiliarySign->u8signDirectionPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjAuxiliarySign->u8signDirectionPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_ConnectingLaneEx_DfEnc编码函数
* @details   协议栈ConnectingLaneEx编解码中 统一ConnectingLaneEx的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ConnectingLaneEx_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    ConnectingLaneEx_t *pstruAsnConnectingLaneEx = (ConnectingLaneEx_t *)pvoidAsnDf;
    WJV2_STRU_ConnectingLaneEx *pstruWjConnectingLaneEx = (WJV2_STRU_ConnectingLaneEx *)pvoidWjDf;
    int32_t n32Ret = 0;

    if ((WJV2_MAX_SectionId_SIZE < pstruWjConnectingLaneEx->n32target_section) ||
        (WJV2_MIN_SectionId_SIZE > pstruWjConnectingLaneEx->n32target_section))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjConnectingLaneEx->n32target_section = %d",
                 pstruWjConnectingLaneEx->n32target_section);
        return false;
    }

    pstruAsnConnectingLaneEx->target_section = pstruWjConnectingLaneEx->n32target_section;

    if ((WJV2_MAX_LaneRefID_SIZE < pstruWjConnectingLaneEx->n32target_lane) ||
        (WJV2_MIN_LaneRefID_SIZE > pstruWjConnectingLaneEx->n32target_lane))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjConnectingLaneEx->n32target_lane = %d",
                 pstruWjConnectingLaneEx->n32target_lane);
        return false;
    }

    pstruAsnConnectingLaneEx->target_lane = pstruWjConnectingLaneEx->n32target_lane;

    if (WJV2_PRESENT == pstruWjConnectingLaneEx->u8connectingLaneWidthPresent)
    {
        if ((WJV2_MAX_LANEWIDTH_SIZE < pstruWjConnectingLaneEx->n32connectingLaneWidth) ||
            (WJV2_MIN_LANEWIDTH_SIZE > pstruWjConnectingLaneEx->n32connectingLaneWidth))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjConnectingLaneEx->n32connectingLaneWidth = %d",
                     pstruWjConnectingLaneEx->n32connectingLaneWidth);
            return false;
        }
        pstruAsnConnectingLaneEx->connectingLaneWidth = CALLOC(1, sizeof(LaneWidth_t));
        if (NULL == pstruAsnConnectingLaneEx->connectingLaneWidth)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnConnectingLaneEx->connectingLaneWidth = pstruWjConnectingLaneEx->n32connectingLaneWidth;
    }
    else
    {
        pstruAsnConnectingLaneEx->connectingLaneWidth = NULL;
    }

    if (WJV2_PRESENT == pstruWjConnectingLaneEx->u8connectingLanePointsPresent)
    {
        pstruAsnConnectingLaneEx->connectingLanePoints = CALLOC(1, sizeof(PointList_t));
        if (NULL == pstruAsnConnectingLaneEx->connectingLanePoints)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }

        n32Ret = WJV2_PointList_DfEnc(pstruAsnConnectingLaneEx->connectingLanePoints, &(pstruWjConnectingLaneEx->struconnectingLanePoints));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PointList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnConnectingLaneEx->connectingLanePoints = NULL;
    }

    if (WJV2_PRESENT == pstruWjConnectingLaneEx->u8isolatedConnectingLanePresent)
    {
        pstruAsnConnectingLaneEx->isolatedConnectingLane = CALLOC(1, sizeof(BOOLEAN_t));
        if (NULL == pstruAsnConnectingLaneEx->isolatedConnectingLane)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnConnectingLaneEx->isolatedConnectingLane = pstruWjConnectingLaneEx->n32isolatedConnectingLane;
    }
    else
    {
        pstruAsnConnectingLaneEx->isolatedConnectingLane = NULL;
    }

    return true;
}
/**
* @brief     WJV2_ConnectingLaneEx_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ConnectingLaneEx_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    ConnectingLaneEx_t *pstruAsnConnectingLaneEx = (ConnectingLaneEx_t *)pvoidAsnDf;
    WJV2_STRU_ConnectingLaneEx *pstruWjConnectingLaneEx = (WJV2_STRU_ConnectingLaneEx *)pvoidWjDf;
    int32_t n32Ret = 0;

    if ((WJV2_MAX_SectionId_SIZE < pstruAsnConnectingLaneEx->target_section) ||
        (WJV2_MIN_SectionId_SIZE > pstruAsnConnectingLaneEx->target_section))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnConnectingLaneEx->target_section = %d",
                 pstruAsnConnectingLaneEx->target_section);
        return false;
    }

    pstruWjConnectingLaneEx->n32target_section = pstruAsnConnectingLaneEx->target_section;

    if ((WJV2_MAX_LaneRefID_SIZE < pstruAsnConnectingLaneEx->target_lane) ||
        (WJV2_MIN_LaneRefID_SIZE > pstruAsnConnectingLaneEx->target_lane))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnConnectingLaneEx->target_lane = %d",
                 pstruAsnConnectingLaneEx->target_lane);
        return false;
    }

    pstruWjConnectingLaneEx->n32target_lane = pstruAsnConnectingLaneEx->target_lane;

    if (NULL != pstruAsnConnectingLaneEx->connectingLaneWidth)
    {
        if ((WJV2_MAX_LANEWIDTH_SIZE < *pstruAsnConnectingLaneEx->connectingLaneWidth) ||
            (WJV2_MIN_LANEWIDTH_SIZE > *pstruAsnConnectingLaneEx->connectingLaneWidth))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*pstruAsnConnectingLaneEx->connectingLaneWidth = %d",
                     *pstruAsnConnectingLaneEx->connectingLaneWidth);
            return false;
        }

        pstruWjConnectingLaneEx->n32connectingLaneWidth = *pstruAsnConnectingLaneEx->connectingLaneWidth;
        pstruWjConnectingLaneEx->u8connectingLaneWidthPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjConnectingLaneEx->u8connectingLaneWidthPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnConnectingLaneEx->connectingLanePoints)
    {

        n32Ret = WJV2_PointList_DfDec(pstruAsnConnectingLaneEx->connectingLanePoints, &(pstruWjConnectingLaneEx->struconnectingLanePoints));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PointList_DfDec is err");
            return false;
        }
        pstruWjConnectingLaneEx->u8connectingLanePointsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjConnectingLaneEx->u8connectingLanePointsPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnConnectingLaneEx->isolatedConnectingLane)
    {

        pstruWjConnectingLaneEx->n32isolatedConnectingLane = *pstruAsnConnectingLaneEx->isolatedConnectingLane;
        pstruWjConnectingLaneEx->u8isolatedConnectingLanePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjConnectingLaneEx->u8isolatedConnectingLanePresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_ConnectionEx_DfEnc编码函数
* @details   协议栈ConnectionEx编解码中 统一ConnectionEx的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ConnectionEx_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    ConnectionEx_t *pstruAsnConnectionEx = (ConnectionEx_t *)pvoidAsnDf;
    WJV2_STRU_ConnectionEx *pstruWjConnectionEx = (WJV2_STRU_ConnectionEx *)pvoidWjDf;
    int32_t n32Ret = 0;

    n32Ret = WJV2_NodeReferenceID_DfEnc(&(pstruAsnConnectionEx->remoteIntersection), &(pstruWjConnectionEx->struremoteIntersection));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfEnc is err");
        return false;
    }
    if (WJV2_PRESENT == pstruWjConnectionEx->u8swlPresent)
    {
        pstruAsnConnectionEx->swl = CALLOC(1, sizeof(SignalWaitingLane_t));
        if (NULL == pstruAsnConnectionEx->swl)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_SignalWaitingLane_DfEnc(pstruAsnConnectionEx->swl, &(pstruWjConnectionEx->struswl));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_SignalWaitingLane_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnConnectionEx->swl = NULL;
    }

    if (WJV2_PRESENT == pstruWjConnectionEx->u8connectingLanePresent)
    {
        pstruAsnConnectionEx->connectingLane = CALLOC(1, sizeof(struct ConnectingLane));
        if (NULL == pstruAsnConnectionEx->connectingLane)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        n32Ret = WJV2_ConnectingLane_DfEnc(pstruAsnConnectionEx->connectingLane, &(pstruWjConnectionEx->struconnectingLane));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ConnectingLane_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnConnectionEx->connectingLane = NULL;
    }
    if (WJV2_PRESENT == pstruWjConnectionEx->u8phaseIdPresent)
    {
        pstruAsnConnectionEx->phaseId = CALLOC(1, sizeof(PhaseID_t));
        if (NULL == pstruAsnConnectionEx->phaseId)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        if ((WJV2_MAX_PHASEID_SIZE < pstruWjConnectionEx->n32phaseId) ||
            (WJV2_MIN_PHASEID_SIZE > pstruWjConnectionEx->n32phaseId))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjConnectionEx->n32phaseId = %d",
                     pstruWjConnectionEx->n32phaseId);
            return false;
        }
        *(pstruAsnConnectionEx->phaseId) = pstruWjConnectionEx->n32phaseId;
    }
    else
    {
        pstruAsnConnectionEx->phaseId = NULL;
    }

    if (WJV2_PRESENT == pstruWjConnectionEx->u8turn_directionPresent)
    {
        pstruAsnConnectionEx->turn_direction = CALLOC(1, sizeof(Maneuver_t));
        if (NULL == pstruAsnConnectionEx->turn_direction)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }

        *(pstruAsnConnectionEx->turn_direction) = pstruWjConnectionEx->enumturn_direction;
    }
    else
    {
        pstruAsnConnectionEx->turn_direction = NULL;
    }
    return true;
}
/**
* @brief     WJV2_ConnectionEx_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ConnectionEx_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    ConnectionEx_t *pstruAsnConnectionEx = (ConnectionEx_t *)pvoidAsnDf;
    WJV2_STRU_ConnectionEx *pstruWjConnectionEx = (WJV2_STRU_ConnectionEx *)pvoidWjDf;
    int32_t n32Ret = 0;

    n32Ret = WJV2_NodeReferenceID_DfDec(&(pstruAsnConnectionEx->remoteIntersection), &(pstruWjConnectionEx->struremoteIntersection));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfDec is err");
        return false;
    }
    if (NULL != pstruAsnConnectionEx->swl)
    {
        n32Ret = WJV2_SignalWaitingLane_DfDec(pstruAsnConnectionEx->swl, &(pstruWjConnectionEx->struswl));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_SignalWaitingLane_DfDec is err");
            return false;
        }
        pstruWjConnectionEx->u8swlPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjConnectionEx->u8swlPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnConnectionEx->connectingLane)
    {

        n32Ret = WJV2_ConnectingLane_DfDec(pstruAsnConnectionEx->connectingLane, &(pstruWjConnectionEx->struconnectingLane));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ConnectingLane_DfDec is err");
            return false;
        }
        pstruWjConnectionEx->u8connectingLanePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjConnectionEx->u8connectingLanePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnConnectionEx->phaseId)
    {

        if ((WJV2_MAX_PHASEID_SIZE < *(pstruAsnConnectionEx->phaseId)) ||
            (WJV2_MIN_PHASEID_SIZE > *(pstruAsnConnectionEx->phaseId)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnConnectionEx->phaseId) = %d",
                     *(pstruAsnConnectionEx->phaseId));
            return false;
        }
        pstruWjConnectionEx->n32phaseId = *(pstruAsnConnectionEx->phaseId);
        pstruWjConnectionEx->u8phaseIdPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjConnectionEx->u8phaseIdPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnConnectionEx->turn_direction)
    {
        pstruWjConnectionEx->enumturn_direction = *(pstruAsnConnectionEx->turn_direction);
        pstruWjConnectionEx->u8phaseIdPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjConnectionEx->u8phaseIdPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_ConnectsToExList_DfEnc编码函数
* @details   协议栈ConnectsToExList编解码中 统一ConnectsToExList的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ConnectsToExList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    WJV2_STRU_ConnectsToExList *pstruWjConnectsToExList = (WJV2_STRU_ConnectsToExList *)pvoidWjDf;
    ConnectsToExList_t *pstruAsnConnectsToExList = (ConnectsToExList_t *)pvoidAsnDf;
    ConnectionEx_t *pstruConnectionEx_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_ConnectsToEx_LEN < pstruWjConnectsToExList->u8ConnectsToExNum) ||
        (WJV2_MIN_LIST_ConnectsToEx_LEN > pstruWjConnectsToExList->u8ConnectsToExNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjConnectsToExList->u8ConnectsToExNum = %d",
                 pstruWjConnectsToExList->u8ConnectsToExNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjConnectsToExList->u8ConnectsToExNum; u32i++)
    {
        pstruConnectionEx_node = CALLOC(1, sizeof(ConnectionEx_t));
        if (NULL == pstruConnectionEx_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ConnectionEx_DfEnc(pstruConnectionEx_node, &(pstruWjConnectsToExList->struConnectsToEx[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Connection_DfEnc is err");
            FREEMEM(pstruConnectionEx_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnConnectsToExList->list), pstruConnectionEx_node);
    }

    return true;
}
/**
* @brief     WJV2_ConnectsToExList_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ConnectsToExList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    WJV2_STRU_ConnectsToExList *pstruWjConnectsToExList = (WJV2_STRU_ConnectsToExList *)pvoidWjDf;
    ConnectsToExList_t *pstruAsnConnectsToExList = (ConnectsToExList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_ConnectsToEx_LEN < pstruAsnConnectsToExList->list.count) ||
        (WJV2_MIN_LIST_ConnectsToEx_LEN > pstruAsnConnectsToExList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnConnectsToExList->list.count = %d",
                 pstruAsnConnectsToExList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnConnectsToExList->list.count; u32i++)
    {
        n32Ret = WJV2_ConnectionEx_DfDec(pstruAsnConnectsToExList->list.array[u32i],
                                         &(pstruWjConnectsToExList->struConnectsToEx[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ConnectionEx_DfDec is err");
            return false;
        }
    }
    pstruWjConnectsToExList->u8ConnectsToExNum = (uint8_t)u32i;

    return true;
}

/**
* @brief     WJV2_ObjectSizeConfidence_DfEnc编码函数
* @details   协议栈Polygon编解码中 统一Polygon的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ObjectSizeConfidence_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    ObjectSizeConfidence_t *pstruAsnObjectSizeConfidence = (ObjectSizeConfidence_t *)pvoidAsnDf;
    WJV2_STRU_ObjectSizeConfidence *pstruWjObjectSizeConfidence = (WJV2_STRU_ObjectSizeConfidence *)pvoidWjDf;

    pstruAsnObjectSizeConfidence->widthConf = pstruWjObjectSizeConfidence->enumwidthConf;
    pstruAsnObjectSizeConfidence->lengthConf = pstruWjObjectSizeConfidence->enumlengthConf;
    if (WJV2_PRESENT == pstruWjObjectSizeConfidence->u8heightConfPresent)
    {

        pstruAsnObjectSizeConfidence->heightConf = CALLOC(1, sizeof(SizeValueConfidence_t));
        if (NULL == pstruAsnObjectSizeConfidence->heightConf)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnObjectSizeConfidence->heightConf = pstruWjObjectSizeConfidence->enumheightConf;
    }
    else
    {
        pstruAsnObjectSizeConfidence->heightConf = NULL;
    }

    return true;
}
/**
* @brief     WJV2_ObjectSizeConfidence_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ObjectSizeConfidence_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    ObjectSizeConfidence_t *pstruAsnObjectSizeConfidence = (ObjectSizeConfidence_t *)pvoidAsnDf;
    WJV2_STRU_ObjectSizeConfidence *pstruWjObjectSizeConfidence = (WJV2_STRU_ObjectSizeConfidence *)pvoidWjDf;

    pstruWjObjectSizeConfidence->enumwidthConf = pstruAsnObjectSizeConfidence->widthConf;
    pstruWjObjectSizeConfidence->enumlengthConf = pstruAsnObjectSizeConfidence->lengthConf;
    if (WJV2_PRESENT == pstruWjObjectSizeConfidence->u8heightConfPresent)
    {
        pstruWjObjectSizeConfidence->enumheightConf = *pstruAsnObjectSizeConfidence->heightConf;
        pstruWjObjectSizeConfidence->u8heightConfPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjObjectSizeConfidence->u8heightConfPresent = WJV2_ABSENT;
    }

    return true;
}

/**
* @brief     WJV2_DetectedObstacleData_DfEnc编码函数
* @details   协议栈DetectedObstacleData编解码中 统一DetectedObstacleData的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_DetectedObstacleData_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    DetectedObstacleData_t *pstruAsnDetectedObstacleData = (DetectedObstacleData_t *)pvoidAsnDf;
    WJV2_STRU_DetectedObstacleData *pstruWjDetectedObstacleData = (WJV2_STRU_DetectedObstacleData *)pvoidWjDf;
    int32_t n32Ret = 0;

    pstruAsnDetectedObstacleData->obsType = pstruWjDetectedObstacleData->enumobsType;

    if (WJV2_PRESENT == pstruWjDetectedObstacleData->u8objTypeConfidencePresent)
    {
        if ((WJV2_MAX_CONFIDENCE_SIZE < pstruWjDetectedObstacleData->n32objTypeConfidence) ||
            (WJV2_MIN_CONFIDENCE_SIZE > pstruWjDetectedObstacleData->n32objTypeConfidence))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjDetectedObstacleData->n32objTypeConfidence = %d",
                     pstruWjDetectedObstacleData->n32objTypeConfidence);
            return false;
        }
        pstruAsnDetectedObstacleData->objTypeConfidence = CALLOC(1, sizeof(Confidence_t));
        if (NULL == pstruAsnDetectedObstacleData->objTypeConfidence)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnDetectedObstacleData->objTypeConfidence = pstruWjDetectedObstacleData->n32objTypeConfidence;
    }
    else
    {
        pstruAsnDetectedObstacleData->objTypeConfidence = NULL;
    }
    if ((WJV2_MAX_obsId_SIZE < pstruWjDetectedObstacleData->n32obsId) ||
        (WJV2_MIN_obsId_SIZE > pstruWjDetectedObstacleData->n32obsId))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth: pstruWjDetectedObstacleData->n32obsId = %d",
                 pstruWjDetectedObstacleData->n32obsId);
        return false;
    }
    pstruAsnDetectedObstacleData->obsId = pstruWjDetectedObstacleData->n32obsId;
    pstruAsnDetectedObstacleData->source = pstruWjDetectedObstacleData->enumsource;

    if ((WJV2_MAX_DSECOND_SIZE < pstruWjDetectedObstacleData->n32secMark) ||
        (WJV2_MIN_DSECOND_SIZE > pstruWjDetectedObstacleData->n32secMark))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjDetectedObstacleData->n32secMark = %d",
                 pstruWjDetectedObstacleData->n32secMark);
        return false;
    }
    pstruAsnDetectedObstacleData->secMark = pstruWjDetectedObstacleData->n32secMark;

    n32Ret = WJV2_PositionOffsetLLV_DfEnc(&(pstruAsnDetectedObstacleData->pos), &(pstruWjDetectedObstacleData->strupos));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PositionOffsetLLV_DfEnc is err");
        return false;
    }

    n32Ret = WJV2_PositionConfidenceSet_DfEnc(&(pstruAsnDetectedObstacleData->posConfidence), &(pstruWjDetectedObstacleData->struposConfidence));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PositionConfidenceSet_DfEnc is err");
        return false;
    }

    if ((WJV2_MAX_SPEED_SIZE < pstruWjDetectedObstacleData->n32speed) ||
        (WJV2_MIN_SPEED_SIZE > pstruWjDetectedObstacleData->n32speed))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjDetectedObstacleData->n32speed = %d",
                 pstruWjDetectedObstacleData->n32speed);
        return false;
    }
    pstruAsnDetectedObstacleData->speed = pstruWjDetectedObstacleData->n32speed;

    if (WJV2_PRESENT == pstruWjDetectedObstacleData->u8speedCfdPresent)
    {
        pstruAsnDetectedObstacleData->speedCfd = CALLOC(1, sizeof(SpeedConfidence_t));
        if (NULL == pstruAsnDetectedObstacleData->speedCfd)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnDetectedObstacleData->speedCfd = pstruWjDetectedObstacleData->enumspeedCfd;
    }
    else
    {
        pstruAsnDetectedObstacleData->speedCfd = NULL;
    }

    if ((WJV2_MAX_HEADING_SIZE < pstruWjDetectedObstacleData->n32heading) ||
        (WJV2_MIN_HEADING_SIZE > pstruWjDetectedObstacleData->n32heading))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjDetectedObstacleData->n32heading = %d",
                 pstruWjDetectedObstacleData->n32heading);
        return false;
    }
    pstruAsnDetectedObstacleData->heading = pstruWjDetectedObstacleData->n32heading;

    if (WJV2_PRESENT == pstruWjDetectedObstacleData->u8headingCfdPresent)
    {
        pstruAsnDetectedObstacleData->headingCfd = CALLOC(1, sizeof(HeadingConfidence_t));
        if (NULL == pstruAsnDetectedObstacleData->headingCfd)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnDetectedObstacleData->headingCfd = pstruWjDetectedObstacleData->enumheadingCfd;
    }
    else
    {
        pstruAsnDetectedObstacleData->headingCfd = NULL;
    }

    if (WJV2_PRESENT == pstruWjDetectedObstacleData->u8verSpeedPresent)
    {
        if ((WJV2_MAX_SPEED_SIZE < pstruWjDetectedObstacleData->n32verSpeed) ||
            (WJV2_MIN_SPEED_SIZE > pstruWjDetectedObstacleData->n32verSpeed))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjDetectedObstacleData->n32verSpeed = %d",
                     pstruWjDetectedObstacleData->n32verSpeed);
            return false;
        }
        pstruAsnDetectedObstacleData->verSpeed = CALLOC(1, sizeof(Speed_t));
        if (NULL == pstruAsnDetectedObstacleData->verSpeed)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnDetectedObstacleData->verSpeed = pstruWjDetectedObstacleData->n32verSpeed;
    }
    else
    {
        pstruAsnDetectedObstacleData->verSpeed = NULL;
    }

    if (WJV2_PRESENT == pstruWjDetectedObstacleData->u8verSpeedConfidencePresent)
    {
        pstruAsnDetectedObstacleData->verSpeedConfidence = CALLOC(1, sizeof(SpeedConfidence_t));
        if (NULL == pstruAsnDetectedObstacleData->verSpeedConfidence)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnDetectedObstacleData->verSpeedConfidence = pstruWjDetectedObstacleData->enumverSpeedConfidence;
    }
    else
    {
        pstruAsnDetectedObstacleData->verSpeedConfidence = NULL;
    }

    if (WJV2_PRESENT == pstruWjDetectedObstacleData->u8accelSetPresent)
    {
        pstruAsnDetectedObstacleData->accelSet = CALLOC(1, sizeof(AccelerationSet4Way_t));
        if (NULL == pstruAsnDetectedObstacleData->accelSet)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }

        n32Ret = WJV2_AccelerationSet4Way_DfEnc(pstruAsnDetectedObstacleData->accelSet, &(pstruWjDetectedObstacleData->struaccelSet));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AccelerationSet4Way_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnDetectedObstacleData->accelSet = NULL;
    }

    n32Ret = WJV2_ObjectSize_DfEnc(&pstruAsnDetectedObstacleData->size, &(pstruWjDetectedObstacleData->strusize));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_ObjectSize_DfEnc is err");
        return false;
    }

    if (WJV2_PRESENT == pstruWjDetectedObstacleData->u8pobjSizeConfidencePresent)
    {
        pstruAsnDetectedObstacleData->objSizeConfidence = CALLOC(1, sizeof(struct ObjectSizeConfidence));
        if (NULL == pstruAsnDetectedObstacleData->objSizeConfidence)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }

        n32Ret = WJV2_ObjectSizeConfidence_DfEnc(pstruAsnDetectedObstacleData->objSizeConfidence, &(pstruWjDetectedObstacleData->struobjSizeConfidence));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ObjectSizeConfidence_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnDetectedObstacleData->objSizeConfidence = NULL;
    }

    if (WJV2_PRESENT == pstruWjDetectedObstacleData->u8trackingPresent)
    {
        if ((WJV2_MAX_tracking_SIZE < pstruWjDetectedObstacleData->n32tracking) ||
            (WJV2_MIN_tracking_SIZE > pstruWjDetectedObstacleData->n32tracking))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth: pstruWjDetectedObstacleData->n32tracking = %d",
                     pstruWjDetectedObstacleData->n32tracking);
            return false;
        }
        pstruAsnDetectedObstacleData->tracking = CALLOC(1, sizeof(long));
        if (NULL == pstruAsnDetectedObstacleData->tracking)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnDetectedObstacleData->tracking = pstruWjDetectedObstacleData->n32tracking;
    }
    else
    {
        pstruAsnDetectedObstacleData->tracking = NULL;
    }

    if (WJV2_PRESENT == pstruWjDetectedObstacleData->u8polygonPresent)
    {
        pstruAsnDetectedObstacleData->polygon = CALLOC(1, sizeof(struct Polygon));
        if (NULL == pstruAsnDetectedObstacleData->polygon)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_Polygon_DfEnc(pstruAsnDetectedObstacleData->polygon, &(pstruWjDetectedObstacleData->strupolygon));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Polygon_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnDetectedObstacleData->polygon = NULL;
    }

    return true;
}
/**
* @brief     WJV2_DetectedObstacleData_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_DetectedObstacleData_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    DetectedObstacleData_t *pstruAsnDetectedObstacleData = (DetectedObstacleData_t *)pvoidAsnDf;
    WJV2_STRU_DetectedObstacleData *pstruWjDetectedObstacleData = (WJV2_STRU_DetectedObstacleData *)pvoidWjDf;
    int32_t n32Ret = 0;

    pstruWjDetectedObstacleData->enumobsType = pstruAsnDetectedObstacleData->obsType;

    if (NULL != pstruAsnDetectedObstacleData->objTypeConfidence)
    {
        if ((WJV2_MAX_CONFIDENCE_SIZE < *pstruAsnDetectedObstacleData->objTypeConfidence) ||
            (WJV2_MIN_CONFIDENCE_SIZE > *pstruAsnDetectedObstacleData->objTypeConfidence))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth: *pstruAsnDetectedObstacleData->objTypeConfidence = %d",
                     *pstruAsnDetectedObstacleData->objTypeConfidence);
            return false;
        }

        pstruWjDetectedObstacleData->n32objTypeConfidence = *pstruAsnDetectedObstacleData->objTypeConfidence;
        pstruWjDetectedObstacleData->u8objTypeConfidencePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDetectedObstacleData->u8objTypeConfidencePresent = WJV2_ABSENT;
    }
    if ((WJV2_MAX_obsId_SIZE < pstruAsnDetectedObstacleData->obsId) ||
        (WJV2_MIN_obsId_SIZE > pstruAsnDetectedObstacleData->obsId))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth: pstruAsnDetectedObstacleData->obsId = %d",
                 pstruAsnDetectedObstacleData->obsId);
        return false;
    }
    pstruWjDetectedObstacleData->n32obsId = pstruAsnDetectedObstacleData->obsId;
    pstruWjDetectedObstacleData->enumsource = pstruAsnDetectedObstacleData->source;
    if ((WJV2_MAX_DSECOND_SIZE < pstruAsnDetectedObstacleData->secMark) ||
        (WJV2_MIN_DSECOND_SIZE > pstruAsnDetectedObstacleData->secMark))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnDetectedObstacleData->secMark = %d",
                 pstruAsnDetectedObstacleData->secMark);
        return false;
    }
    pstruWjDetectedObstacleData->n32secMark = pstruAsnDetectedObstacleData->secMark;

    n32Ret = WJV2_PositionOffsetLLV_DfDec(&(pstruAsnDetectedObstacleData->pos), &(pstruWjDetectedObstacleData->strupos));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PositionOffsetLLV_DfDec is err");
        return false;
    }

    n32Ret = WJV2_PositionConfidenceSet_DfDec(&(pstruAsnDetectedObstacleData->posConfidence), &(pstruWjDetectedObstacleData->struposConfidence));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PositionConfidenceSet_DfDec is err");
        return false;
    }

    if ((WJV2_MAX_SPEED_SIZE < pstruAsnDetectedObstacleData->speed) ||
        (WJV2_MIN_SPEED_SIZE > pstruAsnDetectedObstacleData->speed))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnDetectedObstacleData->speed = %d",
                 pstruAsnDetectedObstacleData->speed);
        return false;
    }
    pstruWjDetectedObstacleData->n32speed = pstruAsnDetectedObstacleData->speed;

    if (NULL != pstruAsnDetectedObstacleData->speedCfd)
    {

        pstruWjDetectedObstacleData->enumspeedCfd = *pstruAsnDetectedObstacleData->speedCfd;
        pstruWjDetectedObstacleData->u8speedCfdPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDetectedObstacleData->u8speedCfdPresent = WJV2_ABSENT;
    }

    if ((WJV2_MAX_HEADING_SIZE < pstruAsnDetectedObstacleData->heading) ||
        (WJV2_MIN_HEADING_SIZE > pstruAsnDetectedObstacleData->heading))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnDetectedObstacleData->heading = %d",
                 pstruAsnDetectedObstacleData->heading);
        return false;
    }
    pstruWjDetectedObstacleData->n32heading = pstruAsnDetectedObstacleData->heading;

    if (NULL != pstruAsnDetectedObstacleData->headingCfd)
    {
        pstruWjDetectedObstacleData->enumheadingCfd = *pstruAsnDetectedObstacleData->headingCfd;
        pstruWjDetectedObstacleData->u8headingCfdPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDetectedObstacleData->u8headingCfdPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDetectedObstacleData->verSpeed)
    {
        if ((WJV2_MAX_SPEED_SIZE < *pstruAsnDetectedObstacleData->verSpeed) ||
            (WJV2_MIN_SPEED_SIZE > *pstruAsnDetectedObstacleData->verSpeed))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth: *pstruAsnDetectedObstacleData->verSpeed = %d",
                     *pstruAsnDetectedObstacleData->verSpeed);
            return false;
        }

        pstruWjDetectedObstacleData->n32verSpeed = *pstruAsnDetectedObstacleData->verSpeed;
        pstruWjDetectedObstacleData->u8verSpeedPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDetectedObstacleData->u8verSpeedPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDetectedObstacleData->verSpeedConfidence)
    {

        pstruWjDetectedObstacleData->enumverSpeedConfidence = *pstruAsnDetectedObstacleData->verSpeedConfidence;
        pstruWjDetectedObstacleData->u8verSpeedConfidencePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDetectedObstacleData->u8verSpeedConfidencePresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDetectedObstacleData->accelSet)
    {
        n32Ret = WJV2_AccelerationSet4Way_DfDec(pstruAsnDetectedObstacleData->accelSet, &(pstruWjDetectedObstacleData->struaccelSet));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AccelerationSet4Way_DfDec is err");
            return false;
        }
        pstruWjDetectedObstacleData->u8accelSetPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDetectedObstacleData->u8accelSetPresent = WJV2_ABSENT;
    }

    n32Ret = WJV2_ObjectSize_DfDec(&pstruAsnDetectedObstacleData->size, &(pstruWjDetectedObstacleData->strusize));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_ObjectSize_DfDec is err");
        return false;
    }

    if (NULL != pstruAsnDetectedObstacleData->objSizeConfidence)
    {
        n32Ret = WJV2_ObjectSizeConfidence_DfDec(pstruAsnDetectedObstacleData->objSizeConfidence, &(pstruWjDetectedObstacleData->struobjSizeConfidence));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ObjectSizeConfidence_DfDec is err");
            return false;
        }
        pstruWjDetectedObstacleData->u8pobjSizeConfidencePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDetectedObstacleData->u8pobjSizeConfidencePresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDetectedObstacleData->tracking)
    {
        if ((WJV2_MAX_tracking_SIZE < (*pstruAsnDetectedObstacleData->tracking)) ||
            (WJV2_MIN_tracking_SIZE > (*pstruAsnDetectedObstacleData->tracking)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth: *pstruAsnDetectedObstacleData->tracking = %d",
                     *pstruAsnDetectedObstacleData->tracking);
            return false;
        }
        pstruWjDetectedObstacleData->n32tracking = *pstruAsnDetectedObstacleData->tracking;
        pstruWjDetectedObstacleData->u8trackingPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDetectedObstacleData->u8trackingPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDetectedObstacleData->polygon)
    {
        n32Ret = WJV2_Polygon_DfDec(pstruAsnDetectedObstacleData->polygon, &(pstruWjDetectedObstacleData->strupolygon));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Polygon_DfDec is err");
            return false;
        }
        pstruWjDetectedObstacleData->u8polygonPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDetectedObstacleData->u8polygonPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_DetectedObstacleList_DfEnc编码函数
* @details   协议栈DetectedObstacleList编解码中 统一DetectedObstacleList的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_DetectedObstacleList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    WJV2_STRU_DetectedObstacleList *pstruWjDetectedObstacleList = (WJV2_STRU_DetectedObstacleList *)pvoidWjDf;
    DetectedObstacleList_t *pstruAsnDetectedObstacleList = (DetectedObstacleList_t *)pvoidAsnDf;
    DetectedObstacleData_t *pstruDetectedObstacleData_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_DetectedObstacleData_LEN < pstruWjDetectedObstacleList->u8DetectedObstacleDataNum) ||
        (WJV2_MIN_LIST_DetectedObstacleData_LEN > pstruWjDetectedObstacleList->u8DetectedObstacleDataNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjDetectedObstacleList->u8DetectedObstacleDataNum = %d",
                 pstruWjDetectedObstacleList->u8DetectedObstacleDataNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjDetectedObstacleList->u8DetectedObstacleDataNum; u32i++)
    {
        pstruDetectedObstacleData_node = CALLOC(1, sizeof(DetectedObstacleData_t));
        if (NULL == pstruDetectedObstacleData_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_DetectedObstacleData_DfEnc(pstruDetectedObstacleData_node, &(pstruWjDetectedObstacleList->struDetectedObstacle[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DetectedObstacleData_DfEnc is err");
            FREEMEM(pstruDetectedObstacleData_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnDetectedObstacleList->list), pstruDetectedObstacleData_node);
    }

    return true;
}
/**
* @brief     WJV2_DetectedObstacleList_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_DetectedObstacleList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_DetectedObstacleList *pstruWjDetectedObstacleList = (WJV2_STRU_DetectedObstacleList *)pvoidWjDf;
    DetectedObstacleList_t *pstruAsnDetectedObstacleList = (DetectedObstacleList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_DetectedObstacleData_LEN < pstruAsnDetectedObstacleList->list.count) ||
        (WJV2_MIN_LIST_DetectedObstacleData_LEN > pstruAsnDetectedObstacleList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnDetectedObstacleList->list.count = %d",
                 pstruAsnDetectedObstacleList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnDetectedObstacleList->list.count; u32i++)
    {
        n32Ret = WJV2_DetectedObstacleData_DfDec(pstruAsnDetectedObstacleList->list.array[u32i],
                                                 &(pstruWjDetectedObstacleList->struDetectedObstacle[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DetectedObstacleData_DfDec is err");
            return false;
        }
    }
    pstruWjDetectedObstacleList->u8DetectedObstacleDataNum = (uint8_t)u32i;
    return true;
}
/**
* @brief     WJV2_DetectedPTCData_DfEnc编码函数
* @details   协议栈DetectedPTCData编解码中 统一DetectedPTCData的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_DetectedPTCData_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    DetectedPTCData_t *pstruAsnDetectedPTCData = (DetectedPTCData_t *)pvoidAsnDf;
    WJV2_STRU_DetectedPTCData *pstruWjDetectedPTCData = (WJV2_STRU_DetectedPTCData *)pvoidWjDf;
    int32_t n32Ret = 0;

    n32Ret = WJV2_ParticipantData_DfEnc(&pstruAsnDetectedPTCData->ptc,
                                        &(pstruWjDetectedPTCData->struptc));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_ParticipantData_DfEnc is err");
        return false;
    }

    if (WJV2_PRESENT == pstruWjDetectedPTCData->u8objSizeConfidencePresent)
    {
        pstruAsnDetectedPTCData->objSizeConfidence = CALLOC(1, sizeof(struct ObjectSizeConfidence));
        if (NULL == pstruAsnDetectedPTCData->objSizeConfidence)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ObjectSizeConfidence_DfEnc(pstruAsnDetectedPTCData->objSizeConfidence,
                                                 &(pstruWjDetectedPTCData->struobjSizeConfidence));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ObjectSizeConfidence_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnDetectedPTCData->objSizeConfidence = NULL;
    }

    if (WJV2_PRESENT == pstruWjDetectedPTCData->u8detectedPTCTypePresent)
    {
        pstruAsnDetectedPTCData->detectedPTCType = CALLOC(1, sizeof(DetectedPTCType_t));
        if (NULL == pstruAsnDetectedPTCData->detectedPTCType)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnDetectedPTCData->detectedPTCType = pstruWjDetectedPTCData->enumdetectedPTCType;
    }
    else
    {
        pstruAsnDetectedPTCData->detectedPTCType = NULL;
    }

    if (WJV2_PRESENT == pstruWjDetectedPTCData->u8typeConfidencePresent)
    {
        if ((WJV2_MAX_CONFIDENCE_SIZE < pstruWjDetectedPTCData->n32typeConfidence) ||
            (WJV2_MIN_CONFIDENCE_SIZE > pstruWjDetectedPTCData->n32typeConfidence))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjDetectedPTCData->n32typeConfidence = %d",
                     pstruWjDetectedPTCData->n32typeConfidence);
            return false;
        }

        pstruAsnDetectedPTCData->typeConfidence = CALLOC(1, sizeof(Confidence_t));
        if (NULL == pstruAsnDetectedPTCData->typeConfidence)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnDetectedPTCData->typeConfidence = pstruWjDetectedPTCData->n32typeConfidence;
    }
    else
    {
        pstruAsnDetectedPTCData->typeConfidence = NULL;
    }

    if (WJV2_PRESENT == pstruWjDetectedPTCData->u8acc4WayConfidencePresent)
    {
        pstruAsnDetectedPTCData->acc4WayConfidence = CALLOC(1, sizeof(struct AccSet4WayConfidence));
        if (NULL == pstruAsnDetectedPTCData->acc4WayConfidence)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_AccSet4WayConfidence_DfEnc(pstruAsnDetectedPTCData->acc4WayConfidence,
                                                 &(pstruWjDetectedPTCData->struacc4WayConfidence));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AccSet4WayConfidence_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnDetectedPTCData->acc4WayConfidence = NULL;
    }

    if (WJV2_PRESENT == pstruWjDetectedPTCData->u8statusDurationPresent)
    {
        if ((WJV2_MAX_TIMEOFFSET_SIZE < pstruWjDetectedPTCData->n32statusDuration) ||
            (WJV2_MIN_TIMEOFFSET_SIZE > pstruWjDetectedPTCData->n32statusDuration))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjDetectedPTCData->n32statusDuration = %d",
                     pstruWjDetectedPTCData->n32statusDuration);
            return false;
        }
        pstruAsnDetectedPTCData->statusDuration = CALLOC(1, sizeof(TimeOffset_t));
        if (NULL == pstruAsnDetectedPTCData->statusDuration)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnDetectedPTCData->statusDuration = pstruWjDetectedPTCData->n32statusDuration;
    }
    else
    {
        pstruAsnDetectedPTCData->statusDuration = NULL;
    }

    if (WJV2_PRESENT == pstruWjDetectedPTCData->u8pathHistoryPresent)
    {
        pstruAsnDetectedPTCData->pathHistory = CALLOC(1, sizeof(struct PathHistory));
        if (NULL == pstruAsnDetectedPTCData->pathHistory)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }

        n32Ret = WJV2_PathHistory_DfEnc(pstruAsnDetectedPTCData->pathHistory,
                                        &(pstruWjDetectedPTCData->strupathHistory));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PathHistory_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnDetectedPTCData->pathHistory = NULL;
    }

    if (WJV2_PRESENT == pstruWjDetectedPTCData->u8planningListPresent)
    {
        pstruAsnDetectedPTCData->planningList = CALLOC(1, sizeof(struct PlanningList));
        if (NULL == pstruAsnDetectedPTCData->planningList)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PlanningList_DfEnc(pstruAsnDetectedPTCData->planningList,
                                         &(pstruWjDetectedPTCData->struplanningList));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PlanningList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnDetectedPTCData->planningList = NULL;
    }

    if (WJV2_PRESENT == pstruWjDetectedPTCData->u8trackingPresent)
    {
        if ((WJV2_MAX_tracking_SIZE < pstruWjDetectedPTCData->n32tracking) ||
            (WJV2_MIN_tracking_SIZE > pstruWjDetectedPTCData->n32tracking))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth: pstruWjDetectedPTCData->n32tracking = %d",
                     pstruWjDetectedPTCData->n32tracking);
            return false;
        }
        pstruAsnDetectedPTCData->tracking = CALLOC(1, sizeof(long));
        if (NULL == pstruAsnDetectedPTCData->tracking)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnDetectedPTCData->tracking = pstruWjDetectedPTCData->n32tracking;
    }
    else
    {
        pstruAsnDetectedPTCData->tracking = NULL;
    }

    if (WJV2_PRESENT == pstruWjDetectedPTCData->u8polygonPresent)
    {
        pstruAsnDetectedPTCData->polygon = CALLOC(1, sizeof(struct Polygon));
        if (NULL == pstruAsnDetectedPTCData->polygon)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_Polygon_DfEnc(pstruAsnDetectedPTCData->polygon,
                                    &(pstruWjDetectedPTCData->strupolygon));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Polygon_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnDetectedPTCData->polygon = NULL;
    }

    if (WJV2_PRESENT == pstruWjDetectedPTCData->u8type_relatedExtPresent)
    {
        pstruAsnDetectedPTCData->type_relatedExt = CALLOC(1, sizeof(struct type_relatedExt));
        if (NULL == pstruAsnDetectedPTCData->type_relatedExt)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        pstruAsnDetectedPTCData->type_relatedExt->present = pstruWjDetectedPTCData->strutype_relatedExt.enumpresent;
        if (WJV2_type_relatedExt_PR_motorExt == pstruWjDetectedPTCData->strutype_relatedExt.enumpresent)
        {
            n32Ret = WJV2_MotorDataExtension_DfEnc(&pstruAsnDetectedPTCData->type_relatedExt->choice.motorExt,
                                                   &(pstruWjDetectedPTCData->strutype_relatedExt.choice.strumotorExt));
            if (true != n32Ret)
            {
                LogPrint(LOG_LEVEL_ERR,
                         STACK_DF_MODULE,
                         "WJV2_MotorDataExtension_DfEnc is err");
                return false;
            }
        }
        else if (WJV2_type_relatedExt_PR_non_motorExt == pstruWjDetectedPTCData->strutype_relatedExt.enumpresent)
        {
            n32Ret = WJV2_NonMotorDataExtension_DfEnc(&pstruAsnDetectedPTCData->type_relatedExt->choice.non_motorExt,
                                                      &(pstruWjDetectedPTCData->strutype_relatedExt.choice.strunon_motorExt));
            if (true != n32Ret)
            {
                LogPrint(LOG_LEVEL_ERR,
                         STACK_DF_MODULE,
                         "WJV2_NonMotorDataExtension_DfEnc is err");
                return false;
            }
        }
    }
    else
    {
        pstruAsnDetectedPTCData->type_relatedExt = NULL;
    }

    return true;
}
/**
* @brief     WJV2_DetectedPTCData_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_DetectedPTCData_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    DetectedPTCData_t *pstruAsnDetectedPTCData = (DetectedPTCData_t *)pvoidAsnDf;
    WJV2_STRU_DetectedPTCData *pstruWjDetectedPTCData = (WJV2_STRU_DetectedPTCData *)pvoidWjDf;
    int32_t n32Ret = 0;

    n32Ret = WJV2_ParticipantData_DfDec(&pstruAsnDetectedPTCData->ptc,
                                        &(pstruWjDetectedPTCData->struptc));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_ParticipantData_DfDec is err");
        return false;
    }

    if (NULL != pstruAsnDetectedPTCData->objSizeConfidence)
    {

        n32Ret = WJV2_ObjectSizeConfidence_DfDec(pstruAsnDetectedPTCData->objSizeConfidence,
                                                 &(pstruWjDetectedPTCData->struobjSizeConfidence));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ObjectSizeConfidence_DfDec is err");
            return false;
        }
        pstruWjDetectedPTCData->u8objSizeConfidencePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDetectedPTCData->u8objSizeConfidencePresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDetectedPTCData->detectedPTCType)
    {

        pstruWjDetectedPTCData->enumdetectedPTCType = *pstruAsnDetectedPTCData->detectedPTCType;
        pstruWjDetectedPTCData->u8detectedPTCTypePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDetectedPTCData->u8detectedPTCTypePresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDetectedPTCData->typeConfidence)
    {
        if ((WJV2_MAX_CONFIDENCE_SIZE < *pstruAsnDetectedPTCData->typeConfidence) ||
            (WJV2_MIN_CONFIDENCE_SIZE > *pstruAsnDetectedPTCData->typeConfidence))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*pstruAsnDetectedPTCData->typeConfidence  = %d",
                     *pstruAsnDetectedPTCData->typeConfidence);
            return false;
        }

        pstruWjDetectedPTCData->n32typeConfidence = *pstruAsnDetectedPTCData->typeConfidence;
        pstruWjDetectedPTCData->u8typeConfidencePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDetectedPTCData->u8typeConfidencePresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDetectedPTCData->acc4WayConfidence)
    {

        n32Ret = WJV2_AccSet4WayConfidence_DfDec(pstruAsnDetectedPTCData->acc4WayConfidence,
                                                 &(pstruWjDetectedPTCData->struacc4WayConfidence));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AccSet4WayConfidence_DfDec is err");
            return false;
        }
        pstruWjDetectedPTCData->u8acc4WayConfidencePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDetectedPTCData->u8acc4WayConfidencePresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDetectedPTCData->statusDuration)
    {
        if ((WJV2_MAX_TIMEOFFSET_SIZE < *pstruAsnDetectedPTCData->statusDuration) ||
            (WJV2_MIN_TIMEOFFSET_SIZE > *pstruAsnDetectedPTCData->statusDuration))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*pstruAsnDetectedPTCData->statusDuration = %d",
                     *pstruAsnDetectedPTCData->statusDuration);
            return false;
        }

        pstruWjDetectedPTCData->n32statusDuration = *pstruAsnDetectedPTCData->statusDuration;
        pstruWjDetectedPTCData->u8statusDurationPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDetectedPTCData->u8statusDurationPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDetectedPTCData->pathHistory)
    {

        n32Ret = WJV2_PathHistory_DfDec(pstruAsnDetectedPTCData->pathHistory,
                                        &(pstruWjDetectedPTCData->strupathHistory));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PathHistory_DfDec is err");
            return false;
        }
        pstruWjDetectedPTCData->u8pathHistoryPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDetectedPTCData->u8pathHistoryPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDetectedPTCData->planningList)
    {

        n32Ret = WJV2_PlanningList_DfDec(pstruAsnDetectedPTCData->planningList,
                                         &(pstruWjDetectedPTCData->struplanningList));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PlanningList_DfDec is err");
            return false;
        }
        pstruWjDetectedPTCData->u8planningListPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDetectedPTCData->u8planningListPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDetectedPTCData->tracking)
    {
        if ((WJV2_MAX_tracking_SIZE < (*pstruAsnDetectedPTCData->tracking)) ||
            (WJV2_MIN_tracking_SIZE > (*pstruAsnDetectedPTCData->tracking)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth: *pstruAsnDetectedPTCData->tracking = %d",
                     *pstruAsnDetectedPTCData->tracking);
            return false;
        }
        pstruWjDetectedPTCData->n32tracking = *pstruAsnDetectedPTCData->tracking;
        pstruWjDetectedPTCData->u8trackingPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDetectedPTCData->u8trackingPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDetectedPTCData->polygon)
    {

        n32Ret = WJV2_Polygon_DfDec(pstruAsnDetectedPTCData->polygon,
                                    &(pstruWjDetectedPTCData->strupolygon));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Polygon_DfDec is err");
            return false;
        }
        pstruWjDetectedPTCData->u8polygonPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDetectedPTCData->u8polygonPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDetectedPTCData->type_relatedExt)
    {

        pstruWjDetectedPTCData->strutype_relatedExt.enumpresent = pstruAsnDetectedPTCData->type_relatedExt->present;
        if (WJV2_type_relatedExt_PR_motorExt == pstruWjDetectedPTCData->strutype_relatedExt.enumpresent)
        {
            n32Ret = WJV2_MotorDataExtension_DfDec(&pstruAsnDetectedPTCData->type_relatedExt->choice.motorExt,
                                                   &(pstruWjDetectedPTCData->strutype_relatedExt.choice.strumotorExt));
            if (true != n32Ret)
            {
                LogPrint(LOG_LEVEL_ERR,
                         STACK_DF_MODULE,
                         "WJV2_MotorDataExtension_DfDec is err");
                return false;
            }
        }
        else if (WJV2_type_relatedExt_PR_non_motorExt == pstruWjDetectedPTCData->strutype_relatedExt.enumpresent)
        {
            n32Ret = WJV2_NonMotorDataExtension_DfDec(&pstruAsnDetectedPTCData->type_relatedExt->choice.non_motorExt,
                                                      &(pstruWjDetectedPTCData->strutype_relatedExt.choice.strunon_motorExt));
            if (true != n32Ret)
            {
                LogPrint(LOG_LEVEL_ERR,
                         STACK_DF_MODULE,
                         "WJV2_NonMotorDataExtension_DfDec is err");
                return false;
            }
        }

        pstruWjDetectedPTCData->u8type_relatedExtPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDetectedPTCData->u8type_relatedExtPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_DetectedPTCList_DfEnc编码函数
* @details   协议栈DetectedPTCList编解码中 统一DetectedPTCList的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_DetectedPTCList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    WJV2_STRU_DetectedPTCList *pstruWjDetectedPTCLis = (WJV2_STRU_DetectedPTCList *)pvoidWjDf;
    DetectedPTCList_t *pstruAsnDetectedPTCLis = (DetectedPTCList_t *)pvoidAsnDf;
    DetectedPTCData_t *pstruDetectedPTCData_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_DetectedPTCData_LEN < pstruWjDetectedPTCLis->u16DetectedPTCDataNum) ||
        (WJV2_MIN_LIST_DetectedPTCData_LEN > pstruWjDetectedPTCLis->u16DetectedPTCDataNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjDetectedPTCLis->u16DetectedPTCDataNum = %d",
                 pstruWjDetectedPTCLis->u16DetectedPTCDataNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjDetectedPTCLis->u16DetectedPTCDataNum; u32i++)
    {
        pstruDetectedPTCData_node = CALLOC(1, sizeof(DetectedPTCData_t));
        if (NULL == pstruDetectedPTCData_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_DetectedPTCData_DfEnc(pstruDetectedPTCData_node, &(pstruWjDetectedPTCLis->struDetectedPTCData[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DetectedPTCData_DfEnc is err");
            FREEMEM(pstruDetectedPTCData_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnDetectedPTCLis->list), pstruDetectedPTCData_node);
    }

    return true;
}
/**
* @brief     WJV2_DetectedPTCList_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_DetectedPTCList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_DetectedPTCList *pstruWjDetectedPTCLis = (WJV2_STRU_DetectedPTCList *)pvoidWjDf;
    DetectedPTCList_t *pstruAsnDetectedPTCLis = (DetectedPTCList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_DetectedPTCData_LEN < pstruAsnDetectedPTCLis->list.count) ||
        (WJV2_MIN_LIST_DetectedPTCData_LEN > pstruAsnDetectedPTCLis->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnDetectedPTCLis->list.count = %d",
                 pstruAsnDetectedPTCLis->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnDetectedPTCLis->list.count; u32i++)
    {
        n32Ret = WJV2_DetectedPTCData_DfDec(pstruAsnDetectedPTCLis->list.array[u32i],
                                            &(pstruWjDetectedPTCLis->struDetectedPTCData[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DetectedPTCData_DfDec is err");
            return false;
        }
    }
    pstruWjDetectedPTCLis->u16DetectedPTCDataNum = (uint8_t)u32i;

    return true;
}
/**
* @brief     WJV2_DetectedRegion_DfEnc编码函数
* @details   协议栈DetectedRegion编解码中 统一DetectedRegion的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_DetectedRegion_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    WJV2_STRU_DetectedRegion *pstruWjDetectedRegion = (WJV2_STRU_DetectedRegion *)pvoidWjDf;
    DetectedRegion_t *pstruAsnDetectedRegion = (DetectedRegion_t *)pvoidAsnDf;
    Polygon_t *pstruPolygon_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_DetectedRegion_LEN < pstruWjDetectedRegion->u8PolygonNum) ||
        (WJV2_MIN_LIST_DetectedRegion_LEN > pstruWjDetectedRegion->u8PolygonNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjDetectedRegion->u8PolygonNum = %d",
                 pstruWjDetectedRegion->u8PolygonNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjDetectedRegion->u8PolygonNum; u32i++)
    {
        pstruPolygon_node = CALLOC(1, sizeof(Polygon_t));
        if (NULL == pstruPolygon_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_Polygon_DfEnc(pstruPolygon_node, &(pstruWjDetectedRegion->struPolygon[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Polygon_DfEnc is err");
            FREEMEM(pstruPolygon_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnDetectedRegion->list), pstruPolygon_node);
    }

    return true;
}
/**
* @brief     WJV2_DetectedRegion_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_DetectedRegion_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_DetectedRegion *pstruWjDetectedRegion = (WJV2_STRU_DetectedRegion *)pvoidWjDf;
    DetectedRegion_t *pstruAsnDetectedRegion = (DetectedRegion_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_DetectedRegion_LEN < pstruAsnDetectedRegion->list.count) ||
        (WJV2_MIN_LIST_DetectedRegion_LEN > pstruAsnDetectedRegion->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnDetectedRegion->list.count = %d",
                 pstruAsnDetectedRegion->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnDetectedRegion->list.count; u32i++)
    {
        n32Ret = WJV2_Polygon_DfDec(pstruAsnDetectedRegion->list.array[u32i],
                                    &(pstruWjDetectedRegion->struPolygon[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Polygon_DfDec is err");
            return false;
        }
    }
    pstruWjDetectedRegion->u8PolygonNum = (uint8_t)u32i;
    return true;
}
/**
* @brief     WJV2_DriveRequest_DfEnc编码函数
* @details   协议栈DriveRequest编解码中 统一DriveRequest的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_DriveRequest_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    DriveRequest_t *pstruAsnDriveRequest = (DriveRequest_t *)pvoidAsnDf;
    WJV2_STRU_DriveRequest *pstruWjDriveRequest = (WJV2_STRU_DriveRequest *)pvoidWjDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_reqID_SIZE < pstruWjDriveRequest->n32reqID) ||
        (WJV2_MIN_reqID_SIZE > pstruWjDriveRequest->n32reqID))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjDriveRequest->n32reqID = %d",
                 pstruWjDriveRequest->n32reqID);
        return false;
    }
    pstruAsnDriveRequest->reqID = pstruWjDriveRequest->n32reqID;
    pstruAsnDriveRequest->status = pstruWjDriveRequest->enumstatus;

    if (WJV2_PRESENT == pstruWjDriveRequest->u8reqPriorityPresent)
    {
        if ((WJV2_MAX_OCTreqPriority_SIZE < pstruWjDriveRequest->u8OCTreqPriorityNum) ||
            (0 > pstruWjDriveRequest->u8OCTreqPriorityNum))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjDriveRequest->u8OCTreqPriorityNum = %d",
                     pstruWjDriveRequest->u8OCTreqPriorityNum);
            return false;
        }
        pstruAsnDriveRequest->reqPriority = CALLOC(1, sizeof(OCTET_STRING_t));
        if (NULL == pstruAsnDriveRequest->reqPriority)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        pstruAsnDriveRequest->reqPriority->size = pstruWjDriveRequest->u8OCTreqPriorityNum;
        pstruAsnDriveRequest->reqPriority->buf = CALLOC(pstruAsnDriveRequest->reqPriority->size, sizeof(uint8_t));
        if (NULL == pstruAsnDriveRequest->reqPriority->buf)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        memcpy(pstruAsnDriveRequest->reqPriority->buf, pstruWjDriveRequest->u8OCTreqPriority, pstruAsnDriveRequest->reqPriority->size);
    }
    else
    {
        pstruAsnDriveRequest->reqPriority = NULL;
    }

    if (WJV2_PRESENT == pstruWjDriveRequest->u8targetVehPresent)
    {
        if ((WJV2_MAX_OCTtargetVeh_SIZE != pstruWjDriveRequest->u8OCTtargetVehNum) /*||
            (1 > pstruWjDriveRequest->u8OCTtargetVehNum)*/
        )
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjDriveRequest->u8OCTtargetVehNum = %d",
                     pstruWjDriveRequest->u8OCTtargetVehNum);
            return false;
        }
        pstruAsnDriveRequest->targetVeh = CALLOC(1, sizeof(OCTET_STRING_t));
        if (NULL == pstruAsnDriveRequest->targetVeh)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        pstruAsnDriveRequest->targetVeh->size = pstruWjDriveRequest->u8OCTtargetVehNum;
        pstruAsnDriveRequest->targetVeh->buf = CALLOC(pstruAsnDriveRequest->targetVeh->size, sizeof(uint8_t));
        if (NULL == pstruAsnDriveRequest->targetVeh->buf)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        memcpy(pstruAsnDriveRequest->targetVeh->buf, pstruWjDriveRequest->u8OCTtargetVeh, pstruAsnDriveRequest->targetVeh->size);
    }
    else
    {
        pstruAsnDriveRequest->targetVeh = NULL;
    }

    if (WJV2_PRESENT == pstruWjDriveRequest->u8targetRSUPresent)
    {
        if ((WJV2_MAX_OCTtargetRSU_SIZE != pstruWjDriveRequest->u8OCTtargetRSUNum) /*||
            (1 > pstruWjDriveRequest->u8OCTtargetRSUNum)*/
        )
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjDriveRequest->u8OCTtargetRSUNum = %d",
                     pstruWjDriveRequest->u8OCTtargetRSUNum);
            return false;
        }
        pstruAsnDriveRequest->targetRSU = CALLOC(1, sizeof(OCTET_STRING_t));
        if (NULL == pstruAsnDriveRequest->targetRSU)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        pstruAsnDriveRequest->targetRSU->size = pstruWjDriveRequest->u8OCTtargetRSUNum;
        pstruAsnDriveRequest->targetRSU->buf = CALLOC(pstruAsnDriveRequest->targetRSU->size, sizeof(uint8_t));
        if (NULL == pstruAsnDriveRequest->targetRSU->buf)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        memcpy(pstruAsnDriveRequest->targetRSU->buf, pstruWjDriveRequest->u8OCTtargetRSU, pstruAsnDriveRequest->targetRSU->size);
    }
    else
    {
        pstruAsnDriveRequest->targetRSU = NULL;
    }

    if (WJV2_PRESENT == pstruWjDriveRequest->u8infoPresent)
    {
        pstruAsnDriveRequest->info = CALLOC(1, sizeof(struct ReqInfo));
        if (NULL == pstruAsnDriveRequest->info)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ReqInfo_DfEnc(pstruAsnDriveRequest->info,
                                    &(pstruWjDriveRequest->struinfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReqInfo_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnDriveRequest->info = NULL;
    }

    if (WJV2_PRESENT == pstruWjDriveRequest->u8lifeTimePresent)
    {
        if ((WJV2_MAX_TIMEOFFSET_SIZE < pstruWjDriveRequest->n32lifeTime) ||
            (WJV2_MIN_TIMEOFFSET_SIZE > pstruWjDriveRequest->n32lifeTime))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjDriveRequest->n32lifeTime = %d",
                     pstruWjDriveRequest->n32lifeTime);
            return false;
        }

        pstruAsnDriveRequest->lifeTime = CALLOC(1, sizeof(TimeOffset_t));
        if (NULL == pstruAsnDriveRequest->lifeTime)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnDriveRequest->lifeTime = pstruWjDriveRequest->n32lifeTime;
    }
    else
    {
        pstruAsnDriveRequest->lifeTime = NULL;
    }

    return true;
}
/**
* @brief     WJV2_DriveRequest_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_DriveRequest_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    DriveRequest_t *pstruAsnDriveRequest = (DriveRequest_t *)pvoidAsnDf;
    WJV2_STRU_DriveRequest *pstruWjDriveRequest = (WJV2_STRU_DriveRequest *)pvoidWjDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_reqID_SIZE < pstruAsnDriveRequest->reqID) ||
        (WJV2_MIN_reqID_SIZE > pstruAsnDriveRequest->reqID))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnDriveRequest->reqID = %d",
                 pstruAsnDriveRequest->reqID);
        return false;
    }
    pstruWjDriveRequest->n32reqID = pstruAsnDriveRequest->reqID;
    pstruWjDriveRequest->enumstatus = pstruAsnDriveRequest->status;

    if (NULL != pstruAsnDriveRequest->reqPriority)
    {
        if ((WJV2_MAX_OCTreqPriority_SIZE < pstruAsnDriveRequest->reqPriority->size) ||
            (0 > pstruAsnDriveRequest->reqPriority->size))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruAsnDriveRequest->reqPriority->size = %d",
                     pstruAsnDriveRequest->reqPriority->size);
            return false;
        }
        pstruWjDriveRequest->u8OCTreqPriorityNum = pstruAsnDriveRequest->reqPriority->size;
        if (NULL != pstruAsnDriveRequest->reqPriority->buf)
        {
            memcpy(pstruWjDriveRequest->u8OCTreqPriority, pstruAsnDriveRequest->reqPriority->buf, pstruAsnDriveRequest->reqPriority->size);
            pstruWjDriveRequest->u8reqPriorityPresent = WJV2_PRESENT;
        }
    }
    else
    {
        pstruWjDriveRequest->u8reqPriorityPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDriveRequest->targetVeh)
    {
        if ((WJV2_MAX_OCTtargetVeh_SIZE != pstruAsnDriveRequest->targetVeh->size) /*||
            (1 > pstruAsnDriveRequest->targetVeh->size)*/
        )
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruAsnDriveRequest->targetVeh->size = %d",
                     pstruAsnDriveRequest->targetVeh->size);
            return false;
        }
        pstruWjDriveRequest->u8OCTtargetVehNum = pstruAsnDriveRequest->targetVeh->size;
        if (NULL != pstruAsnDriveRequest->targetVeh->buf)
        {
            memcpy(pstruWjDriveRequest->u8OCTtargetVeh, pstruAsnDriveRequest->targetVeh->buf, pstruAsnDriveRequest->targetVeh->size);
            pstruWjDriveRequest->u8targetVehPresent = WJV2_PRESENT;
        }
    }
    else
    {
        pstruWjDriveRequest->u8targetVehPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDriveRequest->targetRSU)
    {
        if ((WJV2_MAX_OCTtargetRSU_SIZE != pstruAsnDriveRequest->targetRSU->size) /*||
            (1 > pstruAsnDriveRequest->targetRSU->size)*/
        )
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruAsnDriveRequest->targetRSU->size = %d",
                     pstruAsnDriveRequest->targetRSU->size);
            return false;
        }
        pstruWjDriveRequest->u8OCTtargetRSUNum = pstruAsnDriveRequest->targetRSU->size;
        if (NULL != pstruAsnDriveRequest->targetRSU->buf)
        {
            memcpy(pstruWjDriveRequest->u8OCTtargetRSU, pstruAsnDriveRequest->targetRSU->buf, pstruAsnDriveRequest->targetRSU->size);
            pstruWjDriveRequest->u8targetRSUPresent = WJV2_PRESENT;
        }
    }
    else
    {
        pstruWjDriveRequest->u8targetRSUPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDriveRequest->info)
    {
        n32Ret = WJV2_ReqInfo_DfDec(pstruAsnDriveRequest->info,
                                    &(pstruWjDriveRequest->struinfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReqInfo_DfDec is err");
            return false;
        }
        pstruWjDriveRequest->u8infoPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDriveRequest->u8infoPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDriveRequest->lifeTime)
    {
        if ((WJV2_MAX_TIMEOFFSET_SIZE < *pstruAsnDriveRequest->lifeTime) ||
            (WJV2_MIN_TIMEOFFSET_SIZE > *pstruAsnDriveRequest->lifeTime))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*pstruAsnDriveRequest->lifeTime = %d",
                     *pstruAsnDriveRequest->lifeTime);
            return false;
        }
        pstruWjDriveRequest->n32lifeTime = *pstruAsnDriveRequest->lifeTime;
        pstruWjDriveRequest->u8lifeTimePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDriveRequest->u8lifeTimePresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_DriveSuggestion_DfEnc编码函数
* @details   协议栈DriveSuggestion编解码中 统一DriveSuggestion的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_DriveSuggestion_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    DriveSuggestion_t *pstruAsnDriveSuggestion = (DriveSuggestion_t *)pvoidAsnDf;
    WJV2_STRU_DriveSuggestion *pstruWjDriveSuggestion = (WJV2_STRU_DriveSuggestion *)pvoidWjDf;
    int32_t n32Ret = 0;

    pstruAsnDriveSuggestion->suggestion.size = WJV2_LEN_BYTE_DriveBehavior;
    pstruAsnDriveSuggestion->suggestion.bits_unused = (8 * WJV2_LEN_BYTE_DriveBehavior) - WJV2_LEN_BITSTR_DriveBehavior;
    pstruAsnDriveSuggestion->suggestion.buf = CALLOC(pstruAsnDriveSuggestion->suggestion.size, sizeof(uint8_t));
    if (NULL == pstruAsnDriveSuggestion->suggestion.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "calloc is err");
        return false;
    }

    n32Ret = WJV2_BITSTRING_DeEnc(&pstruAsnDriveSuggestion->suggestion,
                                  &(pstruWjDriveSuggestion->bitsuggestion));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_BITSTRING_DeEnc is err");
        return false;
    }

    if (WJV2_PRESENT == pstruWjDriveSuggestion->u8lifeTimePresent)
    {
        if ((WJV2_MAX_TIMEOFFSET_SIZE < pstruWjDriveSuggestion->n32lifeTime) ||
            (WJV2_MIN_TIMEOFFSET_SIZE > pstruWjDriveSuggestion->n32lifeTime))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjDriveSuggestion->n32lifeTime = %d",
                     pstruWjDriveSuggestion->n32lifeTime);
            return false;
        }
        pstruAsnDriveSuggestion->lifeTime = CALLOC(1, sizeof(TimeOffset_t));
        if (NULL == pstruAsnDriveSuggestion->lifeTime)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnDriveSuggestion->lifeTime = pstruWjDriveSuggestion->n32lifeTime;
    }
    else
    {
        pstruAsnDriveSuggestion->lifeTime = NULL;
    }

    if (WJV2_PRESENT == pstruWjDriveSuggestion->u8relatedLinkPresent)
    {
        pstruAsnDriveSuggestion->relatedLink = CALLOC(1, sizeof(struct ReferenceLink));
        if (NULL == pstruAsnDriveSuggestion->relatedLink)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ReferenceLink_DfEnc(pstruAsnDriveSuggestion->relatedLink,
                                          &(pstruWjDriveSuggestion->strurelatedLink));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferenceLink_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnDriveSuggestion->relatedLink = NULL;
    }

    if (WJV2_PRESENT == pstruWjDriveSuggestion->u8relatedPathPresent)
    {
        pstruAsnDriveSuggestion->relatedPath = CALLOC(1, sizeof(struct ReferencePath));
        if (NULL == pstruAsnDriveSuggestion->relatedPath)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ReferencePath_DfEnc(pstruAsnDriveSuggestion->relatedPath,
                                          &(pstruWjDriveSuggestion->strurelatedPath));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferencePath_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnDriveSuggestion->relatedPath = NULL;
    }

    return true;
}
/**
* @brief     WJV2_DriveSuggestion_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_DriveSuggestion_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    DriveSuggestion_t *pstruAsnDriveSuggestion = (DriveSuggestion_t *)pvoidAsnDf;
    WJV2_STRU_DriveSuggestion *pstruWjDriveSuggestion = (WJV2_STRU_DriveSuggestion *)pvoidWjDf;
    int32_t n32Ret = 0;

    n32Ret = WJV2_BITSTRING_DeDec(&pstruAsnDriveSuggestion->suggestion,
                                  &(pstruWjDriveSuggestion->bitsuggestion));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_BITSTRING_DeDec is err");
        return false;
    }

    if (NULL != pstruAsnDriveSuggestion->lifeTime)
    {
        if ((WJV2_MAX_TIMEOFFSET_SIZE < *pstruAsnDriveSuggestion->lifeTime) ||
            (WJV2_MIN_TIMEOFFSET_SIZE > *pstruAsnDriveSuggestion->lifeTime))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*pstruAsnDriveSuggestion->lifeTime = %d",
                     *pstruAsnDriveSuggestion->lifeTime);
            return false;
        }
        pstruWjDriveSuggestion->n32lifeTime = *pstruAsnDriveSuggestion->lifeTime;
        pstruWjDriveSuggestion->u8lifeTimePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDriveSuggestion->u8lifeTimePresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDriveSuggestion->relatedLink)
    {

        n32Ret = WJV2_ReferenceLink_DfDec(pstruAsnDriveSuggestion->relatedLink,
                                          &(pstruWjDriveSuggestion->strurelatedLink));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferenceLink_DfDec is err");
            return false;
        }
        pstruWjDriveSuggestion->u8relatedLinkPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDriveSuggestion->u8relatedLinkPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnDriveSuggestion->relatedPath)
    {

        n32Ret = WJV2_ReferencePath_DfDec(pstruAsnDriveSuggestion->relatedPath,
                                          &(pstruWjDriveSuggestion->strurelatedPath));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferencePath_DfDec is err");
            return false;
        }
        pstruWjDriveSuggestion->u8relatedPathPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjDriveSuggestion->u8relatedPathPresent = WJV2_ABSENT;
    }
    return true;
}

/**
* @brief     WJV2_GBICCInfo_DfEnc编码函数
* @details   协议栈GBICCInfo编解码中 统一GBICCInfo的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_GBICCInfo_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    GBICCInfo_t *pstruAsnGBICCInfo = (GBICCInfo_t *)pvoidAsnDf;
    WJV2_STRU_GBICCInfo *pstruWjGBICCInfo = (WJV2_STRU_GBICCInfo *)pvoidWjDf;

    if ((WJV2_MAX_OCTiccIssueInfo_SIZE < pstruWjGBICCInfo->u8OCTiccIssueInfoNum) ||
        (WJV2_MIN_OCTiccIssueInfo_SIZE > pstruWjGBICCInfo->u8OCTiccIssueInfoNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjGBICCInfo->u8OCTiccIssueInfoNum = %d",
                 pstruWjGBICCInfo->u8OCTiccIssueInfoNum);
        return false;
    }

    pstruAsnGBICCInfo->iccIssueInfo.size = pstruWjGBICCInfo->u8OCTiccIssueInfoNum;
    pstruAsnGBICCInfo->iccIssueInfo.buf = CALLOC(pstruAsnGBICCInfo->iccIssueInfo.size, sizeof(uint8_t));
    if (NULL == pstruAsnGBICCInfo->iccIssueInfo.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruAsnGBICCInfo->iccIssueInfo.buf, pstruWjGBICCInfo->u8OCTiccIssueInfo, pstruAsnGBICCInfo->iccIssueInfo.size);

    if ((WJV2_MAX_OCTiccUniTollInfo_SIZE < pstruWjGBICCInfo->u8OCTiccUniTollInfoNum) ||
        (WJV2_MIN_OCTiccUniTollInfo_SIZE > pstruWjGBICCInfo->u8OCTiccUniTollInfoNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjGBICCInfo->u8OCTiccUniTollInfoNum = %d",
                 pstruWjGBICCInfo->u8OCTiccUniTollInfoNum);
        return false;
    }

    pstruAsnGBICCInfo->iccUniTollInfo.size = pstruWjGBICCInfo->u8OCTiccUniTollInfoNum;
    pstruAsnGBICCInfo->iccUniTollInfo.buf = CALLOC(pstruAsnGBICCInfo->iccUniTollInfo.size, sizeof(uint8_t));
    if (NULL == pstruAsnGBICCInfo->iccUniTollInfo.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruAsnGBICCInfo->iccUniTollInfo.buf, pstruWjGBICCInfo->u8OCTiccUniTollInfo, pstruAsnGBICCInfo->iccUniTollInfo.size);

    if ((WJV2_MAX_OCTiccBalance_SIZE < pstruWjGBICCInfo->u8OCTiccBalanceNum) ||
        (WJV2_MIN_OCTiccBalance_SIZE > pstruWjGBICCInfo->u8OCTiccBalanceNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjGBICCInfo->u8OCTiccBalanceNum = %d",
                 pstruWjGBICCInfo->u8OCTiccBalanceNum);
        return false;
    }
    pstruAsnGBICCInfo->iccBalance.size = pstruWjGBICCInfo->u8OCTiccBalanceNum;
    pstruAsnGBICCInfo->iccBalance.buf = CALLOC(pstruAsnGBICCInfo->iccBalance.size, sizeof(uint8_t));
    if (NULL == pstruAsnGBICCInfo->iccBalance.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruAsnGBICCInfo->iccBalance.buf, pstruWjGBICCInfo->u8OCTiccBalance, pstruAsnGBICCInfo->iccBalance.size);

    return true;
}
/**
* @brief     WJV2_GBICCInfo_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_GBICCInfo_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    GBICCInfo_t *pstruAsnGBICCInfo = (GBICCInfo_t *)pvoidAsnDf;
    WJV2_STRU_GBICCInfo *pstruWjGBICCInfo = (WJV2_STRU_GBICCInfo *)pvoidWjDf;

    if ((WJV2_MAX_OCTiccIssueInfo_SIZE < pstruAsnGBICCInfo->iccIssueInfo.size) ||
        (WJV2_MIN_OCTiccIssueInfo_SIZE > pstruAsnGBICCInfo->iccIssueInfo.size))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnGBICCInfo->iccIssueInfo.size = %d",
                 pstruAsnGBICCInfo->iccIssueInfo.size);
        return false;
    }

    pstruWjGBICCInfo->u8OCTiccIssueInfoNum = pstruAsnGBICCInfo->iccIssueInfo.size;
    if (NULL != pstruAsnGBICCInfo->iccIssueInfo.buf)
    {
        memcpy(pstruWjGBICCInfo->u8OCTiccIssueInfo, pstruAsnGBICCInfo->iccIssueInfo.buf, pstruAsnGBICCInfo->iccIssueInfo.size);
    }

    if ((WJV2_MAX_OCTiccUniTollInfo_SIZE < pstruAsnGBICCInfo->iccUniTollInfo.size) ||
        (WJV2_MIN_OCTiccUniTollInfo_SIZE > pstruAsnGBICCInfo->iccUniTollInfo.size))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnGBICCInfo->iccUniTollInfo.size = %d",
                 pstruAsnGBICCInfo->iccUniTollInfo.size);
        return false;
    }

    pstruWjGBICCInfo->u8OCTiccUniTollInfoNum = pstruAsnGBICCInfo->iccUniTollInfo.size;
    if (NULL != pstruAsnGBICCInfo->iccUniTollInfo.buf)
    {
        memcpy(pstruWjGBICCInfo->u8OCTiccUniTollInfo, pstruAsnGBICCInfo->iccUniTollInfo.buf, pstruAsnGBICCInfo->iccUniTollInfo.size);
    }

    if ((WJV2_MAX_OCTiccBalance_SIZE < pstruAsnGBICCInfo->iccBalance.size) ||
        (WJV2_MIN_OCTiccBalance_SIZE > pstruAsnGBICCInfo->iccBalance.size))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnGBICCInfo->iccBalance.size = %d",
                 pstruAsnGBICCInfo->iccBalance.size);
        return false;
    }

    pstruWjGBICCInfo->u8OCTiccBalanceNum = pstruAsnGBICCInfo->iccBalance.size;
    if (NULL != pstruAsnGBICCInfo->iccBalance.buf)
    {
        memcpy(pstruWjGBICCInfo->u8OCTiccBalance, pstruAsnGBICCInfo->iccBalance.buf, pstruAsnGBICCInfo->iccBalance.size);
    }

    return true;
}
/**
* @brief     WJV2_GetTollDataRq_DfEnc编码函数
* @details   协议栈GetTollDataRq编解码中 统一GetTollDataRq的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行���果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_GetTollDataRq_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    GetTollDataRq_t *pstruAsnGetTollDataRq = (GetTollDataRq_t *)pvoidAsnDf;
    WJV2_STRU_GetTollDataRq *pstruWjGetTollDataRq = (WJV2_STRU_GetTollDataRq *)pvoidWjDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_RangeOfFile_DfEnc(&pstruAsnGetTollDataRq->vehicleInfo,
                                    &(pstruWjGetTollDataRq->struvehicleInfo));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_RangeOfFile_DfEnc is err");
        return false;
    }

    if (WJV2_PRESENT == pstruWjGetTollDataRq->u8tollInfoPresent)
    {
        pstruAsnGetTollDataRq->tollInfo = CALLOC(1, sizeof(struct RangeOfFile));
        if (NULL == pstruAsnGetTollDataRq->tollInfo)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_RangeOfFile_DfEnc(pstruAsnGetTollDataRq->tollInfo,
                                        &(pstruWjGetTollDataRq->strutollInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RangeOfFile_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnGetTollDataRq->tollInfo = NULL;
    }

    if (WJV2_PRESENT == pstruWjGetTollDataRq->u8keyIdForACPresent)
    {
        if ((WJV2_MAX_keyIdForAC_SIZE < pstruWjGetTollDataRq->n32keyIdForAC) ||
            (WJV2_MIN_keyIdForAC_SIZE > pstruWjGetTollDataRq->n32keyIdForAC))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjGetTollDataRq->n32keyIdForAC = %d",
                     pstruWjGetTollDataRq->n32keyIdForAC);
            return false;
        }
        pstruAsnGetTollDataRq->keyIdForAC = CALLOC(1, sizeof(long));
        if (NULL == pstruAsnGetTollDataRq->keyIdForAC)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnGetTollDataRq->keyIdForAC = pstruWjGetTollDataRq->n32keyIdForAC;
    }
    else
    {
        pstruAsnGetTollDataRq->keyIdForAC = NULL;
    }

    return true;
}
/**
* @brief     WJV2_GetTollDataRq_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_GetTollDataRq_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    GetTollDataRq_t *pstruAsnGetTollDataRq = (GetTollDataRq_t *)pvoidAsnDf;
    WJV2_STRU_GetTollDataRq *pstruWjGetTollDataRq = (WJV2_STRU_GetTollDataRq *)pvoidWjDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_RangeOfFile_DfDec(&pstruAsnGetTollDataRq->vehicleInfo,
                                    &(pstruWjGetTollDataRq->struvehicleInfo));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_RangeOfFile_DfDec is err");
        return false;
    }

    if (NULL != pstruAsnGetTollDataRq->tollInfo)
    {
        n32Ret = WJV2_RangeOfFile_DfDec(pstruAsnGetTollDataRq->tollInfo,
                                        &(pstruWjGetTollDataRq->strutollInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RangeOfFile_DfDec is err");
            return false;
        }
        pstruWjGetTollDataRq->u8tollInfoPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjGetTollDataRq->u8tollInfoPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnGetTollDataRq->keyIdForAC)
    {
        if ((WJV2_MAX_keyIdForAC_SIZE < (*pstruAsnGetTollDataRq->keyIdForAC)) ||
            (WJV2_MIN_keyIdForAC_SIZE > (*pstruAsnGetTollDataRq->keyIdForAC)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*pstruAsnGetTollDataRq->keyIdForAC = %d",
                     *pstruAsnGetTollDataRq->keyIdForAC);
            return false;
        }
        pstruWjGetTollDataRq->n32keyIdForAC = *pstruAsnGetTollDataRq->keyIdForAC;
        pstruWjGetTollDataRq->u8keyIdForACPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjGetTollDataRq->u8keyIdForACPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_GetTollDataRs_DfEnc编码函数
* @details   协议栈GetTollDataRs编解码中 统一GetTollDataRs的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_GetTollDataRs_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    GetTollDataRs_t *pstruAsnGetTollDataRs = (GetTollDataRs_t *)pvoidAsnDf;
    WJV2_STRU_GetTollDataRs *pstruWjGetTollDataRs = (WJV2_STRU_GetTollDataRs *)pvoidWjDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_File_DeEnc(&pstruAsnGetTollDataRs->vehicleInfo,
                             &(pstruWjGetTollDataRs->octvehicleInfo));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_File_DeEnc is err");
        return false;
    }

    if (WJV2_PRESENT == pstruWjGetTollDataRs->u8tollInfoPresent)
    {
        pstruAsnGetTollDataRs->tollInfo = CALLOC(1, sizeof(File_t));
        if (NULL == pstruAsnGetTollDataRs->tollInfo)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_File_DeEnc(pstruAsnGetTollDataRs->tollInfo,
                                 &(pstruWjGetTollDataRs->octtollInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_File_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnGetTollDataRs->tollInfo = NULL;
    }

    return true;
}
/**
* @brief     WJV2_GetTollDataRs_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_GetTollDataRs_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    GetTollDataRs_t *pstruAsnGetTollDataRs = (GetTollDataRs_t *)pvoidAsnDf;
    WJV2_STRU_GetTollDataRs *pstruWjGetTollDataRs = (WJV2_STRU_GetTollDataRs *)pvoidWjDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_File_DeDec(&pstruAsnGetTollDataRs->vehicleInfo,
                             &(pstruWjGetTollDataRs->octvehicleInfo));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_File_DeDec is err");
        return false;
    }

    if (NULL != pstruAsnGetTollDataRs->tollInfo)
    {
        n32Ret = WJV2_File_DeDec(pstruAsnGetTollDataRs->tollInfo,
                                 &(pstruWjGetTollDataRs->octtollInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_File_DeDec is err");
            return false;
        }
        pstruWjGetTollDataRs->u8tollInfoPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjGetTollDataRs->u8tollInfoPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_GetSecureRq_DfEnc编码函数
* @details   协议栈GetSecureRq编解码中 统一GetSecureRq的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_GetSecureRq_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    GetSecureRq_t *pstruAsnGetSecureRq = (GetSecureRq_t *)pvoidAsnDf;
    WJV2_STRU_GetSecureRq *pstruWjGetSecureRq = (WJV2_STRU_GetSecureRq *)pvoidWjDf;
    int32_t n32Ret = 0;

    n32Ret = WJV2_RangeOfFile_DfEnc(&pstruAsnGetSecureRq->vehicleInfo,
                                    &(pstruWjGetSecureRq->struvehicleInfo));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_RangeOfFile_DfEnc is err");
        return false;
    }

    n32Ret = WJV2_RandStr8_DeEnc(&pstruAsnGetSecureRq->rndRsuForAuthen,
                                 &(pstruWjGetSecureRq->octrndRsuForAuthen));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_RandStr8_DeEnc is err");
        return false;
    }
    if ((WJV2_MAX_keyIdForAuthen_SIZE < pstruWjGetSecureRq->n32keyIdForAuthen) ||
        (WJV2_MIN_keyIdForAuthen_SIZE > pstruWjGetSecureRq->n32keyIdForAuthen))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth: pstruWjGetSecureRq->n32keyIdForAuthen = %d",
                 pstruWjGetSecureRq->n32keyIdForAuthen);
        return false;
    }
    pstruAsnGetSecureRq->keyIdForAuthen = pstruWjGetSecureRq->n32keyIdForAuthen;
    if (WJV2_PRESENT == pstruWjGetSecureRq->u8keyIdForEncryptPresent)
    {
        if ((WJV2_MAX_keyIdForEncrypt_SIZE < pstruWjGetSecureRq->n32keyIdForEncrypt) ||
            (WJV2_MIN_keyIdForEncrypt_SIZE > pstruWjGetSecureRq->n32keyIdForEncrypt))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth: pstruWjGetSecureRq->n32keyIdForEncrypt = %d",
                     pstruWjGetSecureRq->n32keyIdForEncrypt);
            return false;
        }
        pstruAsnGetSecureRq->keyIdForEncrypt = CALLOC(1, sizeof(long));
        if (NULL == pstruAsnGetSecureRq->keyIdForEncrypt)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnGetSecureRq->keyIdForEncrypt = pstruWjGetSecureRq->n32keyIdForEncrypt;
    }
    else
    {
        pstruAsnGetSecureRq->keyIdForEncrypt = NULL;
    }

    return true;
}
/**
* @brief     WJV2_GetSecureRq_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_GetSecureRq_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    GetSecureRq_t *pstruAsnGetSecureRq = (GetSecureRq_t *)pvoidAsnDf;
    WJV2_STRU_GetSecureRq *pstruWjGetSecureRq = (WJV2_STRU_GetSecureRq *)pvoidWjDf;
    int32_t n32Ret = 0;

    n32Ret = WJV2_RangeOfFile_DfDec(&pstruAsnGetSecureRq->vehicleInfo,
                                    &(pstruWjGetSecureRq->struvehicleInfo));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_RangeOfFile_DfDec is err");
        return false;
    }

    n32Ret = WJV2_RandStr8_DeDec(&pstruAsnGetSecureRq->rndRsuForAuthen,
                                 &(pstruWjGetSecureRq->octrndRsuForAuthen));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_RandStr8_DeDec is err");
        return false;
    }
    if ((WJV2_MAX_keyIdForAuthen_SIZE < pstruAsnGetSecureRq->keyIdForAuthen) ||
        (WJV2_MIN_keyIdForAuthen_SIZE > pstruAsnGetSecureRq->keyIdForAuthen))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth: pstruAsnGetSecureRq->keyIdForAuthen = %d",
                 pstruAsnGetSecureRq->keyIdForAuthen);
        return false;
    }
    pstruWjGetSecureRq->n32keyIdForAuthen = pstruAsnGetSecureRq->keyIdForAuthen;
    if (NULL != pstruAsnGetSecureRq->keyIdForEncrypt)
    {
        if ((WJV2_MAX_keyIdForEncrypt_SIZE < (*pstruAsnGetSecureRq->keyIdForEncrypt)) ||
            (WJV2_MIN_keyIdForEncrypt_SIZE > (*pstruAsnGetSecureRq->keyIdForEncrypt)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth: *pstruAsnGetSecureRq->keyIdForEncrypt = %d",
                     *pstruAsnGetSecureRq->keyIdForEncrypt);
            return false;
        }
        pstruWjGetSecureRq->n32keyIdForEncrypt = *pstruAsnGetSecureRq->keyIdForEncrypt;
        pstruWjGetSecureRq->u8keyIdForEncryptPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjGetSecureRq->u8keyIdForEncryptPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_GetSecureRs_DfEnc编码函数
* @details   协议栈GetSecureRs编解码中 统一GetSecureRs的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_GetSecureRs_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    GetSecureRs_t *pstruAsnGetSecureRs = (GetSecureRs_t *)pvoidAsnDf;
    WJV2_STRU_GetSecureRs *pstruWjGetSecureRs = (WJV2_STRU_GetSecureRs *)pvoidWjDf;
    int32_t n32Ret = 0;

    n32Ret = WJV2_RangeOfFile_DfEnc(&pstruAsnGetSecureRs->file,
                                    &(pstruWjGetSecureRs->strufile));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_RangeOfFile_DfEnc is err");
        return false;
    }

    if ((WJV2_MAX_OCTauthenticator_SIZE != pstruWjGetSecureRs->u8OCTauthenticatorNum) /*||
        (1 > pstruWjGetSecureRs->u8OCTauthenticatorNum)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjGetSecureRs->u8OCTauthenticatorNum = %d",
                 pstruWjGetSecureRs->u8OCTauthenticatorNum);
        return false;
    }

    pstruAsnGetSecureRs->authenticator.size = pstruWjGetSecureRs->u8OCTauthenticatorNum;
    pstruAsnGetSecureRs->authenticator.buf = CALLOC(pstruAsnGetSecureRs->authenticator.size, sizeof(uint8_t));
    if (NULL == pstruAsnGetSecureRs->authenticator.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruAsnGetSecureRs->authenticator.buf, pstruWjGetSecureRs->u8OCTauthenticator, pstruAsnGetSecureRs->authenticator.size);

    return true;
}
/**
* @brief     WJV2_GetSecureRs_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_GetSecureRs_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    GetSecureRs_t *pstruAsnGetSecureRs = (GetSecureRs_t *)pvoidAsnDf;
    WJV2_STRU_GetSecureRs *pstruWjGetSecureRs = (WJV2_STRU_GetSecureRs *)pvoidWjDf;
    int32_t n32Ret = 0;

    n32Ret = WJV2_RangeOfFile_DfDec(&pstruAsnGetSecureRs->file,
                                    &(pstruWjGetSecureRs->strufile));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_RangeOfFile_DfDec is err");
        return false;
    }

    if ((WJV2_MAX_OCTauthenticator_SIZE != pstruAsnGetSecureRs->authenticator.size) /*||
        (1 > pstruAsnGetSecureRs->authenticator.size)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnGetSecureRs->authenticator.size = %d",
                 pstruAsnGetSecureRs->authenticator.size);
        return false;
    }

    pstruWjGetSecureRs->u8OCTauthenticatorNum = pstruAsnGetSecureRs->authenticator.size;
    if (NULL != pstruAsnGetSecureRs->authenticator.buf)
    {
        memcpy(pstruWjGetSecureRs->u8OCTauthenticator, pstruAsnGetSecureRs->authenticator.buf, pstruAsnGetSecureRs->authenticator.size);
    }

    return true;
}

/**
* @brief     WJV2_reqsList_DfEnc编码函数
* @details   协议栈Df编解码中 统一Df的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_reqsList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_reqsList *pstruWjreqsList = (WJV2_STRU_reqsList *)pvoidWjDf;
    struct reqs *pstruAsnreqsList = (struct reqs *)pvoidAsnDf;
    DriveRequest_t *pstruDriveRequest_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_DriveRequest_LEN < pstruWjreqsList->u8DriveRequestNum) ||
        (WJV2_MIN_LIST_DriveRequest_LEN > pstruWjreqsList->u8DriveRequestNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjreqsList->u8DriveRequestNum = %d",
                 pstruWjreqsList->u8DriveRequestNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjreqsList->u8DriveRequestNum; u32i++)
    {
        pstruDriveRequest_node = CALLOC(1, sizeof(DriveRequest_t));
        if (NULL == pstruDriveRequest_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_DriveRequest_DfEnc(pstruDriveRequest_node, &(pstruWjreqsList->struDriveRequest[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DriveRequest_DfEnc is err");
            FREEMEM(pstruDriveRequest_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnreqsList->list), pstruDriveRequest_node);
    }
    return true;
}
/**
* @brief     WJV2_reqsList_DfDec解码函数
* @details   协议栈Df编解码中 统一Df的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      huangsai
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2020-12-17  <td>1.0      <td>huangsai  <td>创建初始版本
* </table>
*/
int32_t WJV2_reqsList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_reqsList *pstruWjreqsList = (WJV2_STRU_reqsList *)pvoidWjDf;
    struct reqs *pstruAsnreqsList = (struct reqs *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_DriveRequest_LEN < pstruAsnreqsList->list.count) ||
        (WJV2_MIN_LIST_DriveRequest_LEN > pstruAsnreqsList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnreqsList->list.count = %d",
                 pstruAsnreqsList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnreqsList->list.count; u32i++)
    {
        n32Ret = WJV2_DriveRequest_DfDec(pstruAsnreqsList->list.array[u32i],
                                         &(pstruWjreqsList->struDriveRequest[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DriveRequest_DfDec is err");
            return false;
        }
    }
    pstruWjreqsList->u8DriveRequestNum = (uint8_t)u32i;
    return true;
}

/**
* @brief     WJV2_IARData_DfEnc编码函数
* @details   协议栈IARData编解码中 统一IARData的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_IARData_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    IARData_t *pstruAsnIARData = (IARData_t *)pvoidAsnDf;
    WJV2_STRU_IARData *pstruWjIARData = (WJV2_STRU_IARData *)pvoidWjDf;
    int32_t n32Ret = 0;
    if (WJV2_PRESENT == pstruWjIARData->u8currentPosPresent)
    {
        pstruAsnIARData->currentPos = CALLOC(1, sizeof(struct PathPlanningPoint));
        if (NULL == pstruAsnIARData->currentPos)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PathPlanningPoint_DfEnc(pstruAsnIARData->currentPos,
                                              &(pstruWjIARData->strucurrentPos));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PathPlanningPoint_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnIARData->currentPos = NULL;
    }

    if (WJV2_PRESENT == pstruWjIARData->u8path_PlanningPresent)
    {
        pstruAsnIARData->path_Planning = CALLOC(1, sizeof(struct PathPlanning));
        if (NULL == pstruAsnIARData->path_Planning)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PathPlanning_DfEnc(pstruAsnIARData->path_Planning,
                                         &(pstruWjIARData->strupath_Planning));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PathPlanning_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnIARData->path_Planning = NULL;
    }

    if (WJV2_PRESENT == pstruWjIARData->u8currentBehaviorPresent)
    {
        pstruAsnIARData->currentBehavior = CALLOC(1, sizeof(DriveBehavior_t));
        if (NULL == pstruAsnIARData->currentBehavior)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_DriveBehavior_DeEnc(pstruAsnIARData->currentBehavior,
                                          &(pstruWjIARData->bitcurrentBehavior));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DriveBehavior_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnIARData->currentBehavior = NULL;
    }

    if (WJV2_PRESENT == pstruWjIARData->u8reqsPresent)
    {
        pstruAsnIARData->reqs = CALLOC(1, sizeof(struct reqs));
        if (NULL == pstruAsnIARData->reqs)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_reqsList_DfEnc(pstruAsnIARData->reqs,
                                     &(pstruWjIARData->strureqs));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_reqsList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnIARData->reqs = NULL;
    }

    return true;
}
/**
* @brief     WJV2_IARData_DfDec解码函数
* @details   协议栈���解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_IARData_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    IARData_t *pstruAsnIARData = (IARData_t *)pvoidAsnDf;
    WJV2_STRU_IARData *pstruWjIARData = (WJV2_STRU_IARData *)pvoidWjDf;
    int32_t n32Ret = 0;

    if (NULL != pstruAsnIARData->currentPos)
    {
        n32Ret = WJV2_PathPlanningPoint_DfDec(pstruAsnIARData->currentPos,
                                              &(pstruWjIARData->strucurrentPos));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PathPlanningPoint_DfEnc is err");
            return false;
        }
        pstruWjIARData->u8currentPosPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjIARData->u8currentPosPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnIARData->path_Planning)
    {
        n32Ret = WJV2_PathPlanning_DfDec(pstruAsnIARData->path_Planning,
                                         &(pstruWjIARData->strupath_Planning));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PathPlanning_DfDec is err");
            return false;
        }
        pstruWjIARData->u8path_PlanningPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjIARData->u8path_PlanningPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnIARData->currentBehavior)
    {
        n32Ret = WJV2_DriveBehavior_DeDec(pstruAsnIARData->currentBehavior,
                                          &(pstruWjIARData->bitcurrentBehavior));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DriveBehavior_DeDec is err");
            return false;
        }
        pstruWjIARData->u8currentBehaviorPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjIARData->u8currentBehaviorPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnIARData->reqs)
    {
        n32Ret = WJV2_reqsList_DfDec(pstruAsnIARData->reqs,
                                     &(pstruWjIARData->strureqs));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_reqsList_DfDec is err");
            return false;
        }
        pstruWjIARData->u8reqsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjIARData->u8reqsPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_LaneCoordination_DfEnc编码函数
* @details   协议栈LaneCoordination编解码中 统一LaneCoordination的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_LaneCoordination_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    LaneCoordination_t *pstruAsnLaneCoordination = (LaneCoordination_t *)pvoidAsnDf;
    WJV2_STRU_LaneCoordination *pstruWjLaneCoordination = (WJV2_STRU_LaneCoordination *)pvoidWjDf;
    int32_t n32Ret = 0;

    n32Ret = WJV2_ReferenceLink_DfEnc(&pstruAsnLaneCoordination->targetLane,
                                      &(pstruWjLaneCoordination->strutargetLane));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_ReferenceLink_DfEnc is err");
        return false;
    }

    if (WJV2_PRESENT == pstruWjLaneCoordination->u8relatedPathPresent)
    {
        pstruAsnLaneCoordination->relatedPath = CALLOC(1, sizeof(struct ReferencePath));
        if (NULL == pstruAsnLaneCoordination->relatedPath)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ReferencePath_DfEnc(pstruAsnLaneCoordination->relatedPath,
                                          &(pstruWjLaneCoordination->strurelatedPath));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferencePath_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLaneCoordination->relatedPath = NULL;
    }

    if (WJV2_PRESENT == pstruWjLaneCoordination->u8tBeginPresent)
    {
        pstruAsnLaneCoordination->tBegin = CALLOC(1, sizeof(struct DDateTime));
        if (NULL == pstruAsnLaneCoordination->tBegin)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_DDateTime_DfEnc(pstruAsnLaneCoordination->tBegin,
                                      &(pstruWjLaneCoordination->strutBegin));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DDateTime_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLaneCoordination->tBegin = NULL;
    }

    if (WJV2_PRESENT == pstruWjLaneCoordination->u8tEndPresent)
    {
        pstruAsnLaneCoordination->tEnd = CALLOC(1, sizeof(struct DDateTime));
        if (NULL == pstruAsnLaneCoordination->tEnd)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_DDateTime_DfEnc(pstruAsnLaneCoordination->tEnd,
                                      &(pstruWjLaneCoordination->strutEnd));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DDateTime_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLaneCoordination->tEnd = NULL;
    }

    if (WJV2_PRESENT == pstruWjLaneCoordination->u8recommendedSpeedPresent)
    {
        pstruAsnLaneCoordination->recommendedSpeed = CALLOC(1, sizeof(Speed_t));
        if (NULL == pstruAsnLaneCoordination->recommendedSpeed)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_SPEED_SIZE < pstruWjLaneCoordination->n32recommendedSpeed) ||
            (WJV2_MIN_SPEED_SIZE > pstruWjLaneCoordination->n32recommendedSpeed))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjLaneCoordination->n32recommendedSpeed = %d",
                     pstruWjLaneCoordination->n32recommendedSpeed);
            return false;
        }
        *(pstruAsnLaneCoordination->recommendedSpeed) = pstruWjLaneCoordination->n32recommendedSpeed;
    }
    else
    {
        pstruAsnLaneCoordination->recommendedSpeed = NULL;
    }

    if (WJV2_PRESENT == pstruWjLaneCoordination->u8recommendedBehaviorPresent)
    {
        pstruAsnLaneCoordination->recommendedBehavior = CALLOC(1, sizeof(DriveBehavior_t));
        if (NULL == pstruAsnLaneCoordination->recommendedBehavior)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_DriveBehavior_DeEnc(pstruAsnLaneCoordination->recommendedBehavior,
                                          &(pstruWjLaneCoordination->bitrecommendedBehavior));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DriveBehavior_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLaneCoordination->recommendedBehavior = NULL;
    }

    if (WJV2_PRESENT == pstruWjLaneCoordination->u8infoPresent)
    {
        pstruAsnLaneCoordination->info = CALLOC(1, sizeof(CoordinationInfo_t));
        if (NULL == pstruAsnLaneCoordination->info)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_CoordinationInfo_DeEnc(pstruAsnLaneCoordination->info,
                                             &(pstruWjLaneCoordination->bitinfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_CoordinationInfo_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLaneCoordination->info = NULL;
    }

    if (WJV2_PRESENT == pstruWjLaneCoordination->u8descriptionPresent)
    {
        pstruAsnLaneCoordination->description = CALLOC(1, sizeof(struct Description));
        if (NULL == pstruAsnLaneCoordination->description)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_Description_DfEnc(pstruAsnLaneCoordination->description,
                                        &(pstruWjLaneCoordination->strudescription));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Description_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLaneCoordination->description = NULL;
    }

    return true;
}
/**
* @brief     WJV2_LaneCoordination_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_LaneCoordination_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    LaneCoordination_t *pstruAsnLaneCoordination = (LaneCoordination_t *)pvoidAsnDf;
    WJV2_STRU_LaneCoordination *pstruWjLaneCoordination = (WJV2_STRU_LaneCoordination *)pvoidWjDf;
    int32_t n32Ret = 0;

    n32Ret = WJV2_ReferenceLink_DfDec(&pstruAsnLaneCoordination->targetLane,
                                      &(pstruWjLaneCoordination->strutargetLane));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_ReferenceLink_DfDec is err");
        return false;
    }

    if (NULL != pstruAsnLaneCoordination->relatedPath)
    {
        n32Ret = WJV2_ReferencePath_DfDec(pstruAsnLaneCoordination->relatedPath,
                                          &(pstruWjLaneCoordination->strurelatedPath));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferencePath_DfDec is err");
            return false;
        }
        pstruWjLaneCoordination->u8relatedPathPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLaneCoordination->u8relatedPathPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnLaneCoordination->tBegin)
    {
        n32Ret = WJV2_DDateTime_DfDec(pstruAsnLaneCoordination->tBegin,
                                      &(pstruWjLaneCoordination->strutBegin));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DDateTime_DfDec is err");
            return false;
        }
        pstruWjLaneCoordination->u8tBeginPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLaneCoordination->u8tBeginPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnLaneCoordination->tEnd)
    {
        n32Ret = WJV2_DDateTime_DfDec(pstruAsnLaneCoordination->tEnd,
                                      &(pstruWjLaneCoordination->strutEnd));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DDateTime_DfDec is err");
            return false;
        }
        pstruWjLaneCoordination->u8tEndPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLaneCoordination->u8tEndPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnLaneCoordination->recommendedSpeed)
    {
        if ((WJV2_MAX_SPEED_SIZE < *(pstruAsnLaneCoordination->recommendedSpeed)) ||
            (WJV2_MIN_SPEED_SIZE > *(pstruAsnLaneCoordination->recommendedSpeed)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnLaneCoordination->recommendedSpeed) = %d",
                     *(pstruAsnLaneCoordination->recommendedSpeed));
            return false;
        }
        pstruWjLaneCoordination->n32recommendedSpeed = *(pstruAsnLaneCoordination->recommendedSpeed);
        pstruWjLaneCoordination->u8recommendedSpeedPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLaneCoordination->u8recommendedSpeedPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnLaneCoordination->recommendedBehavior)
    {
        n32Ret = WJV2_DriveBehavior_DeDec(pstruAsnLaneCoordination->recommendedBehavior,
                                          &(pstruWjLaneCoordination->bitrecommendedBehavior));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DriveBehavior_DeDec is err");
            return false;
        }
        pstruWjLaneCoordination->u8recommendedBehaviorPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLaneCoordination->u8recommendedBehaviorPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnLaneCoordination->info)
    {
        n32Ret = WJV2_CoordinationInfo_DeDec(pstruAsnLaneCoordination->info,
                                             &(pstruWjLaneCoordination->bitinfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_CoordinationInfo_DeDec is err");
            return false;
        }
        pstruWjLaneCoordination->u8infoPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLaneCoordination->u8infoPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnLaneCoordination->description)
    {
        n32Ret = WJV2_Description_DfDec(pstruAsnLaneCoordination->description,
                                        &(pstruWjLaneCoordination->strudescription));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Description_DfDec is err");
            return false;
        }
        pstruWjLaneCoordination->u8descriptionPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLaneCoordination->u8descriptionPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_LaneEx_DfEnc编码函数
* @details   协议栈LaneEx编解码中 统一LaneEx的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_LaneEx_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    WJV2_STRU_LaneEx *pstruWjLaneEx = (WJV2_STRU_LaneEx *)pvoidWjDf;
    LaneEx_t *pstruAsnLaneEx = (LaneEx_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_LaneRefID_SIZE < pstruWjLaneEx->n32laneRefID) || (WJV2_MIN_LaneRefID_SIZE > pstruWjLaneEx->n32laneRefID))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjLaneEx->n32laneRefID = %d",
                 pstruWjLaneEx->n32laneRefID);
        return false;
    }
    pstruAsnLaneEx->laneRefID = pstruWjLaneEx->n32laneRefID;
    if (WJV2_PRESENT == pstruWjLaneEx->u8laneWidthPresent)
    {
        pstruAsnLaneEx->laneWidth = CALLOC(1, sizeof(LaneWidth_t));
        if (NULL == pstruAsnLaneEx->laneWidth)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        if ((WJV2_MAX_LANEWIDTH_SIZE < pstruWjLaneEx->n32laneWidth) || (WJV2_MIN_LANEWIDTH_SIZE > pstruWjLaneEx->n32laneWidth))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjLaneEx->n32laneWidth = %d",
                     pstruWjLaneEx->n32laneWidth);
            return false;
        }
        *(pstruAsnLaneEx->laneWidth) = pstruWjLaneEx->n32laneWidth;
    }
    else
    {
        pstruAsnLaneEx->laneWidth = NULL;
    }
    if (WJV2_PRESENT == pstruWjLaneEx->u8laneAttributesPresent)
    {
        pstruAsnLaneEx->laneAttributes = CALLOC(1, sizeof(struct LaneAttributes));
        if (NULL == pstruAsnLaneEx->laneAttributes)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        n32Ret = WJV2_LaneAttributes_DfEnc(pstruAsnLaneEx->laneAttributes, &(pstruWjLaneEx->strulaneAttributes));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneAttributes_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLaneEx->laneAttributes = NULL;
    }
    if (WJV2_PRESENT == pstruWjLaneEx->u8maneuversPresent)
    {
        pstruAsnLaneEx->maneuvers = CALLOC(1, sizeof(AllowedManeuvers_t));
        if (NULL == pstruAsnLaneEx->maneuvers)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        n32Ret = WJV2_AllowedManeuvers_DeEnc(pstruAsnLaneEx->maneuvers, &(pstruWjLaneEx->bitmaneuvers));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AllowedManeuvers_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLaneEx->maneuvers = NULL;
    }
    if (WJV2_PRESENT == pstruWjLaneEx->u8connectsTo_exPresent)
    {
        pstruAsnLaneEx->connectsTo_ex = CALLOC(1, sizeof(struct ConnectsToExList));
        if (NULL == pstruAsnLaneEx->connectsTo_ex)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        n32Ret = WJV2_ConnectsToExList_DfEnc(pstruAsnLaneEx->connectsTo_ex, &(pstruWjLaneEx->struconnectsTo_ex));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ConnectsToExList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLaneEx->connectsTo_ex = NULL;
    }
    if (WJV2_PRESENT == pstruWjLaneEx->u8speedLimitsPresent)
    {
        pstruAsnLaneEx->speedLimits = CALLOC(1, sizeof(struct SpeedLimitList));
        if (NULL == pstruAsnLaneEx->speedLimits)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        n32Ret = WJV2_SpeedLimitList_DfEnc(pstruAsnLaneEx->speedLimits, &(pstruWjLaneEx->struspeedLimits));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_SpeedLimitList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLaneEx->speedLimits = NULL;
    }

    if (WJV2_PRESENT == pstruWjLaneEx->u8st_pointsPresent)
    {
        pstruAsnLaneEx->st_points = CALLOC(1, sizeof(struct STPointList));
        if (NULL == pstruAsnLaneEx->st_points)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        n32Ret = WJV2_STPointList_DfEnc(pstruAsnLaneEx->st_points, &(pstruWjLaneEx->strust_points));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_STPointList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLaneEx->st_points = NULL;
    }

    if (WJV2_PRESENT == pstruWjLaneEx->u8laneLineTypePresent)
    {
        pstruAsnLaneEx->laneLineType = CALLOC(1, sizeof(struct LaneLineType));
        if (NULL == pstruAsnLaneEx->laneLineType)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }
        n32Ret = WJV2_LaneLineType_DfEnc(pstruAsnLaneEx->laneLineType, &(pstruWjLaneEx->strulaneLineType));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_laneLineType_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLaneEx->laneLineType = NULL;
    }

    return true;
}
/**
* @brief     WJV2_LaneEx_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_LaneEx_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    WJV2_STRU_LaneEx *pstruWjLaneEx = (WJV2_STRU_LaneEx *)pvoidWjDf;
    LaneEx_t *pstruAsnLaneEx = (LaneEx_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_LaneRefID_SIZE < pstruAsnLaneEx->laneRefID) || (WJV2_MIN_LaneRefID_SIZE > pstruAsnLaneEx->laneRefID))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnLaneEx->laneRefID = %d",
                 pstruAsnLaneEx->laneRefID);
        return false;
    }
    pstruWjLaneEx->n32laneRefID = pstruAsnLaneEx->laneRefID;
    if (NULL != pstruAsnLaneEx->laneWidth)
    {
        if ((WJV2_MAX_LANEWIDTH_SIZE < *(pstruAsnLaneEx->laneWidth)) || (WJV2_MIN_LANEWIDTH_SIZE > *(pstruAsnLaneEx->laneWidth)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnLaneEx->laneWidth) = %d",
                     *(pstruAsnLaneEx->laneWidth));
            return false;
        }
        pstruWjLaneEx->n32laneWidth = *(pstruAsnLaneEx->laneWidth);
        pstruWjLaneEx->u8laneWidthPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLaneEx->u8laneWidthPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnLaneEx->laneAttributes)
    {
        n32Ret = WJV2_LaneAttributes_DfDec(pstruAsnLaneEx->laneAttributes, &(pstruWjLaneEx->strulaneAttributes));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneAttributes_DfDec is err");
            return false;
        }
        pstruWjLaneEx->u8laneAttributesPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLaneEx->u8laneAttributesPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnLaneEx->maneuvers)
    {
        n32Ret = WJV2_AllowedManeuvers_DeDec(pstruAsnLaneEx->maneuvers, &(pstruWjLaneEx->bitmaneuvers));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AllowedManeuvers_DeDec is err");
            return false;
        }
        pstruWjLaneEx->u8maneuversPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLaneEx->u8maneuversPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnLaneEx->connectsTo_ex)
    {
        n32Ret = WJV2_ConnectsToExList_DfDec(pstruAsnLaneEx->connectsTo_ex, &(pstruWjLaneEx->struconnectsTo_ex));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ConnectsToExList_DfDec is err");
            return false;
        }
        pstruWjLaneEx->u8connectsTo_exPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLaneEx->u8connectsTo_exPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnLaneEx->speedLimits)
    {
        n32Ret = WJV2_SpeedLimitList_DfDec(pstruAsnLaneEx->speedLimits, &(pstruWjLaneEx->struspeedLimits));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_SpeedLimitList_DfDec is err");
            return false;
        }
        pstruWjLaneEx->u8speedLimitsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLaneEx->u8speedLimitsPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnLaneEx->st_points)
    {
        n32Ret = WJV2_PointList_DfDec(pstruAsnLaneEx->st_points, &(pstruWjLaneEx->strust_points));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PointList_DfDec is err");
            return false;
        }
        pstruWjLaneEx->u8st_pointsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLaneEx->u8st_pointsPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnLaneEx->laneLineType)
    {
        n32Ret = WJV2_LaneLineType_DfDec(pstruAsnLaneEx->laneLineType, &(pstruWjLaneEx->strulaneLineType));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneLineType_DfDec is err");
            return false;
        }
        pstruWjLaneEx->u8laneLineTypePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLaneEx->u8laneLineTypePresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_LaneExList_DfEnc编码函数
* @details   协议栈LaneExList编解码中 统一LaneExList的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_LaneExList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_LaneExList *pstruWjLaneExList = (WJV2_STRU_LaneExList *)pvoidWjDf;
    LaneExList_t *pstruAsnLaneExList = (LaneExList_t *)pvoidAsnDf;
    LaneEx_t *pstruLaneEx_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_LaneEx_LEN < pstruWjLaneExList->u8LaneExNum) ||
        (WJV2_MAX_LIST_LaneEx_LEN > pstruWjLaneExList->u8LaneExNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjLaneExList->u8LaneExNum = %d",
                 pstruWjLaneExList->u8LaneExNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjLaneExList->u8LaneExNum; u32i++)
    {
        pstruLaneEx_node = CALLOC(1, sizeof(LaneEx_t));
        if (NULL == pstruLaneEx_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_LaneEx_DfEnc(pstruLaneEx_node, &(pstruWjLaneExList->struLaneEx[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneEx_DfEnc is err");
            FREEMEM(pstruLaneEx_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnLaneExList->list), pstruLaneEx_node);
    }
    return true;
}
/**
* @brief     WJV2_LaneExList_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_LaneExList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    WJV2_STRU_LaneExList *pstruWjLaneExList = (WJV2_STRU_LaneExList *)pvoidWjDf;
    LaneExList_t *pstruAsnLaneExList = (LaneExList_t *)pvoidAsnDf;

    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_LaneEx_LEN < pstruAsnLaneExList->list.count) ||
        (WJV2_MAX_LIST_LaneEx_LEN > pstruAsnLaneExList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnLaneExList->list.count = %d",
                 pstruAsnLaneExList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnLaneExList->list.count; u32i++)
    {
        n32Ret = WJV2_LaneEx_DfDec(pstruAsnLaneExList->list.array[u32i],
                                   &(pstruWjLaneExList->struLaneEx[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneEx_DfDec is err");
            return false;
        }
    }
    pstruWjLaneExList->u8LaneExNum = (uint8_t)u32i;

    return true;
}
/**
* @brief     WJV2_LaneLineType_DfEnc编码函数
* @details   协议栈LaneLineType编解码中 统一LaneLineType的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_LaneLineType_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    LaneLineType_t *pstruAsnLaneLineType = (LaneLineType_t *)pvoidAsnDf;
    WJV2_STRU_LaneLineType *pstruWjLaneLineType = (WJV2_STRU_LaneLineType *)pvoidWjDf;

    pstruAsnLaneLineType->leftLaneLine = pstruWjLaneLineType->enumleftLaneLine;
    pstruAsnLaneLineType->rightLaneLine = pstruWjLaneLineType->enumrightLaneLine;

    return true;
}
/**
* @brief     WJV2_LaneLineType_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_LaneLineType_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    LaneLineType_t *pstruAsnLaneLineType = (LaneLineType_t *)pvoidAsnDf;
    WJV2_STRU_LaneLineType *pstruWjLaneLineType = (WJV2_STRU_LaneLineType *)pvoidWjDf;

    pstruWjLaneLineType->enumleftLaneLine = pstruAsnLaneLineType->leftLaneLine;
    pstruWjLaneLineType->enumrightLaneLine = pstruAsnLaneLineType->rightLaneLine;

    return true;
}
/**
* @brief     WJV2_LinkEx_DfEnc编码函数
* @details   协议栈LinkEx编解码中 统一LinkEx的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_LinkEx_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    WJV2_STRU_LinkEx *pstruWjLinkEx = (WJV2_STRU_LinkEx *)pvoidWjDf;
    LinkEx_t *pstruAsnLinkEx = (LinkEx_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (WJV2_PRESENT == pstruWjLinkEx->u8namePresent)
    {
        pstruAsnLinkEx->name = CALLOC(1, sizeof(DescriptiveName_t));
        if (NULL == pstruAsnLinkEx->name)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_DescriptiveName_DeEnc(pstruAsnLinkEx->name, &(pstruWjLinkEx->strname));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DescriptiveName_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLinkEx->name = NULL;
    }
    n32Ret = WJV2_NodeReferenceID_DfEnc(&(pstruAsnLinkEx->upstreamNodeId), &(pstruWjLinkEx->struupstreamNodeId));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfEnc is err");
        return false;
    }
    if (WJV2_PRESENT == pstruWjLinkEx->u8speedLimitsPresent)
    {
        pstruAsnLinkEx->speedLimits = CALLOC(1, sizeof(struct SpeedLimitList));
        if (NULL == pstruAsnLinkEx->speedLimits)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_SpeedLimitList_DfEnc(pstruAsnLinkEx->speedLimits, &(pstruWjLinkEx->struspeedLimits));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_SpeedLimitList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLinkEx->speedLimits = NULL;
    }

    if (WJV2_PRESENT == pstruWjLinkEx->u8linkWidthPresent)
    {
        pstruAsnLinkEx->linkWidth = CALLOC(1, sizeof(LaneWidth_t));
        if (NULL == pstruAsnLinkEx->linkWidth)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_LANEWIDTH_SIZE < pstruWjLinkEx->n32linkWidth) || (WJV2_MIN_LANEWIDTH_SIZE > pstruWjLinkEx->n32linkWidth))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjLinkEx->n32linkWidth = %d",
                     pstruWjLinkEx->n32linkWidth);
            return false;
        }
        *(pstruAsnLinkEx->linkWidth) = pstruWjLinkEx->n32linkWidth;
    }
    else
    {
        pstruAsnLinkEx->linkWidth = NULL;
    }
    if (WJV2_PRESENT == pstruWjLinkEx->u8refLinePresent)
    {
        pstruAsnLinkEx->refLine = CALLOC(1, sizeof(struct PointList));
        if (NULL == pstruAsnLinkEx->refLine)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PointList_DfEnc(pstruAsnLinkEx->refLine, &(pstruWjLinkEx->strurefLine));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PointList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLinkEx->refLine = NULL;
    }
    if (WJV2_PRESENT == pstruWjLinkEx->u8movements_exPresent)
    {
        pstruAsnLinkEx->movements_ex = CALLOC(1, sizeof(struct MovementExList));
        if (NULL == pstruAsnLinkEx->movements_ex)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_MovementExList_DfEnc(pstruAsnLinkEx->movements_ex, &(pstruWjLinkEx->strumovements_ex));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_MovementExList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnLinkEx->movements_ex = NULL;
    }
    n32Ret = WJV2_SectionList_DfEnc(&(pstruAsnLinkEx->sections), &(pstruWjLinkEx->strusections));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_SectionList_DfEnc is err");
        return false;
    }

    return true;
}
/**
* @brief     WJV2_LinkEx_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_LinkEx_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_LinkEx *pstruWjLinkEx = (WJV2_STRU_LinkEx *)pvoidWjDf;
    LinkEx_t *pstruAsnLinkEx = (LinkEx_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (NULL != pstruAsnLinkEx->name)
    {
        n32Ret = WJV2_DescriptiveName_DeDec(pstruAsnLinkEx->name, &(pstruWjLinkEx->strname));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DescriptiveName_DeDec is err");
            return false;
        }
        pstruWjLinkEx->u8namePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLinkEx->u8namePresent = WJV2_ABSENT;
    }
    n32Ret = WJV2_NodeReferenceID_DfDec(&(pstruAsnLinkEx->upstreamNodeId), &(pstruWjLinkEx->struupstreamNodeId));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfDec is err");
        return false;
    }
    if (NULL != pstruAsnLinkEx->speedLimits)
    {
        n32Ret = WJV2_SpeedLimitList_DfDec(pstruAsnLinkEx->speedLimits, &(pstruWjLinkEx->struspeedLimits));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_SpeedLimitList_DfDec is err");
            return false;
        }
        pstruWjLinkEx->u8speedLimitsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLinkEx->u8speedLimitsPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnLinkEx->linkWidth)
    {
        if ((WJV2_MAX_LANEWIDTH_SIZE < *pstruAsnLinkEx->linkWidth) ||
            (WJV2_MIN_LANEWIDTH_SIZE > *pstruAsnLinkEx->linkWidth))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*pstruAsnLinkEx->linkWidth = %d",
                     *pstruAsnLinkEx->linkWidth);
            return false;
        }
        pstruWjLinkEx->n32linkWidth = *pstruAsnLinkEx->linkWidth;
        pstruWjLinkEx->u8speedLimitsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLinkEx->u8speedLimitsPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnLinkEx->refLine)
    {
        n32Ret = WJV2_PointList_DfDec(pstruAsnLinkEx->refLine, &(pstruWjLinkEx->strurefLine));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PointList_DfDec is err");
            return false;
        }
        pstruWjLinkEx->u8refLinePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLinkEx->u8refLinePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnLinkEx->movements_ex)
    {
        n32Ret = WJV2_MovementExList_DfDec(pstruAsnLinkEx->movements_ex, &(pstruWjLinkEx->strumovements_ex));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_MovementExList_DfDec is err");
            return false;
        }
        pstruWjLinkEx->u8movements_exPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjLinkEx->u8movements_exPresent = WJV2_ABSENT;
    }
    n32Ret = WJV2_SectionList_DfDec(&(pstruAsnLinkEx->sections), &(pstruWjLinkEx->strusections));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_SectionList_DfDec is err");
        return false;
    }
    return true;
}
/**
* @brief     WJV2_LinkExList_DfEnc编码函数
* @details   协议栈LinkExList编解码中 统一LinkExList的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_LinkExList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    WJV2_STRU_LinkExList *pstruWjLinkExList = (WJV2_STRU_LinkExList *)pvoidWjDf;
    LinkExList_t *pstruAsnLinkExList = (LinkExList_t *)pvoidAsnDf;
    LinkEx_t *pstruLinkEx_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_LinkEx_LEN < pstruWjLinkExList->u8LinkExNum) || (WJV2_MIN_LIST_LinkEx_LEN > pstruWjLinkExList->u8LinkExNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjLinkExList->u8LinkNum = %d",
                 pstruWjLinkExList->u8LinkExNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjLinkExList->u8LinkExNum; u32i++)
    {
        pstruLinkEx_node = CALLOC(1, sizeof(LinkEx_t));
        if (NULL == pstruLinkEx_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_LinkEx_DfEnc(pstruLinkEx_node, &(pstruWjLinkExList->struLinkEx[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LinkEx_DfEnc is err");
            FREEMEM(pstruLinkEx_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnLinkExList->list), pstruLinkEx_node);
    }
    return true;
}
/**
* @brief     WJV2_LinkExList_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_LinkExList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_LinkExList *pstruWjLinkExList = (WJV2_STRU_LinkExList *)pvoidWjDf;
    LinkExList_t *pstruAsnLinkExList = (LinkExList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_LinkEx_LEN < pstruAsnLinkExList->list.count) || (WJV2_MIN_LIST_LinkEx_LEN > pstruAsnLinkExList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnLinkExList->list.count = %d",
                 pstruAsnLinkExList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnLinkExList->list.count; u32i++)
    {
        n32Ret = WJV2_LinkEx_DfDec(pstruAsnLinkExList->list.array[u32i],
                                   &(pstruWjLinkExList->struLinkEx[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LinkEx_DfDec is err");
            return false;
        }
    }
    pstruWjLinkExList->u8LinkExNum = (uint8_t)u32i;
    return true;
}
/**
* @brief     WJV2_MemberList_DfEnc编码函数
* @details   协议栈MemberList编解码中 统一MemberList的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_MemberList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_MemberList *pstruWjMemberList = (WJV2_STRU_MemberList *)pvoidWjDf;
    MemberList_t *pstruAsnMemberList = (MemberList_t *)pvoidAsnDf;
    MemberNode_t *pstruMember_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_Member_LEN < pstruWjMemberList->u8MemberNodeNum) ||
        (WJV2_MIN_LIST_Member_LEN > pstruWjMemberList->u8MemberNodeNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjMemberList->u8MemberNodeNum = %d",
                 pstruWjMemberList->u8MemberNodeNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjMemberList->u8MemberNodeNum; u32i++)
    {
        pstruMember_node = CALLOC(1, sizeof(MemberNode_t));
        if (NULL == pstruMember_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_MemberNode_DfEnc(pstruMember_node, &(pstruWjMemberList->struMember[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_MemberNode_DfEnc is err");
            FREEMEM(pstruMember_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnMemberList->list), pstruMember_node);
    }
    return true;
}
/**
* @brief     WJV2_MemberList_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_MemberList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_MemberList *pstruWjMemberList = (WJV2_STRU_MemberList *)pvoidWjDf;
    MemberList_t *pstruAsnMemberList = (MemberList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_Member_LEN < pstruAsnMemberList->list.count) || (WJV2_MIN_LIST_Member_LEN > pstruAsnMemberList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnMemberList->list.count = %d",
                 pstruAsnMemberList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnMemberList->list.count; u32i++)
    {
        n32Ret = WJV2_MemberNode_DfDec(pstruAsnMemberList->list.array[u32i],
                                       &(pstruWjMemberList->struMember[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_MemberNode_DfDec is err");
            return false;
        }
    }
    pstruWjMemberList->u8MemberNodeNum = (uint8_t)u32i;
    return true;
}
/**
* @brief     WJV2_MemberManagement_DfEnc编码函数
* @details   协议栈MemberManagement编解码中 统一MemberManagement的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_MemberManagement_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_MemberManagement *pstruWjMemberManagement = (WJV2_STRU_MemberManagement *)pvoidWjDf;
    MemberManagement_t *pstruAsnMemberManagement = (MemberManagement_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_MemberList_DfEnc(&pstruAsnMemberManagement->memberList,
                                   &(pstruWjMemberManagement->strumemberList));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_MemberList_DfEnc is err");
        return false;
    }
    if (WJV2_PRESENT == pstruWjMemberManagement->u8joiningListPresent)
    {
        pstruAsnMemberManagement->joiningList = CALLOC(1, sizeof(MemberList_t));
        if (NULL == pstruAsnMemberManagement->joiningList)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_MemberList_DfEnc(pstruAsnMemberManagement->joiningList,
                                       &(pstruWjMemberManagement->strujoiningList));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_MemberList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnMemberManagement->joiningList = NULL;
    }

    if (WJV2_PRESENT == pstruWjMemberManagement->u8leavingListPresent)
    {
        pstruAsnMemberManagement->leavingList = CALLOC(1, sizeof(MemberList_t));
        if (NULL == pstruAsnMemberManagement->leavingList)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_MemberList_DfEnc(pstruAsnMemberManagement->leavingList,
                                       &(pstruWjMemberManagement->struleavingList));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_MemberList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnMemberManagement->leavingList = NULL;
    }
    if ((WJV2_MAX_capacity_SIZE < pstruWjMemberManagement->n32capacity) ||
        (WJV2_MIN_capacity_SIZE > pstruWjMemberManagement->n32capacity))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth: pstruWjMemberManagement->n32capacity = %d",
                 pstruWjMemberManagement->n32capacity);
        return false;
    }
    pstruAsnMemberManagement->capacity = pstruWjMemberManagement->n32capacity;
    pstruAsnMemberManagement->openToJoin = pstruWjMemberManagement->n32openToJoin;

    return true;
}
/**
* @brief     WJV2_MemberManagement_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_MemberManagement_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_MemberManagement *pstruWjMemberManagement = (WJV2_STRU_MemberManagement *)pvoidWjDf;
    MemberManagement_t *pstruAsnMemberManagement = (MemberManagement_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_MemberList_DfDec(&pstruAsnMemberManagement->memberList,
                                   &(pstruWjMemberManagement->strumemberList));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_MemberList_DfDec is err");
        return false;
    }
    if (NULL != pstruAsnMemberManagement->joiningList)
    {

        n32Ret = WJV2_MemberList_DfDec(pstruAsnMemberManagement->joiningList,
                                       &(pstruWjMemberManagement->strujoiningList));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_MemberList_DfDec is err");
            return false;
        }
        pstruWjMemberManagement->u8joiningListPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjMemberManagement->u8joiningListPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnMemberManagement->leavingList)
    {

        n32Ret = WJV2_MemberList_DfDec(pstruAsnMemberManagement->leavingList,
                                       &(pstruWjMemberManagement->struleavingList));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_MemberList_DfDec is err");
            return false;
        }
        pstruWjMemberManagement->u8leavingListPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjMemberManagement->u8leavingListPresent = WJV2_ABSENT;
    }
    if ((WJV2_MAX_capacity_SIZE < pstruAsnMemberManagement->capacity) ||
        (WJV2_MIN_capacity_SIZE > pstruAsnMemberManagement->capacity))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth: pstruAsnMemberManagement->capacity = %d",
                 pstruAsnMemberManagement->capacity);
        return false;
    }
    pstruWjMemberManagement->n32capacity = pstruAsnMemberManagement->capacity;
    pstruWjMemberManagement->n32openToJoin = pstruAsnMemberManagement->openToJoin;
    return true;
}
/**
* @brief     WJV2_MemberNode_DfEnc编码函数
* @details   协议栈MemberNode编解码中 统一MemberNode的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_MemberNode_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_MemberNode *pstruWjMemberNode = (WJV2_STRU_MemberNode *)pvoidWjDf;
    MemberNode_t *pstruAsnMemberNode = (MemberNode_t *)pvoidAsnDf;
    if ((WJV2_MAX_OCTvid_SIZE != pstruWjMemberNode->u8OCTvidNum) /*||
        (1 > pstruWjMemberNode->u8OCTvidNum)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjMemberNode->u8OCTvidNum = %d",
                 pstruWjMemberNode->u8OCTvidNum);
        return false;
    }

    pstruAsnMemberNode->vid.size = pstruWjMemberNode->u8OCTvidNum;
    pstruAsnMemberNode->vid.buf = CALLOC(pstruAsnMemberNode->vid.size, sizeof(uint8_t));
    if (NULL == pstruAsnMemberNode->vid.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruAsnMemberNode->vid.buf, pstruWjMemberNode->u8OCTvid, pstruAsnMemberNode->vid.size);
    return true;
}
/**
* @brief     WJV2_MemberNode_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_MemberNode_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_MemberNode *pstruWjMemberNode = (WJV2_STRU_MemberNode *)pvoidWjDf;
    MemberNode_t *pstruAsnMemberNode = (MemberNode_t *)pvoidAsnDf;
    if ((WJV2_MAX_OCTvid_SIZE != pstruAsnMemberNode->vid.size) /*||
        (1 > pstruAsnMemberNode->vid.size)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnMemberNode->vid.size = %d",
                 pstruAsnMemberNode->vid.size);
        return false;
    }

    pstruWjMemberNode->u8OCTvidNum = pstruAsnMemberNode->vid.size;
    if (NULL != pstruAsnMemberNode->vid.buf)
    {
        memcpy(pstruWjMemberNode->u8OCTvid, pstruAsnMemberNode->vid.buf, pstruAsnMemberNode->vid.size);
    }

    return true;
}
/**
* @brief     WJV2_MotorDataExtension_DfEnc编码函数
* @details   协议栈MotorDataExtension编解码中 统一MotorDataExtension的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_MotorDataExtension_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_MotorDataExtension *pstruWjMotorDataExtension = (WJV2_STRU_MotorDataExtension *)pvoidWjDf;
    MotorDataExtension_t *pstruAsnMotorDataExtension = (MotorDataExtension_t *)pvoidAsnDf;
    int32_t n32Ret = 0;

    if (WJV2_PRESENT == pstruWjMotorDataExtension->u8lightsPresent)
    {
        pstruAsnMotorDataExtension->lights = CALLOC(1, sizeof(ExteriorLights_t));
        if (NULL == pstruAsnMotorDataExtension->lights)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ExteriorLights_DeEnc(pstruAsnMotorDataExtension->lights,
                                           &(pstruWjMotorDataExtension->bitlights));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ExteriorLights_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnMotorDataExtension->lights = NULL;
    }

    if (WJV2_PRESENT == pstruWjMotorDataExtension->u8vehAttitudePresent)
    {
        pstruAsnMotorDataExtension->vehAttitude = CALLOC(1, sizeof(struct Attitude));
        if (NULL == pstruAsnMotorDataExtension->vehAttitude)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_Attitude_DfEnc(pstruAsnMotorDataExtension->vehAttitude,
                                     &(pstruWjMotorDataExtension->struvehAttitude));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Attitude_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnMotorDataExtension->vehAttitude = NULL;
    }

    if (WJV2_PRESENT == pstruWjMotorDataExtension->u8vehAttitudeConfidencePresent)
    {
        pstruAsnMotorDataExtension->vehAttitudeConfidence = CALLOC(1, sizeof(struct AttitudeConfidence));
        if (NULL == pstruAsnMotorDataExtension->vehAttitudeConfidence)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_AttitudeConfidence_DfEnc(pstruAsnMotorDataExtension->vehAttitudeConfidence,
                                               &(pstruWjMotorDataExtension->struvehAttitudeConfidence));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AttitudeConfidence_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnMotorDataExtension->vehAttitudeConfidence = NULL;
    }

    if (WJV2_PRESENT == pstruWjMotorDataExtension->u8vehAngVelPresent)
    {
        pstruAsnMotorDataExtension->vehAngVel = CALLOC(1, sizeof(struct AngularVelocity));
        if (NULL == pstruAsnMotorDataExtension->vehAngVel)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_AngularVelocity_DfEnc(pstruAsnMotorDataExtension->vehAngVel,
                                            &(pstruWjMotorDataExtension->struvehAngVel));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AngularVelocity_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnMotorDataExtension->vehAngVel = NULL;
    }

    if (WJV2_PRESENT == pstruWjMotorDataExtension->u8vehAngVelConfidencePresent)
    {
        pstruAsnMotorDataExtension->vehAngVelConfidence = CALLOC(1, sizeof(struct AngularVelocityConfidence));
        if (NULL == pstruAsnMotorDataExtension->vehAngVelConfidence)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_AngularVelocityConfidence_DfEnc(pstruAsnMotorDataExtension->vehAngVelConfidence,
                                                      &(pstruWjMotorDataExtension->struvehAngVelConfidence));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AngularVelocityConfidence_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnMotorDataExtension->vehAngVelConfidence = NULL;
    }

    return true;
}
/**
* @brief     WJV2_MotorDataExtension_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_MotorDataExtension_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_MotorDataExtension *pstruWjMotorDataExtension = (WJV2_STRU_MotorDataExtension *)pvoidWjDf;
    MotorDataExtension_t *pstruAsnMotorDataExtension = (MotorDataExtension_t *)pvoidAsnDf;
    int32_t n32Ret = 0;

    if (NULL != pstruAsnMotorDataExtension->lights)
    {
        n32Ret = WJV2_ExteriorLights_DeDec(pstruAsnMotorDataExtension->lights,
                                           &(pstruWjMotorDataExtension->bitlights));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ExteriorLights_DeDec is err");
            return false;
        }
        pstruWjMotorDataExtension->u8lightsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjMotorDataExtension->u8lightsPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnMotorDataExtension->vehAttitude)
    {
        n32Ret = WJV2_Attitude_DfDec(pstruAsnMotorDataExtension->vehAttitude,
                                     &(pstruWjMotorDataExtension->struvehAttitude));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Attitude_DfDec is err");
            return false;
        }
        pstruWjMotorDataExtension->u8vehAttitudePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjMotorDataExtension->u8vehAttitudePresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnMotorDataExtension->vehAttitudeConfidence)
    {
        n32Ret = WJV2_AttitudeConfidence_DfDec(pstruAsnMotorDataExtension->vehAttitudeConfidence,
                                               &(pstruWjMotorDataExtension->struvehAttitudeConfidence));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AttitudeConfidence_DfDec is err");
            return false;
        }
        pstruWjMotorDataExtension->u8vehAttitudeConfidencePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjMotorDataExtension->u8vehAttitudeConfidencePresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnMotorDataExtension->vehAngVel)
    {
        n32Ret = WJV2_AngularVelocity_DfDec(pstruAsnMotorDataExtension->vehAngVel,
                                            &(pstruWjMotorDataExtension->struvehAngVel));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AngularVelocity_DfDec is err");
            return false;
        }
        pstruWjMotorDataExtension->u8vehAngVelPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjMotorDataExtension->u8vehAngVelPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnMotorDataExtension->vehAngVelConfidence)
    {
        n32Ret = WJV2_AngularVelocityConfidence_DfDec(pstruAsnMotorDataExtension->vehAngVelConfidence,
                                                      &(pstruWjMotorDataExtension->struvehAngVelConfidence));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AngularVelocityConfidence_DfDec is err");
            return false;
        }
        pstruWjMotorDataExtension->u8vehAngVelConfidencePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjMotorDataExtension->u8vehAngVelConfidencePresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_MovementEx_DfEnc编码函数
* @details   协议栈MovementEx编解码中 统一MovementEx的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_MovementEx_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_MovementEx *pstruWjMovementEx = (WJV2_STRU_MovementEx *)pvoidWjDf;
    MovementEx_t *pstruAsnMovementEx = (MovementEx_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_NodeReferenceID_DfEnc(&(pstruAsnMovementEx->remoteIntersection),
                                        &(pstruWjMovementEx->struremoteIntersection));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfEnc is err");
        return false;
    }
    if (WJV2_PRESENT == pstruWjMovementEx->u8phaseIdPresent)
    {
        pstruAsnMovementEx->phaseId = CALLOC(1, sizeof(PhaseID_t));
        if (NULL == pstruAsnMovementEx->phaseId)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_PHASEID_SIZE < pstruWjMovementEx->n32phaseId) ||
            (WJV2_MIN_PHASEID_SIZE > pstruWjMovementEx->n32phaseId))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjMovementEx->n32phaseId = %d",
                     pstruWjMovementEx->n32phaseId);
            return false;
        }
        *(pstruAsnMovementEx->phaseId) = pstruWjMovementEx->n32phaseId;
    }
    else
    {
        pstruAsnMovementEx->phaseId = NULL;
    }
    if (WJV2_PRESENT == pstruWjMovementEx->u8turn_directionPresent)
    {
        pstruAsnMovementEx->turn_direction = CALLOC(1, sizeof(Maneuver_t));
        if (NULL == pstruAsnMovementEx->turn_direction)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "calloc is err");
            return false;
        }

        *(pstruAsnMovementEx->turn_direction) = pstruWjMovementEx->enumturn_direction;
    }
    else
    {
        pstruAsnMovementEx->turn_direction = NULL;
    }
    return true;
}
/**
* @brief     WJV2_MovementEx_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_MovementEx_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_MovementEx *pstruWjMovementEx = (WJV2_STRU_MovementEx *)pvoidWjDf;
    MovementEx_t *pstruAsnMovementEx = (MovementEx_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_NodeReferenceID_DfDec(&(pstruAsnMovementEx->remoteIntersection),
                                        &(pstruWjMovementEx->struremoteIntersection));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfDec is err");
        return false;
    }
    if (NULL != pstruAsnMovementEx->phaseId)
    {

        if ((WJV2_MAX_PHASEID_SIZE < *(pstruAsnMovementEx->phaseId)) ||
            (WJV2_MIN_PHASEID_SIZE > *(pstruAsnMovementEx->phaseId)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnMovementEx->phaseId) = %d",
                     *(pstruAsnMovementEx->phaseId));
            return false;
        }
        pstruWjMovementEx->n32phaseId = *(pstruAsnMovementEx->phaseId);
        pstruWjMovementEx->u8phaseIdPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjMovementEx->u8phaseIdPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnMovementEx->turn_direction)
    {
        pstruWjMovementEx->enumturn_direction = *(pstruAsnMovementEx->turn_direction);
        pstruWjMovementEx->u8turn_directionPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjMovementEx->u8turn_directionPresent = WJV2_ABSENT;
    }
    return true;
}

/**
* @brief     WJV2_MovementExList_DfEnc编码函数
* @details   协议栈MovementExList编解码中 统一MovementExList的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_MovementExList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    WJV2_STRU_MovementExList *pstruWjMovementExList = (WJV2_STRU_MovementExList *)pvoidWjDf;
    MovementExList_t *pstruAsnMovementExList = (MovementExList_t *)pvoidAsnDf;
    MovementEx_t *pstruMovementEx_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_MOVEMENT_LEN < pstruWjMovementExList->u8MovementExNum) ||
        (WJV2_MIN_LIST_MOVEMENT_LEN > pstruWjMovementExList->u8MovementExNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjMovementExList->u8MovementExNum = %d",
                 pstruWjMovementExList->u8MovementExNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjMovementExList->u8MovementExNum; u32i++)
    {
        pstruMovementEx_node = CALLOC(1, sizeof(MovementEx_t));
        if (NULL == pstruMovementEx_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_MovementEx_DfEnc(pstruMovementEx_node, &(pstruWjMovementExList->struMovementEx[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Movement_DfEnc is err");
            FREEMEM(pstruMovementEx_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnMovementExList->list), pstruMovementEx_node);
    }

    return true;
}
/**
* @brief     WJV2_MovementExList_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_MovementExList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_MovementExList *pstruWjMovementExList = (WJV2_STRU_MovementExList *)pvoidWjDf;
    MovementExList_t *pstruAsnMovementExList = (MovementExList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_MovementEx_LEN < pstruAsnMovementExList->list.count) ||
        (WJV2_MIN_LIST_MovementEx_LEN > pstruAsnMovementExList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnMovementExList->list.count = %d",
                 pstruAsnMovementExList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnMovementExList->list.count; u32i++)
    {
        n32Ret = WJV2_MovementEx_DfDec(pstruAsnMovementExList->list.array[u32i],
                                       &(pstruWjMovementExList->struMovementEx[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Movement_DfDec is err");
            return false;
        }
    }
    pstruWjMovementExList->u8MovementExNum = (uint8_t)u32i;
    return true;
}
/**
* @brief     WJV2_NonMotorData_DfEnc编码函数
* @details   协议栈NonMotorData编解码中 统一NonMotorData的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_NonMotorData_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    Non_motorData_t *pstruAsnNonMotorData = (Non_motorData_t *)pvoidAsnDf;
    WJV2_STRU_Non_motorData *pstruWjNonMotorData = (WJV2_STRU_Non_motorData *)pvoidWjDf;
    int32_t n32Ret = 0;

    pstruAsnNonMotorData->basicType = pstruWjNonMotorData->enumbasicType;

    if (WJV2_PRESENT == pstruWjNonMotorData->u8propulsionPresent)
    {
        pstruAsnNonMotorData->propulsion = CALLOC(1, sizeof(struct PropelledInformation));
        if (NULL == pstruAsnNonMotorData->propulsion)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PropelledInformation_DfEnc(pstruAsnNonMotorData->propulsion,
                                                 &(pstruWjNonMotorData->strupropulsion));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PropelledInformation_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnNonMotorData->propulsion = NULL;
    }

    if (WJV2_PRESENT == pstruWjNonMotorData->u8clusterSizePresent)
    {
        pstruAsnNonMotorData->clusterSize = CALLOC(1, sizeof(NumberOfParticipantsInCluster_t));
        if (NULL == pstruAsnNonMotorData->clusterSize)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnNonMotorData->clusterSize = pstruWjNonMotorData->enumclusterSize;
    }
    else
    {
        pstruAsnNonMotorData->clusterSize = NULL;
    }

    if (WJV2_PRESENT == pstruWjNonMotorData->u8attachmentPresent)
    {
        pstruAsnNonMotorData->attachment = CALLOC(1, sizeof(Attachment_t));
        if (NULL == pstruAsnNonMotorData->attachment)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnNonMotorData->attachment = pstruWjNonMotorData->enumattachment;
    }
    else
    {
        pstruAsnNonMotorData->attachment = NULL;
    }

    if (WJV2_PRESENT == pstruWjNonMotorData->u8personalExtPresent)
    {
        pstruAsnNonMotorData->personalExt = CALLOC(1, sizeof(struct PersonalExtensions));
        if (NULL == pstruAsnNonMotorData->personalExt)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PersonalExtensions_DfEnc(pstruAsnNonMotorData->personalExt,
                                               &(pstruWjNonMotorData->strupersonalExt));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PersonalExtensions_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnNonMotorData->personalExt = NULL;
    }

    if (WJV2_PRESENT == pstruWjNonMotorData->u8roadWorkerExtPresent)
    {
        pstruAsnNonMotorData->roadWorkerExt = CALLOC(1, sizeof(struct RoadWorkerExtensions));
        if (NULL == pstruAsnNonMotorData->roadWorkerExt)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_RoadWorkerExtensions_DfEnc(pstruAsnNonMotorData->roadWorkerExt,
                                                 &(pstruWjNonMotorData->struroadWorkerExt));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RoadWorkerExtensions_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnNonMotorData->roadWorkerExt = NULL;
    }

    if (WJV2_PRESENT == pstruWjNonMotorData->u8personalReqPresent)
    {
        pstruAsnNonMotorData->personalReq = CALLOC(1, sizeof(struct PersonalRequest));
        if (NULL == pstruAsnNonMotorData->personalReq)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PersonalRequest_DfEnc(pstruAsnNonMotorData->personalReq,
                                            &(pstruWjNonMotorData->strupersonalReq));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PersonalRequest_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnNonMotorData->personalReq = NULL;
    }

    return true;
}
/**
* @brief     WJV2_NonMotorData_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_NonMotorData_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    Non_motorData_t *pstruAsnNonMotorData = (Non_motorData_t *)pvoidAsnDf;
    WJV2_STRU_Non_motorData *pstruWjNonMotorData = (WJV2_STRU_Non_motorData *)pvoidWjDf;
    int32_t n32Ret = 0;

    pstruWjNonMotorData->enumbasicType = pstruAsnNonMotorData->basicType;

    if (NULL != pstruAsnNonMotorData->propulsion)
    {

        n32Ret = WJV2_PropelledInformation_DfDec(pstruAsnNonMotorData->propulsion,
                                                 &(pstruWjNonMotorData->strupropulsion));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PropelledInformation_DfDec is err");
            return false;
        }
        pstruWjNonMotorData->u8propulsionPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjNonMotorData->u8propulsionPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnNonMotorData->clusterSize)
    {

        pstruWjNonMotorData->enumclusterSize = *pstruAsnNonMotorData->clusterSize;
        pstruWjNonMotorData->u8clusterSizePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjNonMotorData->u8clusterSizePresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnNonMotorData->attachment)
    {

        pstruWjNonMotorData->enumattachment = *pstruAsnNonMotorData->attachment;
        pstruWjNonMotorData->u8attachmentPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjNonMotorData->u8attachmentPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnNonMotorData->personalExt)
    {

        n32Ret = WJV2_PersonalExtensions_DfDec(pstruAsnNonMotorData->personalExt,
                                               &(pstruWjNonMotorData->strupersonalExt));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PersonalExtensions_DfDec is err");
            return false;
        }
        pstruWjNonMotorData->u8personalExtPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjNonMotorData->u8personalExtPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnNonMotorData->roadWorkerExt)
    {

        n32Ret = WJV2_RoadWorkerExtensions_DfDec(pstruAsnNonMotorData->roadWorkerExt,
                                                 &(pstruWjNonMotorData->struroadWorkerExt));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RoadWorkerExtensions_DfDec is err");
            return false;
        }
        pstruWjNonMotorData->u8roadWorkerExtPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjNonMotorData->u8roadWorkerExtPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnNonMotorData->personalReq)
    {

        n32Ret = WJV2_PersonalRequest_DfDec(pstruAsnNonMotorData->personalReq,
                                            &(pstruWjNonMotorData->strupersonalReq));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PersonalRequest_DfDec is err");
            return false;
        }
        pstruWjNonMotorData->u8personalReqPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjNonMotorData->u8personalReqPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_NonMotorDataExtension_DfEnc编码函数
* @details   协议栈NonMotorDataExtension编解码中 统一NonMotorDataExtension的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_NonMotorDataExtension_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    Non_motorDataExtension_t *pstruAsnNonMotorDataExtension = (Non_motorDataExtension_t *)pvoidAsnDf;
    WJV2_STRU_Non_motorDataExtension *pstruWjNonMotorDataExtension = (WJV2_STRU_Non_motorDataExtension *)pvoidWjDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_overallRadius_SIZE < pstruWjNonMotorDataExtension->n32overallRadius) ||
        (WJV2_MIN_overallRadius_SIZE > pstruWjNonMotorDataExtension->n32overallRadius))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth: pstruWjNonMotorDataExtension->n32overallRadius = %d",
                 pstruWjNonMotorDataExtension->n32overallRadius);
        return false;
    }
    pstruAsnNonMotorDataExtension->overallRadius = pstruWjNonMotorDataExtension->n32overallRadius;
    n32Ret = WJV2_NonMotorData_DfEnc(&pstruAsnNonMotorDataExtension->non_motorData,
                                     &(pstruWjNonMotorDataExtension->strunon_motorData));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NonMotorData_DfEnc is err");
        return false;
    }

    return true;
}
/**
* @brief     WJV2_NonMotorDataExtension_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_NonMotorDataExtension_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    Non_motorDataExtension_t *pstruAsnNonMotorDataExtension = (Non_motorDataExtension_t *)pvoidAsnDf;
    WJV2_STRU_Non_motorDataExtension *pstruWjNonMotorDataExtension = (WJV2_STRU_Non_motorDataExtension *)pvoidWjDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_overallRadius_SIZE < pstruAsnNonMotorDataExtension->overallRadius) ||
        (WJV2_MIN_overallRadius_SIZE > pstruAsnNonMotorDataExtension->overallRadius))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth: pstruAsnNonMotorDataExtension->overallRadius = %d",
                 pstruAsnNonMotorDataExtension->overallRadius);
        return false;
    }
    pstruWjNonMotorDataExtension->n32overallRadius = pstruAsnNonMotorDataExtension->overallRadius;
    n32Ret = WJV2_NonMotorData_DfDec(&pstruAsnNonMotorDataExtension->non_motorData,
                                     &(pstruWjNonMotorDataExtension->strunon_motorData));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NonMotorData_DfDec is err");
        return false;
    }
    return true;
}
/**
* @brief     WJV2_ObjectSize_DfEnc编码函数
* @details   协议栈ObjectSize编解码中 统一ObjectSize的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ObjectSize_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    ObjectSize_t *pstruAsnObjectSize = (ObjectSize_t *)pvoidAsnDf;
    WJV2_STRU_ObjectSize *pstruWjObjectSize = (WJV2_STRU_ObjectSize *)pvoidWjDf;

    if ((WJV2_MAX_SizeValue_SIZE < pstruWjObjectSize->n32width) ||
        (WJV2_MIN_SizeValue_SIZE > pstruWjObjectSize->n32width))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjObjectSize->n32width = %d",
                 pstruWjObjectSize->n32width);
        return false;
    }
    pstruAsnObjectSize->width = pstruWjObjectSize->n32width;

    if ((WJV2_MAX_SizeValue_SIZE < pstruWjObjectSize->n32length) ||
        (WJV2_MIN_SizeValue_SIZE > pstruWjObjectSize->n32length))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjObjectSize->n32length = %d",
                 pstruWjObjectSize->n32length);
        return false;
    }
    pstruAsnObjectSize->length = pstruWjObjectSize->n32length;

    if (WJV2_PRESENT == pstruWjObjectSize->u8heightPresent)
    {
        pstruAsnObjectSize->height = CALLOC(1, sizeof(SizeValue_t));
        if (NULL == pstruAsnObjectSize->height)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        if ((WJV2_MAX_SizeValue_SIZE < pstruWjObjectSize->n32height) ||
            (WJV2_MIN_SizeValue_SIZE > pstruWjObjectSize->n32height))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjObjectSize->n32height = %d",
                     pstruWjObjectSize->n32height);
            return false;
        }
        *pstruAsnObjectSize->height = pstruWjObjectSize->n32height;
    }
    else
    {
        pstruAsnObjectSize->height = NULL;
    }

    return true;
}
/**
* @brief     WJV2_ObjectSize_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ObjectSize_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    ObjectSize_t *pstruAsnObjectSize = (ObjectSize_t *)pvoidAsnDf;
    WJV2_STRU_ObjectSize *pstruWjObjectSize = (WJV2_STRU_ObjectSize *)pvoidWjDf;

    if ((WJV2_MAX_SizeValue_SIZE < pstruAsnObjectSize->width) ||
        (WJV2_MIN_SizeValue_SIZE > pstruAsnObjectSize->width))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnObjectSize->width = %d",
                 pstruAsnObjectSize->width);
        return false;
    }
    pstruWjObjectSize->n32width = pstruAsnObjectSize->width;

    if ((WJV2_MAX_SizeValue_SIZE < pstruAsnObjectSize->length) ||
        (WJV2_MIN_SizeValue_SIZE > pstruAsnObjectSize->length))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnObjectSize->length = %d",
                 pstruAsnObjectSize->length);
        return false;
    }
    pstruWjObjectSize->n32length = pstruAsnObjectSize->length;

    if (NULL != pstruAsnObjectSize->height)
    {

        if ((WJV2_MAX_SizeValue_SIZE < *pstruAsnObjectSize->height) ||
            (WJV2_MIN_SizeValue_SIZE > *pstruAsnObjectSize->height))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*pstruAsnObjectSize->height = %d",
                     *pstruAsnObjectSize->height);
            return false;
        }
        pstruWjObjectSize->n32height = *pstruAsnObjectSize->height;
        pstruWjObjectSize->u8heightPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjObjectSize->u8heightPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_OBUInfo_DfEnc编码函数
* @details   协议栈OBUInfo编解码中 统一OBUInfo的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_OBUInfo_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    OBUInfo_t *pstruAsnOBUInfo = (OBUInfo_t *)pvoidAsnDf;
    WJV2_STRU_OBUInfo *pstruWjOBUInfo = (WJV2_STRU_OBUInfo *)pvoidWjDf;
    int32_t n32Ret = 0;
    pstruAsnOBUInfo->obuType = pstruWjOBUInfo->enumobuType;

    if (WJV2_PRESENT == pstruWjOBUInfo->u8obuMotionStatusPresent)
    {
        pstruAsnOBUInfo->obuMotionStatus = CALLOC(1, sizeof(struct OBUMotionStatus));
        if (NULL == pstruAsnOBUInfo->obuMotionStatus)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_OBUMotionStatus_DfEnc(pstruAsnOBUInfo->obuMotionStatus,
                                            &(pstruWjOBUInfo->struobuMotionStatus));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_OBUMotionStatus_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnOBUInfo->obuMotionStatus = NULL;
    }
    return true;
}
/**
* @brief     WJV2_OBUInfo_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_OBUInfo_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    OBUInfo_t *pstruAsnOBUInfo = (OBUInfo_t *)pvoidAsnDf;
    WJV2_STRU_OBUInfo *pstruWjOBUInfo = (WJV2_STRU_OBUInfo *)pvoidWjDf;
    int32_t n32Ret = 0;
    pstruWjOBUInfo->enumobuType = pstruAsnOBUInfo->obuType;

    if (NULL != pstruAsnOBUInfo->obuMotionStatus)
    {

        n32Ret = WJV2_OBUMotionStatus_DfDec(pstruAsnOBUInfo->obuMotionStatus,
                                            &(pstruWjOBUInfo->struobuMotionStatus));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_OBUMotionStatus_DfDec is err");
            return false;
        }
        pstruWjOBUInfo->u8obuMotionStatusPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjOBUInfo->u8obuMotionStatusPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_OBUMotionStatus_DfEnc编码函数
* @details   协议栈OBUMotionStatus编解码中 统一OBUMotionStatus的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_OBUMotionStatus_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    OBUMotionStatus_t *pstruAsnOBUMotionStatus = (OBUMotionStatus_t *)pvoidAsnDf;
    WJV2_STRU_OBUMotionStatus *pstruWjOBUMotionStatus = (WJV2_STRU_OBUMotionStatus *)pvoidWjDf;
    int32_t n32Ret = 0;

    if (WJV2_PRESENT == pstruWjOBUMotionStatus->u8posPresent)
    {
        pstruAsnOBUMotionStatus->pos = CALLOC(1, sizeof(struct Position3D));
        if (NULL == pstruAsnOBUMotionStatus->pos)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_Position3D_DfEnc(pstruAsnOBUMotionStatus->pos,
                                       &(pstruWjOBUMotionStatus->strupos));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Position3D_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnOBUMotionStatus->pos = NULL;
    }

    if (WJV2_PRESENT == pstruWjOBUMotionStatus->u8headingPresent)
    {
        if ((WJV2_MAX_HEADING_SIZE < pstruWjOBUMotionStatus->n32heading) ||
            (WJV2_MIN_HEADING_SIZE > pstruWjOBUMotionStatus->n32heading))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjOBUMotionStatus->n32heading = %d",
                     pstruWjOBUMotionStatus->n32heading);
            return false;
        }
        pstruAsnOBUMotionStatus->heading = CALLOC(1, sizeof(Heading_t));
        if (NULL == pstruAsnOBUMotionStatus->heading)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnOBUMotionStatus->heading = pstruWjOBUMotionStatus->n32heading;
    }
    else
    {
        pstruAsnOBUMotionStatus->heading = NULL;
    }

    if (WJV2_PRESENT == pstruWjOBUMotionStatus->u8speedPresent)
    {
        if ((WJV2_MAX_SPEED_SIZE < pstruWjOBUMotionStatus->n32speed) ||
            (WJV2_MIN_SPEED_SIZE > pstruWjOBUMotionStatus->n32speed))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjOBUMotionStatus->n32speed = %d",
                     pstruWjOBUMotionStatus->n32speed);
            return false;
        }
        pstruAsnOBUMotionStatus->speed = CALLOC(1, sizeof(Speed_t));
        if (NULL == pstruAsnOBUMotionStatus->speed)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnOBUMotionStatus->speed = pstruWjOBUMotionStatus->n32speed;
    }
    else
    {
        pstruAsnOBUMotionStatus->speed = NULL;
    }

    return true;
}
/**
* @brief     WJV2_OBUMotionStatus_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_OBUMotionStatus_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    OBUMotionStatus_t *pstruAsnOBUMotionStatus = (OBUMotionStatus_t *)pvoidAsnDf;
    WJV2_STRU_OBUMotionStatus *pstruWjOBUMotionStatus = (WJV2_STRU_OBUMotionStatus *)pvoidWjDf;
    int32_t n32Ret = 0;

    if (NULL != pstruAsnOBUMotionStatus->pos)
    {

        n32Ret = WJV2_Position3D_DfEnc(pstruAsnOBUMotionStatus->pos,
                                       &(pstruWjOBUMotionStatus->strupos));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Position3D_DfEnc is err");
            return false;
        }
        pstruWjOBUMotionStatus->u8posPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjOBUMotionStatus->u8posPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnOBUMotionStatus->heading)
    {
        if ((WJV2_MAX_HEADING_SIZE < *pstruAsnOBUMotionStatus->heading) ||
            (WJV2_MIN_HEADING_SIZE > *pstruAsnOBUMotionStatus->heading))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*pstruAsnOBUMotionStatus->heading  = %d",
                     *pstruAsnOBUMotionStatus->heading);
            return false;
        }

        pstruWjOBUMotionStatus->n32heading = *pstruAsnOBUMotionStatus->heading;
        pstruWjOBUMotionStatus->u8headingPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjOBUMotionStatus->u8headingPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnOBUMotionStatus->speed)
    {
        if ((WJV2_MAX_SPEED_SIZE < *pstruAsnOBUMotionStatus->speed) ||
            (WJV2_MIN_SPEED_SIZE > *pstruAsnOBUMotionStatus->speed))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*pstruAsnOBUMotionStatus->speed = %d",
                     *pstruAsnOBUMotionStatus->speed);
            return false;
        }

        pstruWjOBUMotionStatus->n32speed = *pstruAsnOBUMotionStatus->speed;
        pstruWjOBUMotionStatus->u8speedPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjOBUMotionStatus->u8speedPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_OBUPaymentInfo_DfEnc编码函数
* @details   协议栈OBUPaymentInfo编解码中 统一OBUPaymentInfo的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_OBUPaymentInfo_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    OBUPaymentInfo_t *pstruAsnOBUPaymentInfo = (OBUPaymentInfo_t *)pvoidAsnDf;
    WJV2_STRU_OBUPaymentInfo *pstruWjOBUPaymentInfo = (WJV2_STRU_OBUPaymentInfo *)pvoidWjDf;
    int32_t n32Ret = 0;
    pstruAsnOBUPaymentInfo->present = pstruWjOBUPaymentInfo->enumpresent;

    if (OBUPaymentInfo_PR_obuPaymentInfoType1 == pstruAsnOBUPaymentInfo->present)
    {

        n32Ret = WJV2_OBUPaymentInfoType1_DfEnc(&pstruAsnOBUPaymentInfo->choice.obuPaymentInfoType1,
                                                &(pstruWjOBUPaymentInfo->choice.struobuPaymentInfoType1));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_OBUPaymentInfoType1_DfEnc is err");
            return false;
        }
    }

    return true;
}
/**
* @brief     WJV2_OBUPaymentInfo_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_OBUPaymentInfo_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    OBUPaymentInfo_t *pstruAsnOBUPaymentInfo = (OBUPaymentInfo_t *)pvoidAsnDf;
    WJV2_STRU_OBUPaymentInfo *pstruWjOBUPaymentInfo = (WJV2_STRU_OBUPaymentInfo *)pvoidWjDf;
    int32_t n32Ret = 0;
    pstruWjOBUPaymentInfo->enumpresent = pstruAsnOBUPaymentInfo->present;

    if (OBUPaymentInfo_PR_obuPaymentInfoType1 == pstruAsnOBUPaymentInfo->present)
    {

        n32Ret = WJV2_OBUPaymentInfoType1_DfDec(&pstruAsnOBUPaymentInfo->choice.obuPaymentInfoType1,
                                                &(pstruWjOBUPaymentInfo->choice.struobuPaymentInfoType1));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_OBUPaymentInfoType1_DfDec is err");
            return false;
        }
    }

    return true;
}

/**
* @brief     WJV2_PassedPosList_DfEnc编码函数
* @details   协议栈MovementExList编解码中 统一MovementExList的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PassedPosList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    WJV2_STRU_PassedPosList *pstruWjPassedPosList = (WJV2_STRU_PassedPosList *)pvoidWjDf;
    struct passedPos *pstruAsnPassedPosList = (struct passedPos *)pvoidAsnDf;
    struct PassedPos *pstruPassedPos_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_PassedPos_LEN < pstruWjPassedPosList->u16PassedPosNum) ||
        (WJV2_MIN_LIST_PassedPos_LEN > pstruWjPassedPosList->u16PassedPosNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPassedPosList->u16PassedPosNum = %d",
                 pstruWjPassedPosList->u16PassedPosNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjPassedPosList->u16PassedPosNum; u32i++)
    {
        pstruPassedPos_node = CALLOC(1, sizeof(struct PassedPos));
        if (NULL == pstruPassedPos_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PassedPos_DfEnc(pstruPassedPos_node, &(pstruWjPassedPosList->struPassedPos[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Movement_DfEnc is err");
            FREEMEM(pstruPassedPos_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnPassedPosList->list), pstruPassedPos_node);
    }

    return true;
}
/**
* @brief     WJV2_PassedPosList_DfEnc解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PassedPosList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PassedPosList *pstruWjPassedPosList = (WJV2_STRU_PassedPosList *)pvoidWjDf;
    struct passedPos *pstruAsnPassedPosList = (struct passedPos *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_PassedPos_LEN < pstruAsnPassedPosList->list.count) ||
        (WJV2_MIN_LIST_PassedPos_LEN > pstruAsnPassedPosList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPassedPosList->list.count = %d",
                 pstruAsnPassedPosList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnPassedPosList->list.count; u32i++)
    {
        n32Ret = WJV2_PassedPos_DfDec(pstruAsnPassedPosList->list.array[u32i],
                                      &(pstruWjPassedPosList->struPassedPos[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PassedPos_DfDec is err");
            return false;
        }
    }
    pstruWjPassedPosList->u16PassedPosNum = (uint8_t)u32i;
    return true;
}

/**
* @brief     WJV2_PassedSitesInfo_DfEnc编码函数
* @details   协议栈OBUPaymentInfo编解码中 统一OBUPaymentInfo的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PassedSitesInfo_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    PassedSitesInfo_t *pstruAsnPassedSitesInfo = (PassedSitesInfo_t *)pvoidAsnDf;
    WJV2_STRU_PassedSitesInfo *pstruWjPassedSitesInfo = (WJV2_STRU_PassedSitesInfo *)pvoidWjDf;
    int32_t n32Ret = 0;

    if (WJV2_PRESENT == pstruWjPassedSitesInfo->u8entranceInfoPresent)
    {
        pstruAsnPassedSitesInfo->entranceInfo = CALLOC(1, sizeof(struct PassedPos));
        if (NULL == pstruAsnPassedSitesInfo->entranceInfo)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PassedPos_DfEnc(pstruAsnPassedSitesInfo->entranceInfo,
                                      &(pstruWjPassedSitesInfo->struentranceInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PassedPos_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnPassedSitesInfo->entranceInfo = NULL;
    }

    if (WJV2_PRESENT == pstruWjPassedSitesInfo->u8passedPosPresent)
    {
        pstruAsnPassedSitesInfo->passedPos = CALLOC(1, sizeof(struct PassedPos));
        if (NULL == pstruAsnPassedSitesInfo->passedPos)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PassedPosList_DfEnc(pstruAsnPassedSitesInfo->passedPos,
                                          &(pstruWjPassedSitesInfo->strupassedPos));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PassedPosList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnPassedSitesInfo->passedPos = NULL;
    }

    return true;
}
/**
* @brief     WJV2_PassedSitesInfo_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PassedSitesInfo_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    PassedSitesInfo_t *pstruAsnPassedSitesInfo = (PassedSitesInfo_t *)pvoidAsnDf;
    WJV2_STRU_PassedSitesInfo *pstruWjPassedSitesInfo = (WJV2_STRU_PassedSitesInfo *)pvoidWjDf;
    int32_t n32Ret = 0;

    if (NULL != pstruAsnPassedSitesInfo->entranceInfo)
    {

        n32Ret = WJV2_PassedPos_DfDec(pstruAsnPassedSitesInfo->entranceInfo,
                                      &(pstruWjPassedSitesInfo->struentranceInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PassedPos_DfDec is err");
            return false;
        }
        pstruWjPassedSitesInfo->u8entranceInfoPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPassedSitesInfo->u8entranceInfoPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnPassedSitesInfo->passedPos)
    {

        n32Ret = WJV2_PassedPosList_DfDec(pstruAsnPassedSitesInfo->passedPos,
                                          &(pstruWjPassedSitesInfo->strupassedPos));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PassedPosList_DfDec is err");
            return false;
        }
        pstruWjPassedSitesInfo->u8passedPosPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPassedSitesInfo->u8passedPosPresent = WJV2_ABSENT;
    }
    return true;
}

/**
* @brief     WJV2_OBUPaymentInfoType1_DfEnc编码函数
* @details   协议栈OBUPaymentInfoType1编解码中 统一OBUPaymentInfoType1的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_OBUPaymentInfoType1_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    OBUPaymentInfoType1_t *pstruAsnOBUPaymentInfoType1 = (OBUPaymentInfoType1_t *)pvoidAsnDf;
    WJV2_STRU_OBUPaymentInfoType1 *pstruWjOBUPaymentInfoType1 = (WJV2_STRU_OBUPaymentInfoType1 *)pvoidWjDf;
    int32_t n32Ret = 0;

    if (WJV2_PRESENT == pstruWjOBUPaymentInfoType1->u8equipmentClassPresent)
    {
        pstruAsnOBUPaymentInfoType1->equipmentClass = CALLOC(1, sizeof(EquipmentClass_t));
        if (NULL == pstruAsnOBUPaymentInfoType1->equipmentClass)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnOBUPaymentInfoType1->equipmentClass = pstruWjOBUPaymentInfoType1->enumequipmentClass;
    }
    else
    {
        pstruAsnOBUPaymentInfoType1->equipmentClass = NULL;
    }

    if (WJV2_PRESENT == pstruWjOBUPaymentInfoType1->u8gbiCCInfoPresent)
    {
        pstruAsnOBUPaymentInfoType1->gbiCCInfo = CALLOC(1, sizeof(struct GBICCInfo));
        if (NULL == pstruAsnOBUPaymentInfoType1->gbiCCInfo)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_GBICCInfo_DfEnc(pstruAsnOBUPaymentInfoType1->gbiCCInfo,
                                      &(pstruWjOBUPaymentInfoType1->strugbiCCInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_GBICCInfo_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnOBUPaymentInfoType1->gbiCCInfo = NULL;
    }

    if (WJV2_PRESENT == pstruWjOBUPaymentInfoType1->u8sysInfoPresent)
    {
        pstruAsnOBUPaymentInfoType1->sysInfo = CALLOC(1, sizeof(struct SysInfo));
        if (NULL == pstruAsnOBUPaymentInfoType1->sysInfo)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_SysInfo_DfEnc(pstruAsnOBUPaymentInfoType1->sysInfo,
                                    &(pstruWjOBUPaymentInfoType1->strusysInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_SysInfo_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnOBUPaymentInfoType1->sysInfo = NULL;
    }

    if (WJV2_PRESENT == pstruWjOBUPaymentInfoType1->u8vehicleInfoPresent)
    {
        pstruAsnOBUPaymentInfoType1->vehicleInfo = CALLOC(1, sizeof(struct VehicleInfo));
        if (NULL == pstruAsnOBUPaymentInfoType1->vehicleInfo)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_VehicleInfo_DfEnc(pstruAsnOBUPaymentInfoType1->vehicleInfo,
                                        &(pstruWjOBUPaymentInfoType1->struvehicleInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_VehicleInfo_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnOBUPaymentInfoType1->vehicleInfo = NULL;
    }

    if (WJV2_PRESENT == pstruWjOBUPaymentInfoType1->u8passedSitesInfoPresent)
    {
        pstruAsnOBUPaymentInfoType1->passedSitesInfo = CALLOC(1, sizeof(struct PassedSitesInfo));
        if (NULL == pstruAsnOBUPaymentInfoType1->passedSitesInfo)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PassedSitesInfo_DfEnc(pstruAsnOBUPaymentInfoType1->passedSitesInfo,
                                            &(pstruWjOBUPaymentInfoType1->strupassedSitesInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PassedSitesInfo_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnOBUPaymentInfoType1->passedSitesInfo = NULL;
    }

    return true;
}
/**
* @brief     WJV2_OBUPaymentInfoType1_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_OBUPaymentInfoType1_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    OBUPaymentInfoType1_t *pstruAsnOBUPaymentInfoType1 = (OBUPaymentInfoType1_t *)pvoidAsnDf;
    WJV2_STRU_OBUPaymentInfoType1 *pstruWjOBUPaymentInfoType1 = (WJV2_STRU_OBUPaymentInfoType1 *)pvoidWjDf;
    int32_t n32Ret = 0;

    if (NULL != pstruAsnOBUPaymentInfoType1->equipmentClass)
    {
        pstruWjOBUPaymentInfoType1->enumequipmentClass = *pstruAsnOBUPaymentInfoType1->equipmentClass;
        pstruWjOBUPaymentInfoType1->u8equipmentClassPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjOBUPaymentInfoType1->u8equipmentClassPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnOBUPaymentInfoType1->gbiCCInfo)
    {

        n32Ret = WJV2_GBICCInfo_DfDec(pstruAsnOBUPaymentInfoType1->gbiCCInfo,
                                      &(pstruWjOBUPaymentInfoType1->strugbiCCInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_GBICCInfo_DfDec is err");
            return false;
        }
        pstruWjOBUPaymentInfoType1->u8gbiCCInfoPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjOBUPaymentInfoType1->u8gbiCCInfoPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnOBUPaymentInfoType1->sysInfo)
    {

        n32Ret = WJV2_SysInfo_DfDec(pstruAsnOBUPaymentInfoType1->sysInfo,
                                    &(pstruWjOBUPaymentInfoType1->strusysInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_SysInfo_DfDec is err");
            return false;
        }
        pstruWjOBUPaymentInfoType1->u8sysInfoPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjOBUPaymentInfoType1->u8sysInfoPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnOBUPaymentInfoType1->vehicleInfo)
    {

        n32Ret = WJV2_VehicleInfo_DfDec(pstruAsnOBUPaymentInfoType1->vehicleInfo,
                                        &(pstruWjOBUPaymentInfoType1->struvehicleInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_VehicleInfo_DfDec is err");
            return false;
        }
        pstruWjOBUPaymentInfoType1->u8vehicleInfoPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjOBUPaymentInfoType1->u8vehicleInfoPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnOBUPaymentInfoType1->passedSitesInfo)
    {

        n32Ret = WJV2_PassedSitesInfo_DfDec(pstruAsnOBUPaymentInfoType1->passedSitesInfo,
                                            &(pstruWjOBUPaymentInfoType1->strupassedSitesInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PassedSitesInfo_DfDec is err");
            return false;
        }
        pstruWjOBUPaymentInfoType1->u8passedSitesInfoPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjOBUPaymentInfoType1->u8passedSitesInfoPresent = WJV2_ABSENT;
    }
    return true;
}
/**
* @brief     WJV2_PAMDrive_DfEnc编码函数
* @details   协议栈PAMDrive编解码中 统一PAMDrive的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PAMDrive_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    PAMDrive_t *pstruAsnPAMDrive = (PAMDrive_t *)pvoidAsnDf;
    WJV2_STRU_PAMDrive *pstruWjPAMDrive = (WJV2_STRU_PAMDrive *)pvoidWjDf;
    int32_t n32Ret = 0;

    if ((WJV2_MAX_PAMNodeID_SIZE < pstruWjPAMDrive->n32upstreamPAMNodeId) ||
        (WJV2_MIN_PAMNodeID_SIZE > pstruWjPAMDrive->n32upstreamPAMNodeId))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPAMDrive->n32upstreamPAMNodeId = %d",
                 pstruWjPAMDrive->n32upstreamPAMNodeId);
        return false;
    }
    pstruAsnPAMDrive->upstreamPAMNodeId = pstruWjPAMDrive->n32upstreamPAMNodeId;

    if (WJV2_PRESENT == pstruWjPAMDrive->u8driveIDPresent)
    {
        if ((WJV2_MAX_driveID_SIZE < pstruWjPAMDrive->n32driveID) ||
            (WJV2_MIN_driveID_SIZE > pstruWjPAMDrive->n32driveID))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjPAMDrive->n32driveID= %d",
                     pstruWjPAMDrive->n32driveID);
            return false;
        }
        pstruAsnPAMDrive->driveID = CALLOC(1, sizeof(long));
        if (NULL == pstruAsnPAMDrive->driveID)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnPAMDrive->driveID = pstruWjPAMDrive->n32driveID;
    }
    else
    {
        pstruAsnPAMDrive->driveID = NULL;
    }

    if (WJV2_PRESENT == pstruWjPAMDrive->u8twowaySeprationPresent)
    {
        pstruAsnPAMDrive->twowaySepration = CALLOC(1, sizeof(BOOLEAN_t));
        if (NULL == pstruAsnPAMDrive->twowaySepration)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnPAMDrive->twowaySepration = pstruWjPAMDrive->n32twowaySepration;
    }
    else
    {
        pstruAsnPAMDrive->twowaySepration = NULL;
    }

    if (WJV2_PRESENT == pstruWjPAMDrive->u8speedLimitPresent)
    {
        if ((WJV2_MAX_SPEED_SIZE < pstruWjPAMDrive->n32speedLimit) ||
            (WJV2_MIN_SPEED_SIZE > pstruWjPAMDrive->n32speedLimit))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjPAMDrive->n32speedLimit = %d",
                     pstruWjPAMDrive->n32speedLimit);
            return false;
        }
        pstruAsnPAMDrive->speedLimit = CALLOC(1, sizeof(Speed_t));
        if (NULL == pstruAsnPAMDrive->speedLimit)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnPAMDrive->speedLimit = pstruWjPAMDrive->n32speedLimit;
    }
    else
    {
        pstruAsnPAMDrive->speedLimit = NULL;
    }

    if (WJV2_PRESENT == pstruWjPAMDrive->u8heightRestrictionPresent)
    {
        if ((WJV2_MAX_heightRestriction_SIZE < pstruWjPAMDrive->n32heightRestriction) ||
            (WJV2_MIN_heightRestriction_SIZE > pstruWjPAMDrive->n32heightRestriction))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjPAMDrive->n32heightRestriction= %d",
                     pstruWjPAMDrive->n32heightRestriction);
            return false;
        }
        pstruAsnPAMDrive->heightRestriction = CALLOC(1, sizeof(long));
        if (NULL == pstruAsnPAMDrive->heightRestriction)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnPAMDrive->heightRestriction = pstruWjPAMDrive->n32heightRestriction;
    }
    else
    {
        pstruAsnPAMDrive->heightRestriction = NULL;
    }

    if (WJV2_PRESENT == pstruWjPAMDrive->u8driveWidthPresent)
    {
        if ((WJV2_MAX_LANEWIDTH_SIZE < pstruWjPAMDrive->n32driveWidth) ||
            (WJV2_MIN_LANEWIDTH_SIZE > pstruWjPAMDrive->n32driveWidth))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjPAMDrive->n32driveWidth = %d",
                     pstruWjPAMDrive->n32driveWidth);
            return false;
        }
        pstruAsnPAMDrive->driveWidth = CALLOC(1, sizeof(LaneWidth_t));
        if (NULL == pstruAsnPAMDrive->driveWidth)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnPAMDrive->driveWidth = pstruWjPAMDrive->n32driveWidth;
    }
    else
    {
        pstruAsnPAMDrive->driveWidth = NULL;
    }

    if (WJV2_PRESENT == pstruWjPAMDrive->u8laneNumPresent)
    {
        if ((WJV2_MAX_laneNum_SIZE < pstruWjPAMDrive->n32laneNum) ||
            (WJV2_MIN_laneNum_SIZE > pstruWjPAMDrive->n32laneNum))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjPAMDrive->n32laneNum= %d",
                     pstruWjPAMDrive->n32laneNum);
            return false;
        }
        pstruAsnPAMDrive->laneNum = CALLOC(1, sizeof(long));
        if (NULL == pstruAsnPAMDrive->laneNum)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnPAMDrive->laneNum = pstruWjPAMDrive->n32laneNum;
    }
    else
    {
        pstruAsnPAMDrive->laneNum = NULL;
    }

    if (WJV2_PRESENT == pstruWjPAMDrive->u8pointsPresent)
    {

        pstruAsnPAMDrive->points = CALLOC(1, sizeof(struct PointList));
        if (NULL == pstruAsnPAMDrive->points)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PointList_DfEnc(pstruAsnPAMDrive->points,
                                      &(pstruWjPAMDrive->strupoints));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PointList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnPAMDrive->points = NULL;
    }

    if (WJV2_PRESENT == pstruWjPAMDrive->u8movementsPresent)
    {

        pstruAsnPAMDrive->movements = CALLOC(1, sizeof(struct PAMMovementList));
        if (NULL == pstruAsnPAMDrive->movements)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PAMMovementList_DfEnc(pstruAsnPAMDrive->movements,
                                            &(pstruWjPAMDrive->strumovements));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PAMMovementList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnPAMDrive->movements = NULL;
    }

    if (WJV2_PRESENT == pstruWjPAMDrive->u8parkingSlotsPresent)
    {

        pstruAsnPAMDrive->parkingSlots = CALLOC(1, sizeof(struct ParkingSlots));
        if (NULL == pstruAsnPAMDrive->parkingSlots)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ParkingSlots_DfEnc(pstruAsnPAMDrive->parkingSlots,
                                         &(pstruWjPAMDrive->struparkingSlots));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ParkingSlots_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnPAMDrive->parkingSlots = NULL;
    }

    return true;
}
/**
* @brief     WJV2_PAMDrive_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PAMDrive_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    PAMDrive_t *pstruAsnPAMDrive = (PAMDrive_t *)pvoidAsnDf;
    WJV2_STRU_PAMDrive *pstruWjPAMDrive = (WJV2_STRU_PAMDrive *)pvoidWjDf;
    int32_t n32Ret = 0;

    if ((WJV2_MAX_PAMNodeID_SIZE < pstruAsnPAMDrive->upstreamPAMNodeId) ||
        (WJV2_MIN_PAMNodeID_SIZE > pstruAsnPAMDrive->upstreamPAMNodeId))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPAMDrive->upstreamPAMNodeId = %d",
                 pstruAsnPAMDrive->upstreamPAMNodeId);
        return false;
    }
    pstruWjPAMDrive->n32upstreamPAMNodeId = pstruAsnPAMDrive->upstreamPAMNodeId;

    if (NULL != pstruAsnPAMDrive->driveID)
    {
        if ((WJV2_MAX_driveID_SIZE < *pstruAsnPAMDrive->driveID) ||
            (WJV2_MIN_driveID_SIZE > *pstruAsnPAMDrive->driveID))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*pstruAsnPAMDrive->driveID= %d",
                     *pstruAsnPAMDrive->driveID);
            return false;
        }
        pstruWjPAMDrive->n32driveID = *pstruAsnPAMDrive->driveID;
        pstruWjPAMDrive->u8driveIDPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPAMDrive->u8driveIDPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnPAMDrive->twowaySepration)
    {

        pstruWjPAMDrive->n32twowaySepration = *pstruAsnPAMDrive->twowaySepration;
        pstruWjPAMDrive->u8twowaySeprationPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPAMDrive->u8twowaySeprationPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnPAMDrive->speedLimit)
    {
        if ((WJV2_MAX_SPEED_SIZE < *pstruAsnPAMDrive->speedLimit) ||
            (WJV2_MIN_SPEED_SIZE > *pstruAsnPAMDrive->speedLimit))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth: *pstruAsnPAMDrive->speedLimit = %d",
                     *pstruAsnPAMDrive->speedLimit);
            return false;
        }

        pstruWjPAMDrive->n32speedLimit = *pstruAsnPAMDrive->speedLimit;
        pstruWjPAMDrive->u8speedLimitPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPAMDrive->u8speedLimitPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnPAMDrive->heightRestriction)
    {
        if ((WJV2_MAX_heightRestriction_SIZE < *pstruAsnPAMDrive->heightRestriction) ||
            (WJV2_MIN_heightRestriction_SIZE > *pstruAsnPAMDrive->heightRestriction))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*pstruAsnPAMDrive->heightRestriction= %d",
                     *pstruAsnPAMDrive->heightRestriction);
            return false;
        }
        pstruWjPAMDrive->n32heightRestriction = *pstruAsnPAMDrive->heightRestriction;
        pstruWjPAMDrive->u8heightRestrictionPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPAMDrive->u8heightRestrictionPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnPAMDrive->driveWidth)
    {
        if ((WJV2_MAX_LANEWIDTH_SIZE < *pstruAsnPAMDrive->driveWidth) ||
            (WJV2_MIN_LANEWIDTH_SIZE > *pstruAsnPAMDrive->driveWidth))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*pstruAsnPAMDrive->driveWidth = %d",
                     *pstruAsnPAMDrive->driveWidth);
            return false;
        }

        pstruWjPAMDrive->n32driveWidth = *pstruAsnPAMDrive->driveWidth;
        pstruWjPAMDrive->u8driveWidthPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPAMDrive->u8driveWidthPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnPAMDrive->laneNum)
    {
        if ((WJV2_MAX_laneNum_SIZE < *pstruAsnPAMDrive->laneNum) ||
            (WJV2_MIN_laneNum_SIZE > *pstruAsnPAMDrive->laneNum))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*pstruAsnPAMDrive->laneNum= %d",
                     *pstruAsnPAMDrive->laneNum);
            return false;
        }
        pstruWjPAMDrive->n32laneNum = *pstruAsnPAMDrive->laneNum;
        pstruWjPAMDrive->u8laneNumPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPAMDrive->u8laneNumPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnPAMDrive->points)
    {

        n32Ret = WJV2_PointList_DfDec(pstruAsnPAMDrive->points,
                                      &(pstruWjPAMDrive->strupoints));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PointList_DfDec is err");
            return false;
        }
        pstruWjPAMDrive->u8pointsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPAMDrive->u8pointsPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnPAMDrive->movements)
    {

        n32Ret = WJV2_PAMMovementList_DfDec(pstruAsnPAMDrive->movements,
                                            &(pstruWjPAMDrive->strumovements));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PAMMovementList_DfDec is err");
            return false;
        }
        pstruWjPAMDrive->u8movementsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPAMDrive->u8movementsPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnPAMDrive->parkingSlots)
    {

        n32Ret = WJV2_ParkingSlots_DfDec(pstruAsnPAMDrive->parkingSlots,
                                         &(pstruWjPAMDrive->struparkingSlots));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ParkingSlots_DfDec is err");
            return false;
        }
        pstruWjPAMDrive->u8parkingSlotsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPAMDrive->u8parkingSlotsPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_PAMDriveList_DfEnc编码函数
* @details   协议栈PAMDriveList编解码中 统一PAMDriveList的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PAMDriveList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    WJV2_STRU_PAMDriveList *pstruWjPAMDriveList = (WJV2_STRU_PAMDriveList *)pvoidWjDf;
    PAMDriveList_t *pstruAsnPAMDriveList = (PAMDriveList_t *)pvoidAsnDf;
    struct PAMDrive *pstruPAMDrive_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;

    if ((WJV2_MAX_LIST_PAMDrive_LEN < pstruWjPAMDriveList->u8PAMDriveNum) ||
        (WJV2_MIN_LIST_PAMDrive_LEN > pstruWjPAMDriveList->u8PAMDriveNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPAMDriveList->u8PAMDriveNum = %d",
                 pstruWjPAMDriveList->u8PAMDriveNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjPAMDriveList->u8PAMDriveNum; u32i++)
    {
        pstruPAMDrive_node = CALLOC(1, sizeof(struct PAMDrive));
        if (NULL == pstruPAMDrive_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PAMDrive_DfEnc(pstruPAMDrive_node, &(pstruWjPAMDriveList->struPAMDrive[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PAMDrive_DfEnc is err");
            FREEMEM(pstruPAMDrive_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnPAMDriveList->list), pstruPAMDrive_node);
    }

    return true;
}
/**
* @brief     WJV2_PAMDriveList_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PAMDriveList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    WJV2_STRU_PAMDriveList *pstruWjPAMDriveList = (WJV2_STRU_PAMDriveList *)pvoidWjDf;
    PAMDriveList_t *pstruAsnPAMDriveList = (PAMDriveList_t *)pvoidAsnDf;

    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_PAMDrive_LEN < pstruAsnPAMDriveList->list.count) ||
        (WJV2_MIN_LIST_PAMDrive_LEN > pstruAsnPAMDriveList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPAMDriveList->list.count = %d",
                 pstruAsnPAMDriveList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnPAMDriveList->list.count; u32i++)
    {
        n32Ret = WJV2_PAMDrive_DfDec(pstruAsnPAMDriveList->list.array[u32i],
                                     &(pstruWjPAMDriveList->struPAMDrive[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PAMDrive_DfDec is err");
            return false;
        }
    }
    pstruWjPAMDriveList->u8PAMDriveNum = (uint8_t)u32i;

    return true;
}
/**
* @brief     WJV2_PAMMovementList_DfEnc编码函数
* @details   协议栈PAMMovementList编解码中 统一PAMMovementList的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PAMMovementList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    WJV2_STRU_PAMMovementList *pstruWjPAMMovementList = (WJV2_STRU_PAMMovementList *)pvoidWjDf;
    PAMMovementList_t *pstruAsnPAMMovementList = (PAMMovementList_t *)pvoidAsnDf;
    PAMNodeID_t *pstruPAMNodeID_node = NULL;
    uint32_t u32i = 0;

    if ((WJV2_MAX_LIST_PAMNodeID_LEN < pstruWjPAMMovementList->u8PAMNodeIDNum) ||
        (WJV2_MIN_LIST_PAMNodeID_LEN > pstruWjPAMMovementList->u8PAMNodeIDNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPAMMovementList->u8PAMNodeIDNum = %d",
                 pstruWjPAMMovementList->u8PAMNodeIDNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjPAMMovementList->u8PAMNodeIDNum; u32i++)
    {
        if ((WJV2_MAX_PAMNodeID_SIZE < pstruWjPAMMovementList->struPAMNodeID[u32i]) ||
            (WJV2_MIN_PAMNodeID_SIZE > pstruWjPAMMovementList->struPAMNodeID[u32i]))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjPAMMovementList->struPAMNodeID[u32i] = %d",
                     pstruWjPAMMovementList->struPAMNodeID[u32i]);
            return false;
        }

        pstruPAMNodeID_node = CALLOC(1, sizeof(PAMNodeID_t));
        if (NULL == pstruPAMNodeID_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruPAMNodeID_node = pstruWjPAMMovementList->struPAMNodeID[u32i];

        asn_sequence_add(&(pstruAsnPAMMovementList->list), pstruPAMNodeID_node);
    }

    return true;
}
/**
* @brief     WJV2_PAMMovementList_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PAMMovementList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PAMMovementList *pstruWjPAMMovementList = (WJV2_STRU_PAMMovementList *)pvoidWjDf;
    PAMMovementList_t *pstruAsnPAMMovementList = (PAMMovementList_t *)pvoidAsnDf;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_PAMNodeID_LEN < pstruAsnPAMMovementList->list.count) ||
        (WJV2_MIN_LIST_PAMNodeID_LEN > pstruAsnPAMMovementList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPAMMovementList->list.count = %d",
                 pstruAsnPAMMovementList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnPAMMovementList->list.count; u32i++)
    {
        if ((WJV2_MAX_PAMNodeID_SIZE < *pstruAsnPAMMovementList->list.array[u32i]) ||
            (WJV2_MIN_PAMNodeID_SIZE > *pstruAsnPAMMovementList->list.array[u32i]))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*pstruAsnPAMMovementList->list.array[u32i] = %d",
                     *pstruAsnPAMMovementList->list.array[u32i]);
            return false;
        }
        pstruWjPAMMovementList->struPAMNodeID[u32i] = *pstruAsnPAMMovementList->list.array[u32i];
    }
    pstruWjPAMMovementList->u8PAMNodeIDNum = (uint8_t)u32i;

    return true;
}
/**
* @brief     WJV2_PAMNode_DfEnc编码函数
* @details   协议栈PAMNode编解码中 统一PAMNode的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PAMNode_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    PAMNode_t *pstruAsnPAMNode = (PAMNode_t *)pvoidAsnDf;
    WJV2_STRU_PAMNode *pstruWjPAMNode = (WJV2_STRU_PAMNode *)pvoidWjDf;
    int32_t n32Ret = 0;

    if ((WJV2_MAX_PAMNodeID_SIZE < pstruWjPAMNode->n32id) ||
        (WJV2_MIN_PAMNodeID_SIZE > pstruWjPAMNode->n32id))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPAMNode->n32id = %d",
                 pstruWjPAMNode->n32id);
        return false;
    }
    pstruAsnPAMNode->id = pstruWjPAMNode->n32id;

    n32Ret = WJV2_Position3D_DfEnc(&pstruAsnPAMNode->refPos,
                                   &(pstruWjPAMNode->strurefPos));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_Position3D_DfEnc is err");
        return false;
    }

    if (WJV2_PRESENT == pstruWjPAMNode->u8floorPresent)
    {
        if ((WJV2_MAX_floor_SIZE < pstruWjPAMNode->n32floor) ||
            (WJV2_MIN_floor_SIZE > pstruWjPAMNode->n32floor))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjPAMNode->n32floor= %d",
                     pstruWjPAMNode->n32floor);
            return false;
        }
        pstruAsnPAMNode->floor = CALLOC(1, sizeof(long));
        if (NULL == pstruAsnPAMNode->floor)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnPAMNode->floor = pstruWjPAMNode->n32floor;
    }
    else
    {
        pstruAsnPAMNode->floor = NULL;
    }

    if (WJV2_PRESENT == pstruWjPAMNode->u8attributesPresent)
    {
        pstruAsnPAMNode->attributes = CALLOC(1, sizeof(PAMNodeAttributes_t));
        if (NULL == pstruAsnPAMNode->attributes)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PAMNodeAttributes_DeEnc(pstruAsnPAMNode->attributes,
                                              &(pstruWjPAMNode->bitattributes));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PAMNodeAttributes_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnPAMNode->attributes = NULL;
    }

    if (WJV2_PRESENT == pstruWjPAMNode->u8inDrivesPresent)
    {
        pstruAsnPAMNode->inDrives = CALLOC(1, sizeof(struct PAMDriveList));
        if (NULL == pstruAsnPAMNode->inDrives)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PAMDriveList_DfEnc(pstruAsnPAMNode->inDrives,
                                         &(pstruWjPAMNode->struinDrives));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PAMDriveList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnPAMNode->inDrives = NULL;
    }

    return true;
}
/**
* @brief     WJV2_PAMNode_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PAMNode_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    PAMNode_t *pstruAsnPAMNode = (PAMNode_t *)pvoidAsnDf;
    WJV2_STRU_PAMNode *pstruWjPAMNode = (WJV2_STRU_PAMNode *)pvoidWjDf;
    int32_t n32Ret = 0;

    if ((WJV2_MAX_PAMNodeID_SIZE < pstruAsnPAMNode->id) ||
        (WJV2_MIN_PAMNodeID_SIZE > pstruAsnPAMNode->id))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPAMNode->id = %d",
                 pstruAsnPAMNode->id);
        return false;
    }
    pstruWjPAMNode->n32id = pstruAsnPAMNode->id;

    n32Ret = WJV2_Position3D_DfDec(&pstruAsnPAMNode->refPos,
                                   &(pstruWjPAMNode->strurefPos));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_Position3D_DfDec is err");
        return false;
    }

    if (NULL != pstruAsnPAMNode->floor)
    {
        if ((WJV2_MAX_floor_SIZE < *pstruAsnPAMNode->floor) ||
            (WJV2_MIN_floor_SIZE > *pstruAsnPAMNode->floor))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*pstruAsnPAMNode->floor= %d",
                     *pstruAsnPAMNode->floor);
            return false;
        }
        pstruWjPAMNode->n32floor = *pstruAsnPAMNode->floor;
        pstruWjPAMNode->u8floorPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPAMNode->u8floorPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnPAMNode->attributes)
    {

        n32Ret = WJV2_PAMNodeAttributes_DeDec(pstruAsnPAMNode->attributes,
                                              &(pstruWjPAMNode->bitattributes));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PAMNodeAttributes_DeDec is err");
            return false;
        }
        pstruWjPAMNode->u8attributesPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPAMNode->u8attributesPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnPAMNode->inDrives)
    {

        n32Ret = WJV2_PAMDriveList_DfDec(pstruAsnPAMNode->inDrives,
                                         &(pstruWjPAMNode->struinDrives));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PAMDriveList_DfDec is err");
            return false;
        }
        pstruWjPAMNode->u8floorPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPAMNode->u8floorPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_PAMNodeList_DfEnc编码函数
* @details   协议栈PAMNodeList编解码中 统一PAMNodeList的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PAMNodeList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PAMNodeList *pstruWjPAMNodeList = (WJV2_STRU_PAMNodeList *)pvoidWjDf;
    PAMNodeList_t *pstruAsnPAMNodeList = (PAMNodeList_t *)pvoidAsnDf;
    struct PAMNode *pstruPAMNode_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;

    if ((WJV2_MAX_LIST_PAMNode_LEN < pstruWjPAMNodeList->u8PAMNodeNum) ||
        (WJV2_MIN_LIST_PAMNode_LEN > pstruWjPAMNodeList->u8PAMNodeNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPAMNodeList->u8PAMNodeNum = %d",
                 pstruWjPAMNodeList->u8PAMNodeNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjPAMNodeList->u8PAMNodeNum; u32i++)
    {
        pstruPAMNode_node = CALLOC(1, sizeof(struct PAMNode));
        if (NULL == pstruPAMNode_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PAMNode_DfEnc(pstruPAMNode_node, &(pstruWjPAMNodeList->struPAMNode[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PAMNode_DfEnc is err");
            FREEMEM(pstruPAMNode_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnPAMNodeList->list), pstruPAMNode_node);
    }

    return true;
}
/**
* @brief     WJV2_PAMNodeList_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PAMNodeList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PAMNodeList *pstruWjPAMNodeList = (WJV2_STRU_PAMNodeList *)pvoidWjDf;
    PAMNodeList_t *pstruAsnPAMNodeList = (PAMNodeList_t *)pvoidAsnDf;

    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_PAMNode_LEN < pstruAsnPAMNodeList->list.count) ||
        (WJV2_MIN_LIST_PAMNode_LEN > pstruAsnPAMNodeList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPAMNodeList->list.count = %d",
                 pstruAsnPAMNodeList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnPAMNodeList->list.count; u32i++)
    {
        n32Ret = WJV2_PAMNode_DfDec(pstruAsnPAMNodeList->list.array[u32i],
                                    &(pstruWjPAMNodeList->struPAMNode[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PAMNode_DfDec is err");
            return false;
        }
    }
    pstruWjPAMNodeList->u8PAMNodeNum = (uint8_t)u32i;
    return true;
}

/**
* @brief     WJV2_drivePath_DfEnc编码函数
* @details   协议栈PAMNodeList编解码中 统一PAMNodeList的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_drivePath_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_drivePath *pstruWjdrivePath = (WJV2_STRU_drivePath *)pvoidWjDf;
    struct drivePath *pstruAsndrivePath = (struct drivePath *)pvoidAsnDf;
    PAMNodeID_t *pstruPAMNodeID_node = NULL;
    uint32_t u32i = 0;

    if ((WJV2_MAX_LIST_PAMNodeID_LEN < pstruWjdrivePath->u8PAMNodeIDNum) ||
        (WJV2_MIN_LIST_PAMNodeID_LEN > pstruWjdrivePath->u8PAMNodeIDNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjdrivePath->u8PAMNodeIDNum = %d",
                 pstruWjdrivePath->u8PAMNodeIDNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjdrivePath->u8PAMNodeIDNum; u32i++)
    {
        if ((WJV2_MAX_PAMNodeID_SIZE < pstruWjdrivePath->struPAMNodeID[u32i]) ||
            (WJV2_MIN_PAMNodeID_SIZE > pstruWjdrivePath->struPAMNodeID[u32i]))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjdrivePath->struPAMNodeID[u32i] = %d",
                     pstruWjdrivePath->struPAMNodeID[u32i]);
            return false;
        }

        pstruPAMNodeID_node = CALLOC(1, sizeof(PAMNodeID_t));
        if (NULL == pstruPAMNodeID_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruPAMNodeID_node = pstruWjdrivePath->struPAMNodeID[u32i];

        asn_sequence_add(&(pstruAsndrivePath->list), pstruPAMNodeID_node);
    }

    return true;
}
/**
* @brief     WJV2_drivePath_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_drivePath_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_drivePath *pstruWjdrivePath = (WJV2_STRU_drivePath *)pvoidWjDf;
    struct drivePath *pstruAsndrivePath = (struct drivePath *)pvoidAsnDf;
    uint32_t u32i = 0;

    if ((WJV2_MAX_LIST_PAMNodeID_LEN < pstruAsndrivePath->list.count) ||
        (WJV2_MIN_LIST_PAMNodeID_LEN > pstruAsndrivePath->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsndrivePath->list.count = %d",
                 pstruAsndrivePath->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsndrivePath->list.count; u32i++)
    {
        if ((WJV2_MAX_PAMNodeID_SIZE < *pstruAsndrivePath->list.array[u32i]) ||
            (WJV2_MIN_PAMNodeID_SIZE > *pstruAsndrivePath->list.array[u32i]))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*pstruAsndrivePath->list.array[u32i] = %d",
                     *pstruAsndrivePath->list.array[u32i]);
            return false;
        }
        pstruWjdrivePath->struPAMNodeID[u32i] = *pstruAsndrivePath->list.array[u32i];
    }
    pstruWjdrivePath->u8PAMNodeIDNum = (uint8_t)u32i;
    return true;
}

/**
* @brief     WJV2_ParkingGuide_DfEnc编码函数
* @details   协议栈ParkingGuide编解码中 统一ParkingGuide的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ParkingGuide_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    ParkingGuide_t *pstruAsnParkingGuide = (ParkingGuide_t *)pvoidAsnDf;
    WJV2_STRU_ParkingGuide *pstruWjParkingGuide = (WJV2_STRU_ParkingGuide *)pvoidWjDf;
    int32_t n32Ret = 0;

    pstruAsnParkingGuide->vehId.size = WJV2_MAX_OCTvehId_SIZE;
    pstruAsnParkingGuide->vehId.buf = CALLOC(pstruAsnParkingGuide->vehId.size, sizeof(uint8_t));
    if (NULL == pstruAsnParkingGuide->vehId.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruAsnParkingGuide->vehId.buf, pstruWjParkingGuide->u8OCTvehId, pstruAsnParkingGuide->vehId.size);

    n32Ret = WJV2_drivePath_DfEnc(&pstruAsnParkingGuide->drivePath,
                                  &(pstruWjParkingGuide->strudrivePath));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_drivePath_DfEnc is err");
        return false;
    }

    if (WJV2_PRESENT == pstruWjParkingGuide->u8targetParkingSlotPresent)
    {
        if ((WJV2_MAX_targetParkingSlot_SIZE < pstruWjParkingGuide->n32targetParkingSlot) ||
            (WJV2_MIN_targetParkingSlot_SIZE > pstruWjParkingGuide->n32targetParkingSlot))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjParkingGuide->n32targetParkingSlot= %d",
                     pstruWjParkingGuide->n32targetParkingSlot);
            return false;
        }
        pstruAsnParkingGuide->targetParkingSlot = CALLOC(1, sizeof(long));
        if (NULL == pstruAsnParkingGuide->targetParkingSlot)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnParkingGuide->targetParkingSlot = pstruWjParkingGuide->n32targetParkingSlot;
    }
    else
    {
        pstruAsnParkingGuide->targetParkingSlot = NULL;
    }

    return true;
}
/**
* @brief     WJV2_ParkingGuide_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ParkingGuide_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    ParkingGuide_t *pstruAsnParkingGuide = (ParkingGuide_t *)pvoidAsnDf;
    WJV2_STRU_ParkingGuide *pstruWjParkingGuide = (WJV2_STRU_ParkingGuide *)pvoidWjDf;
    int32_t n32Ret = 0;

    if (NULL != pstruAsnParkingGuide->vehId.buf)
    {
        memcpy(pstruWjParkingGuide->u8OCTvehId, pstruAsnParkingGuide->vehId.buf, pstruAsnParkingGuide->vehId.size);
    }

    n32Ret = WJV2_drivePath_DfDec(&pstruAsnParkingGuide->drivePath,
                                  &(pstruWjParkingGuide->strudrivePath));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_drivePath_DfDec is err");
        return false;
    }

    if (NULL != pstruAsnParkingGuide->targetParkingSlot)
    {
        if ((WJV2_MAX_targetParkingSlot_SIZE < *pstruAsnParkingGuide->targetParkingSlot) ||
            (WJV2_MIN_targetParkingSlot_SIZE > *pstruAsnParkingGuide->targetParkingSlot))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth: *pstruAsnParkingGuide->targetParkingSlot= %d",
                     *pstruAsnParkingGuide->targetParkingSlot);
            return false;
        }
        pstruWjParkingGuide->n32targetParkingSlot = *pstruAsnParkingGuide->targetParkingSlot;
        pstruWjParkingGuide->u8targetParkingSlotPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjParkingGuide->u8targetParkingSlotPresent = WJV2_ABSENT;
    }

    return true;
}
//todo
/**
* @brief     WJV2_ParkingLotInfo_DfEnc编码函数
* @details   协议栈ParkingLotInfo编解码中 统一ParkingLotInfo的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ParkingLotInfo_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    ParkingLotInfo_t *pstruAsnParkingLotInfo = (ParkingLotInfo_t *)pvoidAsnDf;
    WJV2_STRU_ParkingLotInfo *pstruWjParkingLotInfo = (WJV2_STRU_ParkingLotInfo *)pvoidAsnDf;
    int32_t n32Ret = 0;

    if (WJV2_PRESENT == pstruWjParkingLotInfo->u8idPresent)
    {
        if ((WJV2_MAX_ParkingLotInfo_id_SIZE < pstruWjParkingLotInfo->n32id) ||
            (WJV2_MIN_ParkingLotInfo_id_SIZE > pstruWjParkingLotInfo->n32id))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjParkingLotInfo->n32id= %d",
                     pstruWjParkingLotInfo->n32id);
            return false;
        }
        pstruAsnParkingLotInfo->id = CALLOC(1, sizeof(long));
        if (NULL == pstruAsnParkingLotInfo->id)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnParkingLotInfo->id = pstruWjParkingLotInfo->n32id;
    }
    else
    {
        pstruAsnParkingLotInfo->id = NULL;
    }

    if (WJV2_PRESENT == pstruWjParkingLotInfo->u8namePresent)
    {
        pstruAsnParkingLotInfo->name = CALLOC(1, sizeof(DescriptiveName_t));
        if (NULL == pstruAsnParkingLotInfo->name)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_DescriptiveName_DeEnc(pstruAsnParkingLotInfo->name,
                                            &(pstruWjParkingLotInfo->strname));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DescriptiveName_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnParkingLotInfo->name = NULL;
    }

    if (WJV2_PRESENT == pstruWjParkingLotInfo->u8numberPresent)
    {
        if ((WJV2_MAX_number_SIZE < pstruWjParkingLotInfo->n32number) ||
            (WJV2_MIN_number_SIZE > pstruWjParkingLotInfo->n32number))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjParkingLotInfo->n32number= %d",
                     pstruWjParkingLotInfo->n32number);
            return false;
        }
        pstruAsnParkingLotInfo->number = CALLOC(1, sizeof(long));
        if (NULL == pstruAsnParkingLotInfo->number)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnParkingLotInfo->number = pstruWjParkingLotInfo->n32number;
    }
    else
    {
        pstruAsnParkingLotInfo->number = NULL;
    }

    if (WJV2_PRESENT == pstruWjParkingLotInfo->u8buildingLayerNumPresent)
    {
        if ((WJV2_MAX_buildingLayerNum_SIZE < pstruWjParkingLotInfo->n32buildingLayerNum) ||
            (WJV2_MIN_buildingLayerNum_SIZE > pstruWjParkingLotInfo->n32buildingLayerNum))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjParkingLotInfo->n32buildingLayerNum= %d",
                     pstruWjParkingLotInfo->n32buildingLayerNum);
            return false;
        }
        pstruAsnParkingLotInfo->buildingLayerNum = CALLOC(1, sizeof(long));
        if (NULL == pstruAsnParkingLotInfo->buildingLayerNum)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnParkingLotInfo->buildingLayerNum = pstruWjParkingLotInfo->n32buildingLayerNum;
    }
    else
    {
        pstruAsnParkingLotInfo->buildingLayerNum = NULL;
    }

    if (WJV2_PRESENT == pstruWjParkingLotInfo->u8avpTypePresent)
    {
        pstruAsnParkingLotInfo->avpType = CALLOC(1, sizeof(AVPType_t));
        if (NULL == pstruAsnParkingLotInfo->avpType)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *pstruAsnParkingLotInfo->avpType = pstruWjParkingLotInfo->enumavpType;
    }
    else
    {
        pstruAsnParkingLotInfo->avpType = NULL;
    }

    return true;
}
/**
* @brief     WJV2_ParkingLotInfo_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ParkingLotInfo_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ParkingLotInfo *pstruWjParkingLotInfo = (WJV2_STRU_ParkingLotInfo *)pvoidWjDf;
    ParkingLotInfo_t *pstruAsnParkingLotInfo = (ParkingLotInfo_t *)pvoidAsnDf;
    int32_t n32Ret = 0;

    if (NULL != pstruAsnParkingLotInfo->id)
    {
        if ((WJV2_MAX_ParkingLotInfo_id_SIZE < *pstruAsnParkingLotInfo->id) ||
            (WJV2_MIN_ParkingLotInfo_id_SIZE > *pstruAsnParkingLotInfo->id))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*pstruAsnParkingLotInfo->id= %d",
                     *pstruAsnParkingLotInfo->id);
            return false;
        }
        pstruWjParkingLotInfo->n32id = *pstruAsnParkingLotInfo->id;
        pstruWjParkingLotInfo->u8idPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjParkingLotInfo->u8idPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnParkingLotInfo->name)
    {

        n32Ret = WJV2_DescriptiveName_DeDec(pstruAsnParkingLotInfo->name,
                                            &(pstruWjParkingLotInfo->strname));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DescriptiveName_DeDec is err");
            return false;
        }
        pstruWjParkingLotInfo->u8namePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjParkingLotInfo->u8namePresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnParkingLotInfo->number)
    {
        if ((WJV2_MAX_number_SIZE < *pstruAsnParkingLotInfo->number) ||
            (WJV2_MIN_number_SIZE > *pstruAsnParkingLotInfo->number))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*pstruAsnParkingLotInfo->number= %d",
                     *pstruAsnParkingLotInfo->number);
            return false;
        }
        pstruWjParkingLotInfo->n32number = *pstruAsnParkingLotInfo->number;
        pstruWjParkingLotInfo->u8numberPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjParkingLotInfo->u8numberPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnParkingLotInfo->buildingLayerNum)
    {
        if ((WJV2_MAX_buildingLayerNum_SIZE < *pstruAsnParkingLotInfo->buildingLayerNum) ||
            (WJV2_MIN_buildingLayerNum_SIZE > *pstruAsnParkingLotInfo->buildingLayerNum))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*pstruAsnParkingLotInfo->buildingLayerNum= %d",
                     *pstruAsnParkingLotInfo->buildingLayerNum);
            return false;
        }
        pstruWjParkingLotInfo->n32buildingLayerNum = *pstruAsnParkingLotInfo->buildingLayerNum;
        pstruWjParkingLotInfo->u8buildingLayerNumPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjParkingLotInfo->u8buildingLayerNumPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnParkingLotInfo->avpType)
    {

        pstruWjParkingLotInfo->enumavpType = *pstruAsnParkingLotInfo->avpType;
        pstruWjParkingLotInfo->u8avpTypePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjParkingLotInfo->u8avpTypePresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_ParkingSlot_DfEnc编码函数
* @details   协议栈ParkingSlot编解码中 统一ParkingSlot的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ParkingSlot_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ParkingSlot *pstruWjParkingSlot = (WJV2_STRU_ParkingSlot *)pvoidWjDf;
    ParkingSlot_t *pstruAsnParkingSlot = (ParkingSlot_t *)pvoidAsnDf;
    int32_t n32Ret = 0;

    if ((WJV2_MAX_slotID_SIZE < pstruWjParkingSlot->n32slotID) ||
        (WJV2_MIN_slotID_SIZE > pstruWjParkingSlot->n32slotID))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjParkingSlot->n32slotID= %d",
                 pstruWjParkingSlot->n32slotID);
        return false;
    }
    pstruAsnParkingSlot->slotID = pstruWjParkingSlot->n32slotID;
    if (WJV2_PRESENT == pstruWjParkingSlot->u8positionPresent)
    {
        pstruAsnParkingSlot->position = CALLOC(1, sizeof(struct ParkingSlotPosition));
        if (NULL == pstruAsnParkingSlot->position)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ParkingSlotPosition_DfEnc(pstruAsnParkingSlot->position, &(pstruWjParkingSlot->struposition));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ParkingSlotPosition_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnParkingSlot->position = NULL;
    }
    if (WJV2_PRESENT == pstruWjParkingSlot->u8signPresent)
    {
        pstruAsnParkingSlot->sign = CALLOC(1, sizeof(DescriptiveName_t));
        if (NULL == pstruAsnParkingSlot->sign)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_DescriptiveName_DeEnc(pstruAsnParkingSlot->sign, &(pstruWjParkingSlot->strsign));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DescriptiveName_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnParkingSlot->sign = NULL;
    }
    n32Ret = WJV2_ParkingType_DeEnc(&(pstruAsnParkingSlot->parkingType), &(pstruWjParkingSlot->bitparkingType));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_ParkingType_DeEnc is err");
        return false;
    }
    pstruAsnParkingSlot->status = pstruWjParkingSlot->enumstatus;
    pstruAsnParkingSlot->parkingSpaceTheta = pstruWjParkingSlot->enumparkingSpaceTheta;
    pstruAsnParkingSlot->parkingLock = pstruWjParkingSlot->enumparkingLock;

    return true;
}
/**
* @brief     WJV2_ParkingSlot_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ParkingSlot_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ParkingSlot *pstruWjParkingSlot = (WJV2_STRU_ParkingSlot *)pvoidWjDf;
    ParkingSlot_t *pstruAsnParkingSlot = (ParkingSlot_t *)pvoidAsnDf;
    int32_t n32Ret = 0;

    if ((WJV2_MAX_slotID_SIZE < pstruAsnParkingSlot->slotID) ||
        (WJV2_MIN_slotID_SIZE > pstruAsnParkingSlot->slotID))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnParkingSlot->slotID= %d",
                 pstruAsnParkingSlot->slotID);
        return false;
    }
    pstruWjParkingSlot->n32slotID = pstruAsnParkingSlot->slotID;
    if (NULL != pstruAsnParkingSlot->position)
    {
        n32Ret = WJV2_ParkingSlotPosition_DfDec(pstruAsnParkingSlot->position, &(pstruWjParkingSlot->struposition));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ParkingSlotPosition_DfDec is err");
            return false;
        }
        pstruWjParkingSlot->u8positionPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjParkingSlot->u8positionPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnParkingSlot->sign)
    {
        n32Ret = WJV2_DescriptiveName_DeDec(pstruAsnParkingSlot->sign, &(pstruWjParkingSlot->strsign));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DescriptiveName_DeDec is err");
            return false;
        }
        pstruWjParkingSlot->u8signPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjParkingSlot->u8signPresent = WJV2_ABSENT;
    }
    n32Ret = WJV2_ParkingType_DeDec(&(pstruAsnParkingSlot->parkingType), &(pstruWjParkingSlot->bitparkingType));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_ParkingType_DeDec is err");
        return false;
    }
    pstruWjParkingSlot->enumstatus = pstruAsnParkingSlot->status;
    pstruWjParkingSlot->enumparkingSpaceTheta = pstruAsnParkingSlot->parkingSpaceTheta;
    pstruWjParkingSlot->enumparkingLock = pstruAsnParkingSlot->parkingLock;

    return true;
}
/**
* @brief     WJV2_ParkingSlotPosition_DfEnc编码函数
* @details   协议栈ParkingSlotPosition编解码中 统一ParkingSlotPosition的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ParkingSlotPosition_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ParkingSlotPosition *pstruWjParkingSlotPosition = (WJV2_STRU_ParkingSlotPosition *)pvoidWjDf;
    ParkingSlotPosition_t *pstruAsnParkingSlotPosition = (ParkingSlotPosition_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_PositionOffsetLLV_DfEnc(&(pstruAsnParkingSlotPosition->topLeft), &(pstruWjParkingSlotPosition->strutopLeft));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PositionOffsetLLV_DfEnc is err");
        return false;
    }
    n32Ret = WJV2_PositionOffsetLLV_DfEnc(&(pstruAsnParkingSlotPosition->topRight), &(pstruWjParkingSlotPosition->strutopRight));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PositionOffsetLLV_DfEnc is err");
        return false;
    }
    n32Ret = WJV2_PositionOffsetLLV_DfEnc(&(pstruAsnParkingSlotPosition->bottomLeft), &(pstruWjParkingSlotPosition->strubottomLeft));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PositionOffsetLLV_DfEnc is err");
        return false;
    }

    return true;
}
/**
* @brief     WJV2_ParkingSlotPosition_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ParkingSlotPosition_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ParkingSlotPosition *pstruWjParkingSlotPosition = (WJV2_STRU_ParkingSlotPosition *)pvoidWjDf;
    ParkingSlotPosition_t *pstruAsnParkingSlotPosition = (ParkingSlotPosition_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_PositionOffsetLLV_DfDec(&(pstruAsnParkingSlotPosition->topLeft), &(pstruWjParkingSlotPosition->strutopLeft));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PositionOffsetLLV_DfDec is err");
        return false;
    }
    n32Ret = WJV2_PositionOffsetLLV_DfDec(&(pstruAsnParkingSlotPosition->topRight), &(pstruWjParkingSlotPosition->strutopRight));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PositionOffsetLLV_DfDec is err");
        return false;
    }
    n32Ret = WJV2_PositionOffsetLLV_DfDec(&(pstruAsnParkingSlotPosition->bottomLeft), &(pstruWjParkingSlotPosition->strubottomLeft));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PositionOffsetLLV_DfDec is err");
        return false;
    }

    return true;
}
/**
* @brief     WJV2_ParkingSlots_DfEnc编码函数
* @details   协议栈ParkingSlots编解码中 统一ParkingSlots的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ParkingSlots_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ParkingSlots *pstruWjParkingSlots = (WJV2_STRU_ParkingSlots *)pvoidWjDf;
    ParkingSlots_t *pstruAsnParkingSlots = (ParkingSlots_t *)pvoidAsnDf;
    ParkingSlot_t *pstruAsnParkingSlot_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_ParkingSlot_LEN < pstruWjParkingSlots->u16ParkingSlotNum) ||
        (WJV2_MIN_LIST_ParkingSlot_LEN > pstruWjParkingSlots->u16ParkingSlotNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjParkingSlots->u16ParkingSlotNum = %d",
                 pstruWjParkingSlots->u16ParkingSlotNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjParkingSlots->u16ParkingSlotNum; u32i++)
    {
        pstruAsnParkingSlot_node = CALLOC(1, sizeof(ParkingSlot_t));
        if (NULL == pstruAsnParkingSlot_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ParkingSlot_DfEnc(pstruAsnParkingSlot_node, &(pstruWjParkingSlots->struParkingSlot[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ParkingSlot_DfEnc is err");
            FREEMEM(pstruAsnParkingSlot_node);

            return false;
        }
        asn_sequence_add(&(pstruAsnParkingSlots->list), pstruAsnParkingSlot_node);
    }

    return true;
}
/**
* @brief     WJV2_ParkingSlots_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ParkingSlots_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ParkingSlots *pstruWjParkingSlots = (WJV2_STRU_ParkingSlots *)pvoidWjDf;
    ParkingSlots_t *pstruAsnParkingSlots = (ParkingSlots_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_ParkingSlot_LEN < pstruAsnParkingSlots->list.count) ||
        (WJV2_MIN_LIST_ParkingSlot_LEN > pstruAsnParkingSlots->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnParkingSlots->list.count = %d",
                 pstruAsnParkingSlots->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnParkingSlots->list.count; u32i++)
    {
        n32Ret = WJV2_ParkingSlot_DfDec(pstruAsnParkingSlots->list.array[u32i],
                                        &(pstruWjParkingSlots->struParkingSlot[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ParkingSlot_DfDec is err");

            return false;
        }
    }
    pstruWjParkingSlots->u16ParkingSlotNum = (uint8_t)u32i;

    return true;
}
/**
* @brief     WJV2_PartOfFile_DfEnc编码函数
* @details   协议栈PartOfFile编解码中 统一PartOfFile的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PartOfFile_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PartOfFile *pstruWjPartOfFile = (WJV2_STRU_PartOfFile *)pvoidWjDf;
    PartOfFile_t *pstruAsnPartOfFile = (PartOfFile_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_OFFSET_SIZE < pstruWjPartOfFile->n32offset) ||
        (WJV2_MIN_OFFSET_SIZE > pstruWjPartOfFile->n32offset))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPartOfFile->n32offset = %d",
                 pstruWjPartOfFile->n32offset);
        return false;
    }
    pstruAsnPartOfFile->offset = pstruWjPartOfFile->n32offset;
    if ((WJV2_MAX_LENGTH_SIZE < pstruWjPartOfFile->n32lenght) ||
        (WJV2_MIN_LENGTH_SIZE > pstruWjPartOfFile->n32lenght))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPartOfFile->n32lenght = %d",
                 pstruWjPartOfFile->n32lenght);
        return false;
    }
    pstruAsnPartOfFile->length = pstruWjPartOfFile->n32lenght;
    n32Ret = WJV2_File_DeEnc(&(pstruAsnPartOfFile->fileContent), &(pstruWjPartOfFile->octfileContent));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_File_DeEnc is err");
        return false;
    }

    return true;
}
/**
* @brief     WJV2_PartOfFile_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PartOfFile_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PartOfFile *pstruWjPartOfFile = (WJV2_STRU_PartOfFile *)pvoidWjDf;
    PartOfFile_t *pstruAsnPartOfFile = (PartOfFile_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_OFFSET_SIZE < pstruAsnPartOfFile->offset) ||
        (WJV2_MIN_OFFSET_SIZE > pstruAsnPartOfFile->offset))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPartOfFile->offset = %d",
                 pstruAsnPartOfFile->offset);
        return false;
    }
    pstruWjPartOfFile->n32offset = pstruAsnPartOfFile->offset;
    if ((WJV2_MAX_LENGTH_SIZE < pstruAsnPartOfFile->length) ||
        (WJV2_MIN_LENGTH_SIZE > pstruAsnPartOfFile->length))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPartOfFile->length = %d",
                 pstruAsnPartOfFile->length);
        return false;
    }
    pstruWjPartOfFile->n32lenght = pstruAsnPartOfFile->length;
    n32Ret = WJV2_File_DeDec(&(pstruAsnPartOfFile->fileContent), &(pstruWjPartOfFile->octfileContent));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_File_DeDec is err");
        return false;
    }

    return true;
}
/**
* @brief     WJV2_PassedPos_DfEnc编码函数
* @details   协议栈PassedPos编解码中 统一PassedPos的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PassedPos_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PassedPos *pstruWjPassedPos = (WJV2_STRU_PassedPos *)pvoidWjDf;
    PassedPos_t *pstruAsnPassedPos = (PassedPos_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_TollingPos_DfEnc(&(pstruAsnPassedPos->tollingPos), &(pstruWjPassedPos->strutollingPos));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_TollingPos_DfEnc is err");
        return false;
    }
    n32Ret = WJV2_DDateTime_DfEnc(&(pstruAsnPassedPos->tollingTime), &(pstruWjPassedPos->strutollingTime));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_DDateTime_DfEnc is err");
        return false;
    }
    if (WJV2_PRESENT == pstruWjPassedPos->u8tollingAmountPresent)
    {
        if ((WJV2_MAX_OCTtollingAmount_SIZE != pstruWjPassedPos->u8OCTtollingAmountNum) /*||
            (1 > pstruWjPassedPos->u8OCTtollingAmountNum)*/
        )
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjPassedPos->u8OCTtollingAmountNum = %d",
                     pstruWjPassedPos->u8OCTtollingAmountNum);
            return false;
        }
        pstruAsnPassedPos->tollingAmount = CALLOC(1, sizeof(OCTET_STRING_t));
        if (NULL == pstruAsnPassedPos->tollingAmount)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        pstruAsnPassedPos->tollingAmount->size = pstruWjPassedPos->u8OCTtollingAmountNum;
        pstruAsnPassedPos->tollingAmount->buf = CALLOC(1, pstruAsnPassedPos->tollingAmount->size);
        if (NULL == pstruAsnPassedPos->tollingAmount->buf)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        memcpy(pstruAsnPassedPos->tollingAmount->buf, pstruWjPassedPos->u8OCTtollingAmount, pstruAsnPassedPos->tollingAmount->size);
    }
    else
    {
        pstruAsnPassedPos->tollingAmount = NULL;
    }

    return true;
}
/**
* @brief     WJV2_PassedPos_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PassedPos_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PassedPos *pstruWjPassedPos = (WJV2_STRU_PassedPos *)pvoidWjDf;
    PassedPos_t *pstruAsnPassedPos = (PassedPos_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_TollingPos_DfDec(&(pstruAsnPassedPos->tollingPos), &(pstruWjPassedPos->strutollingPos));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_TollingPos_DfDec is err");
        return false;
    }
    n32Ret = WJV2_DDateTime_DfDec(&(pstruAsnPassedPos->tollingTime), &(pstruWjPassedPos->strutollingTime));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_DDateTime_DfDec is err");
        return false;
    }
    if (NULL != pstruAsnPassedPos->tollingAmount)
    {
        if ((WJV2_MAX_OCTtollingAmount_SIZE != pstruAsnPassedPos->tollingAmount->size) /*||
            (1 > pstruAsnPassedPos->tollingAmount->size)*/
        )
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruAsnPassedPos->tollingAmount->size = %d",
                     pstruAsnPassedPos->tollingAmount->size);
            return false;
        }
        pstruWjPassedPos->u8OCTtollingAmountNum = pstruAsnPassedPos->tollingAmount->size;
        if (NULL == pstruAsnPassedPos->tollingAmount->buf)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        memcpy(pstruWjPassedPos->u8OCTtollingAmount, pstruAsnPassedPos->tollingAmount->buf, pstruAsnPassedPos->tollingAmount->size);
        pstruWjPassedPos->u8tollingAmountPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPassedPos->u8tollingAmountPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_PathPlanning_DfEnc编码函数
* @details   协议栈PathPlanning编解码中 统一PathPlanning的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PathPlanning_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PathPlanning *pstruWjPathPlanning = (WJV2_STRU_PathPlanning *)pvoidWjDf;
    PathPlanning_t *pstruAsnPathPlanning = (PathPlanning_t *)pvoidAsnDf;
    PathPlanningPoint_t *pstruAsnPathPlanning_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_PathPlanning_LEN < pstruWjPathPlanning->u8PathPlanningPointNum) ||
        (WJV2_MIN_LIST_PathPlanning_LEN > pstruWjPathPlanning->u8PathPlanningPointNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPathPlanning->u8PathPlanningPointNum= %d",
                 pstruWjPathPlanning->u8PathPlanningPointNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjPathPlanning->u8PathPlanningPointNum; u32i++)
    {
        pstruAsnPathPlanning_node = CALLOC(1, sizeof(PathPlanningPoint_t));
        if (NULL == pstruAsnPathPlanning_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PathPlanningPoint_DfEnc(pstruAsnPathPlanning_node, &(pstruWjPathPlanning->struPathPlanningPoint[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PathPlanningPoint_DfEnc is err");
            FREEMEM(pstruAsnPathPlanning_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnPathPlanning->list), pstruAsnPathPlanning_node);
    }

    return true;
}
/**
* @brief     WJV2_PathPlanning_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PathPlanning_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PathPlanning *pstruWjPathPlanning = (WJV2_STRU_PathPlanning *)pvoidWjDf;
    PathPlanning_t *pstruAsnPathPlanning = (PathPlanning_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_PathPlanning_LEN < pstruAsnPathPlanning->list.count) ||
        (WJV2_MIN_LIST_PathPlanning_LEN > pstruAsnPathPlanning->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPathPlanning->list.count= %d",
                 pstruAsnPathPlanning->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnPathPlanning->list.count; u32i++)
    {
        n32Ret = WJV2_PathPlanningPoint_DfDec(pstruAsnPathPlanning->list.array[u32i], &(pstruWjPathPlanning->struPathPlanningPoint[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PathPlanningPoint_DfEnc is err");
            return false;
        }
    }
    pstruWjPathPlanning->u8PathPlanningPointNum = (uint8_t)u32i;

    return true;
}
/**
* @brief     WJV2_PathPlanningPoint_DfEnc编码函数
* @details   协议栈PathPlanningPoint编解码中 统一PathPlanningPoint的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PathPlanningPoint_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PathPlanningPoint *pstruWjPathPlanningPoint = (WJV2_STRU_PathPlanningPoint *)pvoidWjDf;
    PathPlanningPoint_t *pstruAsnPathPlanningPoint = (PathPlanningPoint_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (WJV2_PRESENT == pstruWjPathPlanningPoint->u8ReferenceLinkPresent)
    {
        pstruAsnPathPlanningPoint->posInMap = CALLOC(1, sizeof(struct ReferenceLink));
        if (NULL == pstruAsnPathPlanningPoint->posInMap)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ReferenceLink_DfEnc(pstruAsnPathPlanningPoint->posInMap, &(pstruWjPathPlanningPoint->struposInMap));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferenceLink_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnPathPlanningPoint->posInMap = NULL;
    }
    n32Ret = WJV2_PositionOffsetLLV_DfEnc(&(pstruAsnPathPlanningPoint->pos), &(pstruWjPathPlanningPoint->strupos));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PositionOffsetLLV_DfEnc is err");
        return false;
    }
    if (WJV2_PRESENT == pstruWjPathPlanningPoint->u8posAccuracyPresent)
    {
        pstruAsnPathPlanningPoint->posAccuracy = CALLOC(1, sizeof(struct PositionConfidenceSet));
        if (NULL == pstruAsnPathPlanningPoint->posAccuracy)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PositionConfidenceSet_DfEnc(pstruAsnPathPlanningPoint->posAccuracy, &(pstruWjPathPlanningPoint->strupos));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionConfidenceSet_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnPathPlanningPoint->posAccuracy = NULL;
    }
    if (WJV2_PRESENT == pstruWjPathPlanningPoint->u8speedPresent)
    {
        if ((WJV2_MAX_SPEED_SIZE < pstruWjPathPlanningPoint->n32speed) ||
            (WJV2_MIN_SPEED_SIZE > pstruWjPathPlanningPoint->n32speed))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjPathPlanningPoint->n32speed = %d",
                     pstruWjPathPlanningPoint->n32speed);
            return false;
        }
        pstruAsnPathPlanningPoint->speed = CALLOC(1, sizeof(Speed_t));
        if (NULL == pstruAsnPathPlanningPoint->speed)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnPathPlanningPoint->speed) = pstruWjPathPlanningPoint->n32speed;
    }
    else
    {
        pstruAsnPathPlanningPoint->speed = NULL;
    }
    if (WJV2_PRESENT == pstruWjPathPlanningPoint->u8speedCfdPresent)
    {
        pstruAsnPathPlanningPoint->speedCfd = CALLOC(1, sizeof(SpeedConfidence_t));
        if (NULL == pstruAsnPathPlanningPoint->speedCfd)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnPathPlanningPoint->speedCfd) = pstruWjPathPlanningPoint->enumspeedCfd;
    }
    else
    {
        pstruAsnPathPlanningPoint->speedCfd = NULL;
    }
    if (WJV2_PRESENT == pstruWjPathPlanningPoint->u8headingPresent)
    {
        if ((WJV2_MAX_HEADING_SIZE < pstruWjPathPlanningPoint->n32heading) ||
            (WJV2_MIN_HEADING_SIZE > pstruWjPathPlanningPoint->n32heading))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjPathPlanningPoint->n32heading = %d",
                     pstruWjPathPlanningPoint->n32heading);
            return false;
        }
        pstruAsnPathPlanningPoint->heading = CALLOC(1, sizeof(Heading_t));
        if (NULL == pstruAsnPathPlanningPoint->heading)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnPathPlanningPoint->heading) = pstruWjPathPlanningPoint->n32heading;
    }
    else
    {
        pstruAsnPathPlanningPoint->heading = NULL;
    }
    if (WJV2_PRESENT == pstruWjPathPlanningPoint->u8headingCfdPresent)
    {
        pstruAsnPathPlanningPoint->headingCfd = CALLOC(1, sizeof(HeadingConfidence_t));
        if (NULL == pstruAsnPathPlanningPoint->headingCfd)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnPathPlanningPoint->headingCfd) = pstruWjPathPlanningPoint->enumheadingCfd;
    }
    else
    {
        pstruAsnPathPlanningPoint->headingCfd = NULL;
    }
    if (WJV2_PRESENT == pstruWjPathPlanningPoint->u8accelSetPresent)
    {
        pstruAsnPathPlanningPoint->accelSet = CALLOC(1, sizeof(struct AccelerationSet4Way));
        if (NULL == pstruAsnPathPlanningPoint->accelSet)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_AccelerationSet4Way_DfEnc(pstruAsnPathPlanningPoint->accelSet, &(pstruWjPathPlanningPoint->struaccelSet));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AccelerationSet4Way_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnPathPlanningPoint->accelSet = NULL;
    }
    if (WJV2_PRESENT == pstruWjPathPlanningPoint->u8acc4WayConfidencePresent)
    {
        pstruAsnPathPlanningPoint->acc4WayConfidence = CALLOC(1, sizeof(struct AccSet4WayConfidence));
        if (NULL == pstruAsnPathPlanningPoint->acc4WayConfidence)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_AccSet4WayConfidence_DfEnc(pstruAsnPathPlanningPoint->acc4WayConfidence, &(pstruWjPathPlanningPoint->struacc4WayConfidence));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AccSet4WayConfidence_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnPathPlanningPoint->acc4WayConfidence = NULL;
    }
    if (WJV2_PRESENT == pstruWjPathPlanningPoint->u8estimatedTimePresent)
    {
        if ((WJV2_MAX_TIMEOFFSET_SIZE < pstruWjPathPlanningPoint->n32estimatedTime) ||
            (WJV2_MIN_TIMEOFFSET_SIZE > pstruWjPathPlanningPoint->n32estimatedTime))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjPathPlanningPoint->n32estimatedTime = %d",
                     pstruWjPathPlanningPoint->n32estimatedTime);
            return false;
        }
        pstruAsnPathPlanningPoint->estimatedTime = CALLOC(1, sizeof(TimeOffset_t));
        if (NULL == pstruAsnPathPlanningPoint->estimatedTime)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnPathPlanningPoint->estimatedTime) = pstruWjPathPlanningPoint->n32estimatedTime;
    }
    else
    {
        pstruAsnPathPlanningPoint->estimatedTime = NULL;
    }
    if (WJV2_PRESENT == pstruWjPathPlanningPoint->u8timeConfidencePresent)
    {
        if ((WJV2_MAX_CONFIDENCE_SIZE < pstruWjPathPlanningPoint->n32timeConfidence) ||
            (WJV2_MIN_CONFIDENCE_SIZE > pstruWjPathPlanningPoint->n32timeConfidence))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjPathPlanningPoint->n32timeConfidence = %d",
                     pstruWjPathPlanningPoint->n32timeConfidence);
            return false;
        }
        pstruAsnPathPlanningPoint->timeConfidence = CALLOC(1, sizeof(Confidence_t));
        if (NULL == pstruAsnPathPlanningPoint->timeConfidence)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnPathPlanningPoint->timeConfidence) = pstruWjPathPlanningPoint->n32timeConfidence;
    }
    else
    {
        pstruAsnPathPlanningPoint->timeConfidence = NULL;
    }

    return true;
}
/**
* @brief     WJV2_PathPlanningPoint_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PathPlanningPoint_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PathPlanningPoint *pstruWjPathPlanningPoint = (WJV2_STRU_PathPlanningPoint *)pvoidWjDf;
    PathPlanningPoint_t *pstruAsnPathPlanningPoint = (PathPlanningPoint_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (NULL != pstruAsnPathPlanningPoint->posInMap)
    {
        if (NULL == pstruAsnPathPlanningPoint->posInMap)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "pstruAsnPathPlanningPoint->posInMap is NULL");
            return false;
        }
        n32Ret = WJV2_ReferenceLink_DfDec(pstruAsnPathPlanningPoint->posInMap, &(pstruWjPathPlanningPoint->struposInMap));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferenceLink_DfDec is err");
            return false;
        }
        pstruWjPathPlanningPoint->u8ReferenceLinkPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPathPlanningPoint->u8ReferenceLinkPresent = WJV2_ABSENT;
    }
    n32Ret = WJV2_PositionOffsetLLV_DfDec(&(pstruAsnPathPlanningPoint->pos), &(pstruWjPathPlanningPoint->strupos));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PositionOffsetLLV_DfDec is err");
        return false;
    }
    if (NULL != pstruAsnPathPlanningPoint->posAccuracy)
    {
        if (NULL == pstruAsnPathPlanningPoint->posAccuracy)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "pstruAsnPathPlanningPoint->posAccuracyis NULL");
            return false;
        }
        n32Ret = WJV2_PositionConfidenceSet_DfDec(pstruAsnPathPlanningPoint->posAccuracy, &(pstruWjPathPlanningPoint->strupos));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionConfidenceSet_DfDec is err");
            return false;
        }
        pstruWjPathPlanningPoint->u8posAccuracyPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPathPlanningPoint->u8posAccuracyPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnPathPlanningPoint->speed)
    {
        if ((WJV2_MAX_SPEED_SIZE < *(pstruAsnPathPlanningPoint->speed)) ||
            (WJV2_MIN_SPEED_SIZE > *(pstruAsnPathPlanningPoint->speed)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnPathPlanningPoint->speed) = %d",
                     *(pstruAsnPathPlanningPoint->speed));
            return false;
        }
        pstruWjPathPlanningPoint->n32speed = *(pstruAsnPathPlanningPoint->speed);
        pstruWjPathPlanningPoint->u8speedPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPathPlanningPoint->u8speedPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnPathPlanningPoint->speedCfd)
    {
        pstruWjPathPlanningPoint->enumspeedCfd = *(pstruAsnPathPlanningPoint->speedCfd);
        pstruWjPathPlanningPoint->u8speedCfdPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPathPlanningPoint->u8speedCfdPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnPathPlanningPoint->heading)
    {
        if ((WJV2_MAX_HEADING_SIZE < *(pstruAsnPathPlanningPoint->heading)) ||
            (WJV2_MIN_HEADING_SIZE > *(pstruAsnPathPlanningPoint->heading)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnPathPlanningPoint->heading) = %d",
                     *(pstruAsnPathPlanningPoint->heading));
            return false;
        }
        pstruWjPathPlanningPoint->n32heading = *(pstruAsnPathPlanningPoint->heading);
        pstruWjPathPlanningPoint->u8headingPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPathPlanningPoint->u8headingPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnPathPlanningPoint->headingCfd)
    {
        pstruWjPathPlanningPoint->enumheadingCfd = *(pstruAsnPathPlanningPoint->headingCfd);
        pstruWjPathPlanningPoint->u8headingCfdPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPathPlanningPoint->u8headingCfdPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnPathPlanningPoint->accelSet)
    {
        if (NULL == pstruAsnPathPlanningPoint->accelSet)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "pstruAsnPathPlanningPoint->accelSet is NULL");
            return false;
        }
        n32Ret = WJV2_AccelerationSet4Way_DfDec(pstruAsnPathPlanningPoint->accelSet, &(pstruWjPathPlanningPoint->struaccelSet));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AccelerationSet4Way_DfDec is err");
            return false;
        }
        pstruWjPathPlanningPoint->u8accelSetPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPathPlanningPoint->u8accelSetPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnPathPlanningPoint->acc4WayConfidence)
    {
        if (NULL == pstruAsnPathPlanningPoint->acc4WayConfidence)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "pstruAsnPathPlanningPoint->acc4WayConfidence is NULL");
            return false;
        }
        n32Ret = WJV2_AccSet4WayConfidence_DfDec(pstruAsnPathPlanningPoint->acc4WayConfidence, &(pstruWjPathPlanningPoint->struacc4WayConfidence));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AccSet4WayConfidence_DfDec is err");
            return false;
        }
        pstruWjPathPlanningPoint->u8acc4WayConfidencePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPathPlanningPoint->u8acc4WayConfidencePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnPathPlanningPoint->estimatedTime)
    {
        if ((WJV2_MAX_TIMEOFFSET_SIZE < *(pstruAsnPathPlanningPoint->estimatedTime)) ||
            (WJV2_MIN_TIMEOFFSET_SIZE > *(pstruAsnPathPlanningPoint->estimatedTime)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnPathPlanningPoint->estimatedTime) = %d",
                     *(pstruAsnPathPlanningPoint->estimatedTime));
            return false;
        }
        pstruWjPathPlanningPoint->n32estimatedTime = *(pstruAsnPathPlanningPoint->estimatedTime);
        pstruWjPathPlanningPoint->u8estimatedTimePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPathPlanningPoint->u8estimatedTimePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnPathPlanningPoint->timeConfidence)
    {
        if ((WJV2_MAX_CONFIDENCE_SIZE < *(pstruAsnPathPlanningPoint->timeConfidence)) ||
            (WJV2_MIN_CONFIDENCE_SIZE > *(pstruAsnPathPlanningPoint->timeConfidence)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnPathPlanningPoint->timeConfidence) = %d",
                     *(pstruAsnPathPlanningPoint->timeConfidence));
            return false;
        }
        pstruWjPathPlanningPoint->n32timeConfidence = *(pstruAsnPathPlanningPoint->timeConfidence);
        pstruWjPathPlanningPoint->u8timeConfidencePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPathPlanningPoint->u8timeConfidencePresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_PaymentInfo_DfEnc编码函数
* @details   协议栈PaymentInfo编解码中 统一PaymentInfo的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PaymentInfo_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PaymentInfo *pstruWjPaymentInfo = (WJV2_STRU_PaymentInfo *)pvoidWjDf;
    PaymentInfo_t *pstruAsnPaymentInfo = (PaymentInfo_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (WJV2_PaymentInfo_PR_paymentInfoType1 == pstruWjPaymentInfo->present)
    {
        pstruAsnPaymentInfo->present = pstruWjPaymentInfo->present;
        n32Ret = WJV2_PaymentInfoType1_DfEnc(&(pstruAsnPaymentInfo->choice.paymentInfoType1), &(pstruWjPaymentInfo->choice.strupaymentInfoType1));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PaymentInfoType1_DfEnc is err");
            return false;
        }
    }
    else if (WJV2_PaymentInfo_PR_NOTHING == pstruWjPaymentInfo->present)
    {
        pstruAsnPaymentInfo->present = PaymentInfo_PR_NOTHING;
    }
    else
    {
        pstruAsnPaymentInfo->present = PaymentInfo_PR_NOTHING;
    }

    return true;
}
/**
* @brief     WJV2_PaymentInfo_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PaymentInfo_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PaymentInfo *pstruWjPaymentInfo = (WJV2_STRU_PaymentInfo *)pvoidWjDf;
    PaymentInfo_t *pstruAsnPaymentInfo = (PaymentInfo_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (PaymentInfo_PR_paymentInfoType1 == pstruAsnPaymentInfo->present)
    {
        pstruWjPaymentInfo->present = pstruAsnPaymentInfo->present;
        n32Ret = WJV2_PaymentInfoType1_DfDec(&(pstruAsnPaymentInfo->choice.paymentInfoType1), &(pstruWjPaymentInfo->choice.strupaymentInfoType1));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PaymentInfoType1_DfDec is err");
            return false;
        }
    }
    else if (PaymentInfo_PR_NOTHING == pstruAsnPaymentInfo->present)
    {
        pstruWjPaymentInfo->present = WJV2_PaymentInfo_PR_NOTHING;
    }
    else
    {
        pstruWjPaymentInfo->present = WJV2_PaymentInfo_PR_NOTHING;
    }

    return true;
}
/**
* @brief     WJV2_PaymentInfoType1_DfEnc编码函数
* @details   协议栈PaymentInfoType1编解码中 统一PaymentInfoType1的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PaymentInfoType1_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PaymentInfoType1 *pstruWjPaymentInfoType1 = (WJV2_STRU_PaymentInfoType1 *)pvoidWjDf;
    PaymentInfoType1_t *pstruAsnPaymentInfoType1 = (PaymentInfoType1_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (WJV2_PRESENT == pstruWjPaymentInfoType1->u8tollingNodeInfoPresent)
    {
        pstruAsnPaymentInfoType1->tollingNodeInfo = CALLOC(1, sizeof(struct TollingNodeInfo));
        if (NULL == pstruAsnPaymentInfoType1->tollingNodeInfo)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_TollingNodeInfo_DfEnc(pstruAsnPaymentInfoType1->tollingNodeInfo, &(pstruWjPaymentInfoType1->strutollingNodeInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_TollingNodeInfo_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnPaymentInfoType1->tollingNodeInfo = NULL;
    }
    if (WJV2_PRESENT == pstruWjPaymentInfoType1->u8tollInfoPresent)
    {
        pstruAsnPaymentInfoType1->tollInfo = CALLOC(1, sizeof(struct TollInfo));
        if (NULL == pstruAsnPaymentInfoType1->tollInfo)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_TollInfo_DfEnc(pstruAsnPaymentInfoType1->tollInfo, &(pstruWjPaymentInfoType1->strutollInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_TollInfo_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnPaymentInfoType1->tollInfo = NULL;
    }
    if (WJV2_PRESENT == pstruWjPaymentInfoType1->u8serviceInfoPresent)
    {
        if ((WJV2_MAX_OCTserviceInfo_SIZE < pstruWjPaymentInfoType1->u16OCTserviceInfoNum) ||
            (WJV2_MIN_OCTserviceInfo_SIZE > pstruWjPaymentInfoType1->u16OCTserviceInfoNum))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjPaymentInfoType1->u16OCTserviceInfoNum = %d",
                     pstruWjPaymentInfoType1->u16OCTserviceInfoNum);
            return false;
        }
        pstruAsnPaymentInfoType1->serviceInfo = CALLOC(1, sizeof(OCTET_STRING_t));
        if (NULL == pstruAsnPaymentInfoType1->serviceInfo)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        pstruAsnPaymentInfoType1->serviceInfo->size = pstruWjPaymentInfoType1->u16OCTserviceInfoNum;
        pstruAsnPaymentInfoType1->serviceInfo->buf = CALLOC(1, pstruAsnPaymentInfoType1->serviceInfo->size);
        if (NULL == pstruAsnPaymentInfoType1->serviceInfo->buf)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        memcpy(pstruAsnPaymentInfoType1->serviceInfo->buf, pstruWjPaymentInfoType1->u8OCTserviceInfo, pstruAsnPaymentInfoType1->serviceInfo->size);
    }
    else
    {
        pstruAsnPaymentInfoType1->serviceInfo = NULL;
    }

    return true;
}
/**
* @brief     WJV2_PaymentInfoType1_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PaymentInfoType1_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PaymentInfoType1 *pstruWjPaymentInfoType1 = (WJV2_STRU_PaymentInfoType1 *)pvoidWjDf;
    PaymentInfoType1_t *pstruAsnPaymentInfoType1 = (PaymentInfoType1_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (NULL != pstruAsnPaymentInfoType1->tollingNodeInfo)
    {
        if (NULL == pstruAsnPaymentInfoType1->tollingNodeInfo)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DE_MODULE,
                     "pstruAsnPaymentInfoType1->tollingNodeInfo is NULL");
            return false;
        }
        n32Ret = WJV2_TollingNodeInfo_DfDec(pstruAsnPaymentInfoType1->tollingNodeInfo, &(pstruWjPaymentInfoType1->strutollingNodeInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_TollingNodeInfo_DfDec is err");
            return false;
        }
        pstruWjPaymentInfoType1->u8tollingNodeInfoPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPaymentInfoType1->u8tollingNodeInfoPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnPaymentInfoType1->tollInfo)
    {
        if (NULL == pstruAsnPaymentInfoType1->tollInfo)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DE_MODULE,
                     "pstruAsnPaymentInfoType1->tollInfo is NULL");
            return false;
        }
        n32Ret = WJV2_TollInfo_DfDec(pstruAsnPaymentInfoType1->tollInfo, &(pstruWjPaymentInfoType1->strutollInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_TollInfo_DfDec is err");
            return false;
        }
        pstruWjPaymentInfoType1->u8tollInfoPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPaymentInfoType1->u8tollInfoPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnPaymentInfoType1->serviceInfo)
    {
        if ((WJV2_MAX_OCTserviceInfo_SIZE < pstruAsnPaymentInfoType1->serviceInfo->size) ||
            (WJV2_MIN_OCTserviceInfo_SIZE > pstruAsnPaymentInfoType1->serviceInfo->size))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruAsnPaymentInfoType1->serviceInfo->size = %d",
                     pstruAsnPaymentInfoType1->serviceInfo->size);
            return false;
        }
        pstruWjPaymentInfoType1->u16OCTserviceInfoNum = pstruAsnPaymentInfoType1->serviceInfo->size;
        if (NULL == pstruAsnPaymentInfoType1->serviceInfo->buf)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "pstruAsnPaymentInfoType1->serviceInfo->buf is NULL");
            return false;
        }
        memcpy(pstruWjPaymentInfoType1->u8OCTserviceInfo, pstruAsnPaymentInfoType1->serviceInfo->buf, pstruAsnPaymentInfoType1->serviceInfo->size);
        pstruWjPaymentInfoType1->u8serviceInfoPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPaymentInfoType1->u8serviceInfoPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_PaymentList_DfEnc编码函数
* @details   协议栈PaymentList编解码中 统一PaymentList的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PaymentList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PaymentList *pstruWjPaymentList = (WJV2_STRU_PaymentList *)pvoidWjDf;
    PaymentList_t *pstruAsnPaymentList = (PaymentList_t *)pvoidAsnDf;
    ApplicationParameter_t *pstruAsnApplicationParameter_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_Payment_LEN < pstruWjPaymentList->u8ApplicationParameterNum) ||
        (WJV2_MIN_LIST_Payment_LEN > pstruWjPaymentList->u8ApplicationParameterNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPaymentList->u8ApplicationParameterNum = %d",
                 pstruWjPaymentList->u8ApplicationParameterNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjPaymentList->u8ApplicationParameterNum; u32i++)
    {
        pstruAsnApplicationParameter_node = CALLOC(1, sizeof(ApplicationParameter_t));
        if (NULL == pstruAsnApplicationParameter_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ApplicationParameter_DfEnc(pstruAsnApplicationParameter_node, &(pstruWjPaymentList->struApplicationParameter[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Movement_DfEnc is err");
            FREEMEM(pstruAsnApplicationParameter_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnPaymentList->list), pstruAsnApplicationParameter_node);
    }

    return true;
}
/**
* @brief     WJV2_PaymentList_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PaymentList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PaymentList *pstruWjPaymentList = (WJV2_STRU_PaymentList *)pvoidWjDf;
    PaymentList_t *pstruAsnPaymentList = (PaymentList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_Payment_LEN < pstruAsnPaymentList->list.count) ||
        (WJV2_MIN_LIST_Payment_LEN > pstruAsnPaymentList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPaymentList->list.array = %d",
                 pstruAsnPaymentList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnPaymentList->list.count; u32i++)
    {
        n32Ret = WJV2_ApplicationParameter_DfDec(pstruAsnPaymentList->list.array[u32i],
                                                 &(pstruWjPaymentList->struApplicationParameter[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ApplicationParameter_DfDec is err");
            return false;
        }
    }
    pstruWjPaymentList->u8ApplicationParameterNum = (uint8_t)u32i;

    return true;
}
/**
* @brief     WJV2_PersonalExtensions_DfEnc编码函数
* @details   协议栈PersonalExtensions编解码中 统一PersonalExtensions的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PersonalExtensions_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PersonalExtensions *pstruWjPersonalExtensions = (WJV2_STRU_PersonalExtensions *)pvoidWjDf;
    PersonalExtensions_t *pstruAsnPersonalExtensions = (PersonalExtensions_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (WJV2_PRESENT == pstruWjPersonalExtensions->u8useStatePresent)
    {
        pstruAsnPersonalExtensions->useState = CALLOC(1, sizeof(PersonalDeviceUsageState_t));
        if (NULL == pstruAsnPersonalExtensions->useState)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PersonalDeviceUsageState_DeEnc(pstruAsnPersonalExtensions->useState, &(pstruWjPersonalExtensions->bituseState));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PersonalDeviceUsageState_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnPersonalExtensions->useState = NULL;
    }
    if (WJV2_PRESENT == pstruWjPersonalExtensions->u8assistTypePresent)
    {
        pstruAsnPersonalExtensions->assistType = CALLOC(1, sizeof(PersonalAssistive_t));
        if (NULL == pstruAsnPersonalExtensions->assistType)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PersonalAssistive_DeEnc(pstruAsnPersonalExtensions->assistType, &(pstruWjPersonalExtensions->bitassistType));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PersonalAssistive_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnPersonalExtensions->assistType = NULL;
    }

    return true;
}
/**
* @brief     WJV2_PersonalExtensions_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PersonalExtensions_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PersonalExtensions *pstruWjPersonalExtensions = (WJV2_STRU_PersonalExtensions *)pvoidWjDf;
    PersonalExtensions_t *pstruAsnPersonalExtensions = (PersonalExtensions_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (NULL != pstruAsnPersonalExtensions->useState)
    {

        n32Ret = WJV2_PersonalDeviceUsageState_DeDec(pstruAsnPersonalExtensions->useState, &(pstruWjPersonalExtensions->bituseState));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PersonalDeviceUsageState_DeDec is err");
            return false;
        }
        pstruWjPersonalExtensions->u8useStatePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPersonalExtensions->u8useStatePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnPersonalExtensions->assistType)
    {

        n32Ret = WJV2_PersonalAssistive_DeDec(pstruAsnPersonalExtensions->assistType, &(pstruWjPersonalExtensions->bitassistType));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PersonalAssistive_DeDec is err");
            return false;
        }
        pstruWjPersonalExtensions->u8assistTypePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPersonalExtensions->u8assistTypePresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_PersonalRequest_DfEnc编码函数
* @details   协议栈PersonalRequest编解码中 统一PersonalRequest的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PersonalRequest_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PersonalRequest *pstruWjPersonalRequest = (WJV2_STRU_PersonalRequest *)pvoidWjDf;
    PersonalRequest_t *pstruAsnPersonalRequest = (PersonalRequest_t *)pvoidAsnDf;
    if (WJV2_PRESENT == pstruWjPersonalRequest->u8crossingPresent)
    {
        pstruAsnPersonalRequest->crossing = CALLOC(1, sizeof(PersonalCrossing_t));
        if (NULL == pstruAsnPersonalRequest->crossing)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnPersonalRequest->crossing) = pstruWjPersonalRequest->enumcrossing;
    }
    else
    {
        pstruAsnPersonalRequest->crossing = NULL;
    }

    return true;
}
/**
* @brief     WJV2_PersonalRequest_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PersonalRequest_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PersonalRequest *pstruWjPersonalRequest = (WJV2_STRU_PersonalRequest *)pvoidWjDf;
    PersonalRequest_t *pstruAsnPersonalRequest = (PersonalRequest_t *)pvoidAsnDf;
    if (NULL != pstruAsnPersonalRequest->crossing)
    {
        pstruWjPersonalRequest->enumcrossing = *(pstruAsnPersonalRequest->crossing);
        pstruWjPersonalRequest->u8crossingPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPersonalRequest->u8crossingPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_Planning_DfEnc编码函数
* @details   协议栈Planning编解码中 统一Planning的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_Planning_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Planning *pstruWjPlanning = (WJV2_STRU_Planning *)pvoidWjDf;
    Planning_t *pstruAsnPlanning = (Planning_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (WJV2_PRESENT == pstruWjPlanning->u8durationPresent)
    {
        pstruAsnPlanning->duration = CALLOC(1, sizeof(PlanningDuration_t));
        if (NULL == pstruAsnPlanning->duration)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnPlanning->duration) = pstruWjPlanning->n32duration;
    }
    else
    {
        pstruAsnPlanning->duration = NULL;
    }
    if (WJV2_PRESENT == pstruWjPlanning->u8planConfidencePresent)
    {
        pstruAsnPlanning->planConfidence = CALLOC(1, sizeof(Confidence_t));
        if (NULL == pstruAsnPlanning->planConfidence)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnPlanning->planConfidence) = pstruWjPlanning->n32planConfidence;
    }
    else
    {
        pstruAsnPlanning->planConfidence = NULL;
    }
    if (WJV2_PRESENT == pstruWjPlanning->u8drivingBehaviorPresent)
    {
        pstruAsnPlanning->drivingBehavior = CALLOC(1, sizeof(DriveBehavior_t));
        if (NULL == pstruAsnPlanning->drivingBehavior)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_DriveBehavior_DeEnc(pstruAsnPlanning->drivingBehavior, &(pstruWjPlanning->bitdrivingBehavior));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DriveBehavior_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnPlanning->drivingBehavior = NULL;
    }
    if (WJV2_PRESENT == pstruWjPlanning->u8pathPlanningPresent)
    {
        pstruAsnPlanning->pathPlanning = CALLOC(1, sizeof(struct PathPlanning));
        if (NULL == pstruAsnPlanning->pathPlanning)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PathPlanning_DfEnc(pstruAsnPlanning->pathPlanning, &(pstruWjPlanning->strupathPlanning));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PathPlanning_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnPlanning->pathPlanning = NULL;
    }
    return true;
}
/**
* @brief     WJV2_Planning_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_Planning_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Planning *pstruWjPlanning = (WJV2_STRU_Planning *)pvoidWjDf;
    Planning_t *pstruAsnPlanning = (Planning_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (NULL != pstruAsnPlanning->duration)
    {
        pstruWjPlanning->n32duration = *(pstruAsnPlanning->duration);
        pstruWjPlanning->u8durationPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPlanning->u8durationPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnPlanning->planConfidence)
    {
        pstruWjPlanning->n32planConfidence = *(pstruAsnPlanning->planConfidence);
        pstruWjPlanning->u8planConfidencePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPlanning->u8planConfidencePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnPlanning->drivingBehavior)
    {
        if (NULL == pstruAsnPlanning->drivingBehavior)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "pstruAsnPlanning->pathPlanning is NULL");
            return false;
        }
        n32Ret = WJV2_DriveBehavior_DeDec(pstruAsnPlanning->drivingBehavior, &(pstruWjPlanning->bitdrivingBehavior));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DriveBehavior_DeDec is err");
            return false;
        }
        pstruWjPlanning->u8drivingBehaviorPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPlanning->u8drivingBehaviorPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnPlanning->pathPlanning)
    {
        if (NULL == pstruAsnPlanning->pathPlanning)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "pstruAsnPlanning->pathPlanning is NULL");
            return false;
        }
        n32Ret = WJV2_PathPlanning_DfDec(pstruAsnPlanning->pathPlanning, &(pstruWjPlanning->strupathPlanning));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PathPlanning_DfDec is err");
            return false;
        }
        pstruWjPlanning->u8pathPlanningPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjPlanning->u8pathPlanningPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_PlanningList_DfEnc编码函数
* @details   协议栈PlanningList编解码中 统一PlanningList的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PlanningList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PlanningList *pstruWjPlanningList = (WJV2_STRU_PlanningList *)pvoidWjDf;
    PlanningList_t *pstruAsnPlanningList = (PlanningList_t *)pvoidAsnDf;
    Planning_t *pstruAsnPlanning_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_Planning_LEN < pstruWjPlanningList->u8PlanningListNum) ||
        (WJV2_MIN_LIST_Planning_LEN > pstruWjPlanningList->u8PlanningListNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPlanningList->u8PlanningListNum = %d",
                 pstruWjPlanningList->u8PlanningListNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjPlanningList->u8PlanningListNum; u32i++)
    {
        pstruAsnPlanning_node = CALLOC(1, sizeof(Planning_t));
        if (NULL == pstruAsnPlanning_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_Planning_DfEnc(pstruAsnPlanning_node, &(pstruWjPlanningList->struPlanning[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Planning_DfEnc is err");
            FREEMEM(pstruAsnPlanning_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnPlanningList->list), pstruAsnPlanning_node);
    }
    return true;
}
/**
* @brief     WJV2_PlanningList_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PlanningList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PlanningList *pstruWjPlanningList = (WJV2_STRU_PlanningList *)pvoidWjDf;
    PlanningList_t *pstruAsnPlanningList = (PlanningList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_Planning_LEN < pstruAsnPlanningList->list.count) ||
        (WJV2_MIN_LIST_Planning_LEN > pstruAsnPlanningList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPlanningList->list.count = %d",
                 pstruAsnPlanningList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnPlanningList->list.count; u32i++)
    {
        n32Ret = WJV2_Planning_DfDec(pstruAsnPlanningList->list.array[u32i],
                                     &(pstruWjPlanningList->struPlanning[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Planning_DfDec is err");
            return false;
        }
    }
    pstruWjPlanningList->u8PlanningListNum = (uint8_t)u32i;

    return true;
}
/**
* @brief     WJV2_Polygon_DfEnc编码函数
* @details   协议栈Polygon编解码中 统一Polygon的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_Polygon_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Polygon *pstruWjPolygon = (WJV2_STRU_Polygon *)pvoidWjDf;
    Polygon_t *pstruAsnPolygon = (Polygon_t *)pvoidAsnDf;
    PositionOffsetLLV_t *pstruAsnPositionOffsetLLV = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_Polygon_LEN < pstruWjPolygon->u8PositionOffsetLLVNum) ||
        (WJV2_MIN_LIST_Polygon_LEN > pstruWjPolygon->u8PositionOffsetLLVNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjPolygon->u8PositionOffsetLLVNum = %d",
                 pstruWjPolygon->u8PositionOffsetLLVNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjPolygon->u8PositionOffsetLLVNum; u32i++)
    {
        pstruAsnPositionOffsetLLV = CALLOC(1, sizeof(PositionOffsetLLV_t));
        if (NULL == pstruAsnPositionOffsetLLV)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PositionOffsetLLV_DfEnc(pstruAsnPositionOffsetLLV, &(pstruWjPolygon->struPositionOffsetLLV[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionOffsetLLV_DfEnc is err");
            FREEMEM(pstruAsnPositionOffsetLLV);
            return false;
        }
        asn_sequence_add(&(pstruAsnPolygon->list), pstruAsnPositionOffsetLLV);
    }

    return true;
}
/**
* @brief     WJV2_Polygon_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_Polygon_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Polygon *pstruWjPolygon = (WJV2_STRU_Polygon *)pvoidWjDf;
    Polygon_t *pstruAsnPolygon = (Polygon_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_Polygon_LEN < pstruAsnPolygon->list.count) ||
        (WJV2_MIN_LIST_Polygon_LEN > pstruAsnPolygon->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnPolygon->list.count = %d",
                 pstruAsnPolygon->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnPolygon->list.count; u32i++)
    {
        n32Ret = WJV2_PositionOffsetLLV_DfDec(pstruAsnPolygon->list.array[u32i], &(pstruWjPolygon->struPositionOffsetLLV[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionOffsetLLV_DfDec is err");
            return false;
        }
    }

    return true;
}

/**
* @brief     WJV2_non_motorVehicleProhibitedZones_DfEnc
* @details   协议栈Polygon编解码中 统一Polygon的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_non_motorVehicleProhibitedZones_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_non_motorVehicleProhibitedZones *pstruWjVehicleProhibitedZones = (WJV2_STRU_non_motorVehicleProhibitedZones *)pvoidWjDf;
    struct non_motorVehicleProhibitedZones *pstruAsnVehicleProhibitedZones = (struct non_motorVehicleProhibitedZones *)pvoidAsnDf;
    struct Polygon *pstruAsnPolygon = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_motorVehicleProhibitedZones_LEN < pstruWjVehicleProhibitedZones->u8PolygonNum) ||
        (WJV2_MIN_LIST_motorVehicleProhibitedZones_LEN > pstruWjVehicleProhibitedZones->u8PolygonNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjVehicleProhibitedZones->u8PolygonNum = %d",
                 pstruWjVehicleProhibitedZones->u8PolygonNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjVehicleProhibitedZones->u8PolygonNum; u32i++)
    {
        pstruAsnPolygon = CALLOC(1, sizeof(struct Polygon));
        if (NULL == pstruAsnPolygon)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_Polygon_DfEnc(pstruAsnPolygon, &(pstruWjVehicleProhibitedZones->struPolygon[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Polygon_DfEnc is err");
            FREEMEM(pstruAsnPolygon);
            return false;
        }
        asn_sequence_add(&(pstruAsnVehicleProhibitedZones->list), pstruAsnPolygon);
    }

    return true;
}
/**
* @brief     WJV2_non_motorVehicleProhibitedZones_DfDec
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_non_motorVehicleProhibitedZones_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_non_motorVehicleProhibitedZones *pstruWjVehicleProhibitedZones = (WJV2_STRU_non_motorVehicleProhibitedZones *)pvoidWjDf;
    struct non_motorVehicleProhibitedZones *pstruAsnVehicleProhibitedZones = (struct non_motorVehicleProhibitedZones *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_motorVehicleProhibitedZones_LEN < pstruAsnVehicleProhibitedZones->list.count) ||
        (WJV2_MIN_LIST_motorVehicleProhibitedZones_LEN > pstruAsnVehicleProhibitedZones->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnVehicleProhibitedZones->list.count = %d",
                 pstruAsnVehicleProhibitedZones->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnVehicleProhibitedZones->list.count; u32i++)
    {

        n32Ret = WJV2_Polygon_DfDec(pstruAsnVehicleProhibitedZones->list.array[u32i], &(pstruWjVehicleProhibitedZones->struPolygon[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Polygon_DfDec is err");
            return false;
        }
    }

    return true;
}

/**
* @brief     WJV2_gridLineMarkingProhibitedZones_DfEnc
* @details   协议栈Polygon编解码中 统一Polygon的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_gridLineMarkingProhibitedZones_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_gridLineMarkingProhibitedZones *pstruWjMarkingProhibitedZones = (WJV2_STRU_gridLineMarkingProhibitedZones *)pvoidWjDf;
    struct gridLineMarkingProhibitedZones *pstruAsnMarkingProhibitedZones = (struct gridLineMarkingProhibitedZones *)pvoidAsnDf;
    struct Polygon *pstruAsnPolygon = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_gridLineMarkingProhibitedZones_LEN < pstruWjMarkingProhibitedZones->u8PolygonNum) ||
        (WJV2_MIN_LIST_gridLineMarkingProhibitedZones_LEN > pstruWjMarkingProhibitedZones->u8PolygonNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjMarkingProhibitedZones->u8PolygonNum = %d",
                 pstruWjMarkingProhibitedZones->u8PolygonNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjMarkingProhibitedZones->u8PolygonNum; u32i++)
    {
        pstruAsnPolygon = CALLOC(1, sizeof(struct Polygon));
        if (NULL == pstruAsnPolygon)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_Polygon_DfEnc(pstruAsnPolygon, &(pstruWjMarkingProhibitedZones->struPolygon[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Polygon_DfEnc is err");
            FREEMEM(pstruAsnPolygon);
            return false;
        }
        asn_sequence_add(&(pstruAsnMarkingProhibitedZones->list), pstruAsnPolygon);
    }

    return true;
}
/**
* @brief     WJV2_gridLineMarkingProhibitedZones_DfDec
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_gridLineMarkingProhibitedZones_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_gridLineMarkingProhibitedZones *pstruWjMarkingProhibitedZones = (WJV2_STRU_gridLineMarkingProhibitedZones *)pvoidWjDf;
    struct gridLineMarkingProhibitedZones *pstruAsnMarkingProhibitedZones = (struct gridLineMarkingProhibitedZones *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_gridLineMarkingProhibitedZones_LEN < pstruAsnMarkingProhibitedZones->list.count) ||
        (WJV2_MIN_LIST_gridLineMarkingProhibitedZones_LEN > pstruAsnMarkingProhibitedZones->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnMarkingProhibitedZones->list.count = %d",
                 pstruAsnMarkingProhibitedZones->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnMarkingProhibitedZones->list.count; u32i++)
    {

        n32Ret = WJV2_Polygon_DfDec(pstruAsnMarkingProhibitedZones->list.array[u32i], &(pstruWjMarkingProhibitedZones->struPolygon[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Polygon_DfDec is err");
            return false;
        }
    }

    return true;
}

/**
* @brief     WJV2_ProhibitedZone_DfEnc编码函数
* @details   协议栈ProhibitedZone编解码中 统一ProhibitedZone的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ProhibitedZone_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ProhibitedZone *pstruWjProhibitedZone = (WJV2_STRU_ProhibitedZone *)pvoidWjDf;
    ProhibitedZone_t *pstruAsnProhibitedZone = (ProhibitedZone_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (WJV2_PRESENT == pstruWjProhibitedZone->u8centralCircleProhibitedZonePresent)
    {
        pstruAsnProhibitedZone->centralCircleProhibitedZone = CALLOC(1, sizeof(struct Polygon));
        if (NULL == pstruAsnProhibitedZone->centralCircleProhibitedZone)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_Polygon_DfEnc(pstruAsnProhibitedZone->centralCircleProhibitedZone, &(pstruWjProhibitedZone->strucentralCircleProhibitedZone));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Polygon_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnProhibitedZone->centralCircleProhibitedZone = NULL;
    }
    if (WJV2_PRESENT == pstruWjProhibitedZone->u8motorVehicleProhibitedZonesPresent)
    {
        pstruAsnProhibitedZone->non_motorVehicleProhibitedZones = CALLOC(1, sizeof(struct non_motorVehicleProhibitedZones));
        if (NULL == pstruAsnProhibitedZone->non_motorVehicleProhibitedZones)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_non_motorVehicleProhibitedZones_DfEnc(pstruAsnProhibitedZone->non_motorVehicleProhibitedZones, &(pstruWjProhibitedZone->strunon_motorVehicleProhibitedZones));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_non_motorVehicleProhibitedZones_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnProhibitedZone->non_motorVehicleProhibitedZones = NULL;
    }
    if (WJV2_PRESENT == pstruWjProhibitedZone->u8gridLineMarkingProhibitedZonesPresent)
    {
        pstruAsnProhibitedZone->gridLineMarkingProhibitedZones = CALLOC(1, sizeof(struct gridLineMarkingProhibitedZones));
        if (NULL == pstruAsnProhibitedZone->gridLineMarkingProhibitedZones)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_gridLineMarkingProhibitedZones_DfEnc(pstruAsnProhibitedZone->gridLineMarkingProhibitedZones, &(pstruWjProhibitedZone->strugridLineMarkingProhibitedZones));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_gridLineMarkingProhibitedZones_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnProhibitedZone->gridLineMarkingProhibitedZones = NULL;
    }

    return true;
}
/**
* @brief     WJV2_ProhibitedZone_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ProhibitedZone_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }

    WJV2_STRU_ProhibitedZone *pstruWjProhibitedZone = (WJV2_STRU_ProhibitedZone *)pvoidWjDf;
    ProhibitedZone_t *pstruAsnProhibitedZone = (ProhibitedZone_t *)pvoidAsnDf;
    int32_t n32Ret = 0;

    if (NULL != pstruAsnProhibitedZone->centralCircleProhibitedZone)
    {
        n32Ret = WJV2_Polygon_DfDec(pstruAsnProhibitedZone->centralCircleProhibitedZone, &(pstruWjProhibitedZone->strucentralCircleProhibitedZone));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Polygon_DfDec is err");
            return false;
        }
        pstruWjProhibitedZone->u8centralCircleProhibitedZonePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjProhibitedZone->u8centralCircleProhibitedZonePresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnProhibitedZone->non_motorVehicleProhibitedZones)
    {
        n32Ret = WJV2_non_motorVehicleProhibitedZones_DfDec(pstruAsnProhibitedZone->non_motorVehicleProhibitedZones, &(pstruWjProhibitedZone->strunon_motorVehicleProhibitedZones));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_non_motorVehicleProhibitedZones_DfDec is err");
            return false;
        }
        pstruWjProhibitedZone->u8motorVehicleProhibitedZonesPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjProhibitedZone->u8motorVehicleProhibitedZonesPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnProhibitedZone->gridLineMarkingProhibitedZones)
    {
        n32Ret = WJV2_gridLineMarkingProhibitedZones_DfDec(pstruAsnProhibitedZone->gridLineMarkingProhibitedZones, &(pstruWjProhibitedZone->strugridLineMarkingProhibitedZones));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_gridLineMarkingProhibitedZones_DfDec is err");
            return false;
        }
        pstruWjProhibitedZone->u8gridLineMarkingProhibitedZonesPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjProhibitedZone->u8gridLineMarkingProhibitedZonesPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_PropelledInformation_DfEnc编码函数
* @details   协议栈PropelledInformation编解码中 统一PropelledInformation的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PropelledInformation_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PropelledInformation *pstruWjPropelledInformation = (WJV2_STRU_PropelledInformation *)pvoidWjDf;
    PropelledInformation_t *pstruAsnPropelledInformation = (PropelledInformation_t *)pvoidAsnDf;
    switch (pstruWjPropelledInformation->enumpresent)
    {
    case WJV2_PropelledInformation_PR_NOTHING:
        pstruAsnPropelledInformation->present = pstruWjPropelledInformation->enumpresent;
        break;
    case WJV2_PropelledInformation_PR_human:
        pstruAsnPropelledInformation->present = pstruWjPropelledInformation->enumpresent;
        break;
    case WJV2_PropelledInformation_PR_animal:
        pstruAsnPropelledInformation->present = pstruWjPropelledInformation->enumpresent;
        break;
    case WJV2_PropelledInformation_PR_motor:
        pstruAsnPropelledInformation->present = pstruWjPropelledInformation->enumpresent;
        break;

    default:
        pstruAsnPropelledInformation->present = pstruWjPropelledInformation->enumpresent;
        break;
    }

    return true;
}
/**
* @brief     WJV2_PropelledInformation_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_PropelledInformation_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_PropelledInformation *pstruWjPropelledInformation = (WJV2_STRU_PropelledInformation *)pvoidWjDf;
    PropelledInformation_t *pstruAsnPropelledInformation = (PropelledInformation_t *)pvoidAsnDf;
    switch (pstruAsnPropelledInformation->present)
    {
    case PropelledInformation_PR_NOTHING:
        pstruWjPropelledInformation->enumpresent = pstruAsnPropelledInformation->present;
        break;
    case PropelledInformation_PR_human:
        pstruWjPropelledInformation->enumpresent = pstruAsnPropelledInformation->present;
        break;
    case PropelledInformation_PR_animal:
        pstruWjPropelledInformation->enumpresent = pstruAsnPropelledInformation->present;
        break;
    case PropelledInformation_PR_motor:
        pstruWjPropelledInformation->enumpresent = pstruAsnPropelledInformation->present;
        break;

    default:
        pstruWjPropelledInformation->enumpresent = pstruAsnPropelledInformation->present;
        break;
    }

    return true;
}
/**
* @brief     WJV2_RangeOfFile_DfEnc编码函数
* @details   协议栈RangeOfFile编解码中 统一RangeOfFile的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_RangeOfFile_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_RangeOfFile *pstruWjRangeOfFile = (WJV2_STRU_RangeOfFile *)pvoidWjDf;
    RangeOfFile_t *pstruAsnRangeOfFile = (RangeOfFile_t *)pvoidAsnDf;
    if ((WJV2_MAX_OFFSET_SIZE < pstruWjRangeOfFile->n32offset) ||
        (WJV2_MIN_OFFSET_SIZE > pstruWjRangeOfFile->n32offset))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjRangeOfFile->n32offset = %d",
                 pstruWjRangeOfFile->n32offset);
        return false;
    }
    pstruAsnRangeOfFile->offset = pstruWjRangeOfFile->n32offset;
    if ((WJV2_MAX_LENGTH_SIZE < pstruWjRangeOfFile->n32lengh) ||
        (WJV2_MIN_LENGTH_SIZE > pstruWjRangeOfFile->n32lengh))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjRangeOfFile->length = %d",
                 pstruWjRangeOfFile->n32lengh);
        return false;
    }
    pstruAsnRangeOfFile->length = pstruWjRangeOfFile->n32lengh;

    return true;
}
/**
* @brief     WJV2_RangeOfFile_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_RangeOfFile_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_RangeOfFile *pstruWjRangeOfFile = (WJV2_STRU_RangeOfFile *)pvoidWjDf;
    RangeOfFile_t *pstruAsnRangeOfFile = (RangeOfFile_t *)pvoidAsnDf;
    if ((WJV2_MAX_OFFSET_SIZE < pstruAsnRangeOfFile->offset) ||
        (WJV2_MIN_OFFSET_SIZE > pstruAsnRangeOfFile->offset))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnRangeOfFile->offset = %d",
                 pstruAsnRangeOfFile->offset);
        return false;
    }
    pstruWjRangeOfFile->n32offset = pstruAsnRangeOfFile->offset;
    if ((WJV2_MAX_LENGTH_SIZE < pstruAsnRangeOfFile->length) ||
        (WJV2_MIN_LENGTH_SIZE > pstruAsnRangeOfFile->length))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnRangeOfFile->length = %d",
                 pstruAsnRangeOfFile->length);
        return false;
    }
    pstruWjRangeOfFile->n32lengh = pstruAsnRangeOfFile->length;

    return true;
}
/**
* @brief     WJV2_ReqClearTheWay_DfEnc编码函数
* @details   协议栈ReqClearTheWay编解码中 统一ReqClearTheWay的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ReqClearTheWay_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Req_ClearTheWay *pstruWjReq_ClearTheWay = (WJV2_STRU_Req_ClearTheWay *)pvoidWjDf;
    Req_ClearTheWay_t *pstruAsnReq_ClearTheWay = (Req_ClearTheWay_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_NodeReferenceID_DfEnc(&(pstruAsnReq_ClearTheWay->upstreamNode), &(pstruWjReq_ClearTheWay->struupstreamNode));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfEnc is err");
        return false;
    }
    n32Ret = WJV2_NodeReferenceID_DfEnc(&(pstruAsnReq_ClearTheWay->downstreamNode), &(pstruWjReq_ClearTheWay->strudownstreamNode));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfEnc is err");
        return false;
    }
    pstruAsnReq_ClearTheWay->targetLane = pstruWjReq_ClearTheWay->n32targetLane;
    if (WJV2_PRESENT == pstruWjReq_ClearTheWay->u8relatedPathPresent)
    {
        pstruAsnReq_ClearTheWay->relatedPath = CALLOC(1, sizeof(struct ReferencePath));
        if (NULL == pstruAsnReq_ClearTheWay->relatedPath)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ReferencePath_DfEnc(pstruAsnReq_ClearTheWay->relatedPath, &(pstruWjReq_ClearTheWay->strurelatedPath));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferencePath_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnReq_ClearTheWay->relatedPath = NULL;
    }
    if (WJV2_PRESENT == pstruWjReq_ClearTheWay->u8tBeginPresent)
    {
        pstruAsnReq_ClearTheWay->tBegin = CALLOC(1, sizeof(struct DDateTime));
        if (NULL == pstruAsnReq_ClearTheWay->tEnd)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_DDateTime_DfEnc(pstruAsnReq_ClearTheWay->tBegin, &(pstruWjReq_ClearTheWay->strutBegin));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DDateTime_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnReq_ClearTheWay->tBegin = NULL;
    }
    if (WJV2_PRESENT == pstruWjReq_ClearTheWay->u8tEndPresent)
    {
        pstruAsnReq_ClearTheWay->tEnd = CALLOC(1, sizeof(struct DDateTime));
        if (NULL == pstruAsnReq_ClearTheWay->tEnd)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_DDateTime_DfEnc(pstruAsnReq_ClearTheWay->tEnd, &(pstruWjReq_ClearTheWay->strutEnd));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DDateTime_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnReq_ClearTheWay->tEnd = NULL;
    }

    return true;
}
/**
* @brief     WJV2_ReqClearTheWay_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ReqClearTheWay_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Req_ClearTheWay *pstruWjReq_ClearTheWay = (WJV2_STRU_Req_ClearTheWay *)pvoidWjDf;
    Req_ClearTheWay_t *pstruAsnReq_ClearTheWay = (Req_ClearTheWay_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_NodeReferenceID_DfDec(&(pstruAsnReq_ClearTheWay->upstreamNode), &(pstruWjReq_ClearTheWay->struupstreamNode));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfDec is err");
        return false;
    }
    n32Ret = WJV2_NodeReferenceID_DfDec(&(pstruAsnReq_ClearTheWay->downstreamNode), &(pstruWjReq_ClearTheWay->strudownstreamNode));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfDec is err");
        return false;
    }
    pstruWjReq_ClearTheWay->n32targetLane = pstruAsnReq_ClearTheWay->targetLane;
    if (NULL != pstruAsnReq_ClearTheWay->relatedPath)
    {
        n32Ret = WJV2_ReferencePath_DfDec(pstruAsnReq_ClearTheWay->relatedPath, &(pstruWjReq_ClearTheWay->strurelatedPath));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferencePath_DfDec is err");
            return false;
        }
        pstruWjReq_ClearTheWay->u8relatedPathPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjReq_ClearTheWay->u8relatedPathPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnReq_ClearTheWay->tBegin)
    {
        n32Ret = WJV2_DDateTime_DfDec(pstruAsnReq_ClearTheWay->tBegin, &(pstruWjReq_ClearTheWay->strutBegin));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DDateTime_DfDec is err");
            return false;
        }
        pstruWjReq_ClearTheWay->u8tBeginPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjReq_ClearTheWay->u8tBeginPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnReq_ClearTheWay->tEnd)
    {
        n32Ret = WJV2_DDateTime_DfDec(pstruAsnReq_ClearTheWay->tEnd, &(pstruWjReq_ClearTheWay->strutEnd));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DDateTime_DfDec is err");
            return false;
        }
        pstruWjReq_ClearTheWay->u8tEndPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjReq_ClearTheWay->u8tEndPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_ReqLaneChange_DfEnc编码函数
* @details   协议栈ReqLaneChange编解码中 统一ReqLaneChange的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ReqLaneChange_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Req_LaneChange *pstruWjReq_LaneChange = (WJV2_STRU_Req_LaneChange *)pvoidWjDf;
    Req_LaneChange_t *pstruAsnReq_LaneChange = (Req_LaneChange_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_NodeReferenceID_DfEnc(&(pstruAsnReq_LaneChange->upstreamNode), &(pstruWjReq_LaneChange->struupstreamNode));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfEnc is err");
        return false;
    }
    n32Ret = WJV2_NodeReferenceID_DfEnc(&(pstruAsnReq_LaneChange->downstreamNode), &(pstruWjReq_LaneChange->strudownstreamNode));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfEnc is err");
        return false;
    }
    pstruAsnReq_LaneChange->targetLane = pstruWjReq_LaneChange->n32targetLane;

    return true;
}
/**
* @brief     WJV2_ReqLaneChange_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ReqLaneChange_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Req_LaneChange *pstruWjReq_LaneChange = (WJV2_STRU_Req_LaneChange *)pvoidWjDf;
    Req_LaneChange_t *pstruAsnReq_LaneChange = (Req_LaneChange_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_NodeReferenceID_DfDec(&(pstruAsnReq_LaneChange->upstreamNode), &(pstruWjReq_LaneChange->struupstreamNode));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfDec is err");
        return false;
    }
    n32Ret = WJV2_NodeReferenceID_DfDec(&(pstruAsnReq_LaneChange->downstreamNode), &(pstruWjReq_LaneChange->strudownstreamNode));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfDec is err");
        return false;
    }
    pstruWjReq_LaneChange->n32targetLane = pstruAsnReq_LaneChange->targetLane;

    return true;
}
/**
* @brief     WJV2_ReqParkingArea_DfEnc编码函数
* @details   协议栈ReqParkingArea编解码中 统一ReqParkingArea的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ReqParkingArea_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Req_ParkingArea *pstruWjReq_ParkingArea = (WJV2_STRU_Req_ParkingArea *)pvoidWjDf;
    Req_ParkingArea_t *pstruAsnReq_ParkingArea = (Req_ParkingArea_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_VehicleClassification_DfEnc(&(pstruAsnReq_ParkingArea->vehicleClass), &(pstruWjReq_ParkingArea->struvehicleClass));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_VehicleClassification_DfEnc is err");
        return false;
    }
    n32Ret = WJV2_ParkingRequest_DeEnc(&(pstruAsnReq_ParkingArea->req), &(pstruWjReq_ParkingArea->bitreq));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_ParkingRequest_DeEnc is err");
        return false;
    }
    if (WJV2_PRESENT == pstruWjReq_ParkingArea->u8parkingTypePresent)
    {
        pstruAsnReq_ParkingArea->parkingType = CALLOC(1, sizeof(ParkingType_t));
        if (NULL == pstruAsnReq_ParkingArea->parkingType)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ParkingType_DeEnc(pstruAsnReq_ParkingArea->parkingType, &(pstruWjReq_ParkingArea->bitparkingType));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ParkingType_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnReq_ParkingArea->parkingType = NULL;
    }
    if (WJV2_PRESENT == pstruWjReq_ParkingArea->u8expectedParkingSlotIDPresent)
    {
        if ((WJV2_MAX_expectedParkingSlotID_SIZE < pstruWjReq_ParkingArea->n32expectedParkingSlotID) ||
            (WJV2_MIN_expectedParkingSlotID_SIZE > pstruWjReq_ParkingArea->n32expectedParkingSlotID))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth: pstruWjReq_ParkingArea->n32expectedParkingSlotID = %d",
                     pstruWjReq_ParkingArea->n32expectedParkingSlotID);
            return false;
        }
        pstruAsnReq_ParkingArea->expectedParkingSlotID = CALLOC(1, sizeof(long));
        if (NULL == pstruAsnReq_ParkingArea->expectedParkingSlotID)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnReq_ParkingArea->expectedParkingSlotID) = pstruWjReq_ParkingArea->n32expectedParkingSlotID;
    }
    else
    {
        pstruAsnReq_ParkingArea->expectedParkingSlotID = NULL;
    }

    return true;
}
/**
* @brief     WJV2_ReqParkingArea_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ReqParkingArea_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Req_ParkingArea *pstruWjReq_ParkingArea = (WJV2_STRU_Req_ParkingArea *)pvoidWjDf;
    Req_ParkingArea_t *pstruAsnReq_ParkingArea = (Req_ParkingArea_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_VehicleClassification_DfDec(&(pstruAsnReq_ParkingArea->vehicleClass), &(pstruWjReq_ParkingArea->struvehicleClass));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_VehicleClassification_DfDec is err");
        return false;
    }
    n32Ret = WJV2_ParkingRequest_DeDec(&(pstruAsnReq_ParkingArea->req), &(pstruWjReq_ParkingArea->bitreq));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_ParkingRequest_DeDec is err");
        return false;
    }
    if (NULL != pstruAsnReq_ParkingArea->parkingType)
    {
        n32Ret = WJV2_ParkingType_DeDec(pstruAsnReq_ParkingArea->parkingType, &(pstruWjReq_ParkingArea->bitparkingType));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ParkingType_DeDec is err");
            return false;
        }
        pstruWjReq_ParkingArea->u8parkingTypePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjReq_ParkingArea->u8parkingTypePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnReq_ParkingArea->expectedParkingSlotID)
    {
        if ((WJV2_MAX_expectedParkingSlotID_SIZE < *(pstruAsnReq_ParkingArea->expectedParkingSlotID)) ||
            (WJV2_MIN_expectedParkingSlotID_SIZE > *(pstruAsnReq_ParkingArea->expectedParkingSlotID)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth: *(pstruAsnReq_ParkingArea->expectedParkingSlotID) = %d",
                     *(pstruAsnReq_ParkingArea->expectedParkingSlotID));
            return false;
        }
        pstruWjReq_ParkingArea->n32expectedParkingSlotID = *(pstruAsnReq_ParkingArea->expectedParkingSlotID);
        pstruWjReq_ParkingArea->u8expectedParkingSlotIDPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjReq_ParkingArea->u8expectedParkingSlotIDPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_ReqSensorSharing_DfEnc编码函数
* @details   协议栈ReqSensorSharing编解码中 统一ReqSensorSharing的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ReqSensorSharing_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Req_SensorSharing *pstruWjReq_SensorSharing = (WJV2_STRU_Req_SensorSharing *)pvoidWjDf;
    Req_SensorSharing_t *pstruAsnReq_SensorSharing = (Req_SensorSharing_t *)pvoidAsnDf;
    ReferencePath_t *pstruAsnReferencePath_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_REFERENCEPATH_LEN < pstruWjReq_SensorSharing->strudetectArea.u8ReferencePathNum) ||
        (WJV2_MIN_LIST_REFERENCEPATH_LEN > pstruWjReq_SensorSharing->strudetectArea.u8ReferencePathNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjReq_SensorSharing->strudetectArea.u8ReferencePathNum = %d",
                 pstruWjReq_SensorSharing->strudetectArea.u8ReferencePathNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjReq_SensorSharing->strudetectArea.u8ReferencePathNum; u32i++)
    {
        pstruAsnReferencePath_node = CALLOC(1, sizeof(ReferencePath_t));
        if (NULL == pstruAsnReferencePath_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ReferencePath_DfEnc(pstruAsnReferencePath_node, &(pstruWjReq_SensorSharing->strudetectArea.struReferencePath[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferencePath_DfEnc is err");
            FREEMEM(pstruAsnReferencePath_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnReq_SensorSharing->detectArea.list), pstruAsnReferencePath_node);
    }

    return true;
}
/**
* @brief     WJV2_ReqSensorSharing_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ReqSensorSharing_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Req_SensorSharing *pstruWjReq_SensorSharing = (WJV2_STRU_Req_SensorSharing *)pvoidWjDf;
    Req_SensorSharing_t *pstruAsnReq_SensorSharing = (Req_SensorSharing_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_REFERENCEPATH_LEN < pstruAsnReq_SensorSharing->detectArea.list.count) ||
        (WJV2_MIN_LIST_REFERENCEPATH_LEN > pstruAsnReq_SensorSharing->detectArea.list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnReq_SensorSharing->detectArea.list.count = %d",
                 pstruAsnReq_SensorSharing->detectArea.list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnReq_SensorSharing->detectArea.list.count; u32i++)
    {
        n32Ret = WJV2_ReferencePath_DfDec(pstruAsnReq_SensorSharing->detectArea.list.array[u32i],
                                          &(pstruWjReq_SensorSharing->strudetectArea.struReferencePath[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferencePath_DfDec is err");
            return false;
        }
    }
    pstruWjReq_SensorSharing->strudetectArea.u8ReferencePathNum = (uint8_t)u32i;

    return true;
}
/**
* @brief     WJV2_ReqSignalPriority_DfEnc编码函数
* @details   协议栈ReqSignalPriority编解码中 统一ReqSignalPriority的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ReqSignalPriority_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Req_SignalPriority *pstruWjReqInfo = (WJV2_STRU_Req_SignalPriority *)pvoidWjDf;
    Req_SignalPriority_t *pstruAsnReq_SignalPriority = (Req_SignalPriority_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_NodeReferenceID_DfEnc(&(pstruAsnReq_SignalPriority->intersectionId), &(pstruWjReqInfo->struintersectionId));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfEnc is err");
        return false;
    }
    n32Ret = WJV2_MovementEx_DfEnc(&(pstruAsnReq_SignalPriority->requiredMov), &(pstruWjReqInfo->strurequiredMov));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_MovementEx_DfEnc is err");
        return false;
    }
    if (WJV2_PRESENT == pstruWjReqInfo->u8estimatedArrivalTimePresent)
    {
        pstruAsnReq_SignalPriority->estimatedArrivalTime = CALLOC(1, sizeof(TimeOffset_t));
        if (NULL == pstruAsnReq_SignalPriority->estimatedArrivalTime)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnReq_SignalPriority->estimatedArrivalTime) = pstruWjReqInfo->n32estimatedArrivalTime;
    }
    else
    {
        pstruAsnReq_SignalPriority->estimatedArrivalTime = NULL;
    }
    if (WJV2_PRESENT == pstruWjReqInfo->u8distance2IntersectionPresent)
    {
        if ((WJV2_MAX_distance2Intersection_SIZE < pstruWjReqInfo->n32distance2Intersection) ||
            (WJV2_MIN_distance2Intersection_SIZE > pstruWjReqInfo->n32distance2Intersection))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth: pstruWjReqInfo->n32distance2Intersection = %d",
                     pstruWjReqInfo->n32distance2Intersection);
            return false;
        }
        pstruAsnReq_SignalPriority->distance2Intersection = CALLOC(1, sizeof(long));
        if (NULL == pstruAsnReq_SignalPriority->distance2Intersection)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnReq_SignalPriority->distance2Intersection) = pstruWjReqInfo->n32distance2Intersection;
    }
    else
    {
        pstruAsnReq_SignalPriority->distance2Intersection = NULL;
    }

    return true;
}
/**
* @brief     WJV2_ReqSignalPriority_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ReqSignalPriority_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Req_SignalPriority *pstruWjReqInfo = (WJV2_STRU_Req_SignalPriority *)pvoidWjDf;
    Req_SignalPriority_t *pstruAsnReq_SignalPriority = (Req_SignalPriority_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_NodeReferenceID_DfDec(&(pstruAsnReq_SignalPriority->intersectionId), &(pstruWjReqInfo->struintersectionId));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_NodeReferenceID_DfDec is err");
        return false;
    }
    n32Ret = WJV2_MovementEx_DfDec(&(pstruAsnReq_SignalPriority->requiredMov), &(pstruWjReqInfo->strurequiredMov));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_MovementEx_DfDec is err");
        return false;
    }
    if (NULL != pstruAsnReq_SignalPriority->estimatedArrivalTime)
    {
        if ((WJV2_MAX_TIMEOFFSET_SIZE < (*pstruAsnReq_SignalPriority->estimatedArrivalTime)) ||
            (WJV2_MIN_TIMEOFFSET_SIZE > *(pstruAsnReq_SignalPriority->estimatedArrivalTime)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth: *(pstruAsnReq_SignalPriority->estimatedArrivalTime) = %d",
                     *(pstruAsnReq_SignalPriority->estimatedArrivalTime));
            return false;
        }
        pstruWjReqInfo->n32estimatedArrivalTime = *(pstruAsnReq_SignalPriority->estimatedArrivalTime);
        pstruWjReqInfo->u8estimatedArrivalTimePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjReqInfo->u8estimatedArrivalTimePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnReq_SignalPriority->distance2Intersection)
    {
        if ((WJV2_MAX_distance2Intersection_SIZE < (*pstruAsnReq_SignalPriority->distance2Intersection)) ||
            (WJV2_MIN_distance2Intersection_SIZE > *(pstruAsnReq_SignalPriority->distance2Intersection)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth: *(pstruAsnReq_SignalPriority->distance2Intersection) = %d",
                     *(pstruAsnReq_SignalPriority->distance2Intersection));
            return false;
        }
        pstruWjReqInfo->n32distance2Intersection = *(pstruAsnReq_SignalPriority->distance2Intersection);
        pstruWjReqInfo->u8distance2IntersectionPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjReqInfo->u8distance2IntersectionPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_ReqInfo_DfEnc编码函数
* @details   协议栈ReqInfo编解码中 统一ReqInfo的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ReqInfo_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ReqInfo *pstruWjReqInfo = (WJV2_STRU_ReqInfo *)pvoidWjDf;
    ReqInfo_t *pstruAsnReqInfo = (ReqInfo_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    switch (pstruWjReqInfo->enumpresent)
    {
    case WJV2_ReqInfo_PR_NOTHING:
        pstruAsnReqInfo->present = pstruWjReqInfo->enumpresent;
        break;
    case WJV2_ReqInfo_PR_laneChange:
        pstruAsnReqInfo->present = pstruWjReqInfo->enumpresent;
        n32Ret = WJV2_ReqLaneChange_DfEnc(&(pstruAsnReqInfo->choice.laneChange), &(pstruWjReqInfo->choice.strulaneChange));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReqLaneChange_DfEnc is err");
            return false;
        }
        break;
    case WJV2_ReqInfo_PR_clearTheWay:
        pstruAsnReqInfo->present = pstruWjReqInfo->enumpresent;
        n32Ret = WJV2_ReqClearTheWay_DfEnc(&(pstruAsnReqInfo->choice.clearTheWay), &(pstruWjReqInfo->choice.struclearTheWay));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReqClearTheWay_DfEnc is err");
            return false;
        }
        break;
    case WJV2_ReqInfo_PR_signalPriority:
        pstruAsnReqInfo->present = pstruWjReqInfo->enumpresent;
        n32Ret = WJV2_ReqSignalPriority_DfEnc(&(pstruAsnReqInfo->choice.signalPriority), &(pstruWjReqInfo->choice.strusignalPriority));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReqSignalPriority_DfEnc is err");
            return false;
        }
        break;
    case WJV2_ReqInfo_PR_sensorSharing:
        pstruAsnReqInfo->present = pstruWjReqInfo->enumpresent;
        n32Ret = WJV2_ReqSensorSharing_DfEnc(&(pstruAsnReqInfo->choice.sensorSharing), &(pstruWjReqInfo->choice.strusensorSharing));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReqSensorSharing_DfEnc is err");
            return false;
        }
        break;
    case WJV2_ReqInfo_PR_parking:
        pstruAsnReqInfo->present = pstruWjReqInfo->enumpresent;
        n32Ret = WJV2_ReqParkingArea_DfEnc(&(pstruAsnReqInfo->choice.parking), &(pstruWjReqInfo->choice.struparking));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReqParkingArea_DfEnc is err");
            return false;
        }
        break;

    default:
        pstruAsnReqInfo->present = pstruWjReqInfo->enumpresent;
        break;
    }

    return true;
}
/**
* @brief     WJV2_ReqInfo_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_ReqInfo_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ReqInfo *pstruWjReqInfo = (WJV2_STRU_ReqInfo *)pvoidWjDf;
    ReqInfo_t *pstruAsnReqInfo = (ReqInfo_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    switch (pstruAsnReqInfo->present)
    {
    case ReqInfo_PR_NOTHING:
        pstruWjReqInfo->enumpresent = pstruAsnReqInfo->present;
        break;
    case ReqInfo_PR_laneChange:
        pstruWjReqInfo->enumpresent = pstruAsnReqInfo->present;
        n32Ret = WJV2_ReqLaneChange_DfDec(&(pstruAsnReqInfo->choice.laneChange), &(pstruWjReqInfo->choice.strulaneChange));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReqLaneChange_DfDec is err");
            return false;
        }
        break;
    case ReqInfo_PR_clearTheWay:
        pstruWjReqInfo->enumpresent = pstruAsnReqInfo->present;
        n32Ret = WJV2_ReqClearTheWay_DfDec(&(pstruAsnReqInfo->choice.clearTheWay), &(pstruWjReqInfo->choice.struclearTheWay));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReqClearTheWay_DfDec is err");
            return false;
        }
        break;
    case ReqInfo_PR_signalPriority:
        pstruWjReqInfo->enumpresent = pstruAsnReqInfo->present;
        n32Ret = WJV2_ReqSignalPriority_DfDec(&(pstruAsnReqInfo->choice.signalPriority), &(pstruWjReqInfo->choice.strusignalPriority));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReqSignalPriority_DfDec is err");
            return false;
        }
        break;
    case ReqInfo_PR_sensorSharing:
        pstruWjReqInfo->enumpresent = pstruAsnReqInfo->present;
        n32Ret = WJV2_ReqSensorSharing_DfDec(&(pstruAsnReqInfo->choice.sensorSharing), &(pstruWjReqInfo->choice.strusensorSharing));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReqSensorSharing_DfDec is err");
            return false;
        }
        break;
    case ReqInfo_PR_parking:
        pstruWjReqInfo->enumpresent = pstruAsnReqInfo->present;
        n32Ret = WJV2_ReqParkingArea_DfDec(&(pstruAsnReqInfo->choice.parking), &(pstruWjReqInfo->choice.struparking));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReqParkingArea_DfDec is err");
            return false;
        }
        break;

    default:
        pstruWjReqInfo->enumpresent = pstruAsnReqInfo->present;
        break;
    }

    return true;
}
/**
* @brief     WJV2_RoadWorkerExtensions_DfEnc编码函数
* @details   协议栈RoadWorkerExtensions编解码中 统一RoadWorkerExtensions的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_RoadWorkerExtensions_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_RoadWorkerExtensions *pstruWjRoadWorkerExtensions = (WJV2_STRU_RoadWorkerExtensions *)pvoidWjDf;
    RoadWorkerExtensions_t *pstruAsnRoadWorkerExtensions = (RoadWorkerExtensions_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (WJV2_PRESENT == pstruWjRoadWorkerExtensions->u8workerTypePresent)
    {
        pstruAsnRoadWorkerExtensions->workerType = CALLOC(1, sizeof(RoadWorkerType_t));
        if (NULL == pstruAsnRoadWorkerExtensions->workerType)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnRoadWorkerExtensions->workerType) = pstruWjRoadWorkerExtensions->enumworkerType;
    }
    else
    {
        pstruAsnRoadWorkerExtensions->workerType = NULL;
    }
    if (WJV2_PRESENT == pstruWjRoadWorkerExtensions->u8activityTypePresent)
    {
        pstruAsnRoadWorkerExtensions->activityType = CALLOC(1, sizeof(RoadWorkerActivityType_t));
        if (NULL == pstruAsnRoadWorkerExtensions->activityType)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_RoadWorkerActivityType_DeEnc(pstruAsnRoadWorkerExtensions->activityType, &(pstruWjRoadWorkerExtensions->bitactivityType));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RoadWorkerActivityType_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnRoadWorkerExtensions->activityType = NULL;
    }

    return true;
}
/**
* @brief     WJV2_RoadWorkerExtensions_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_RoadWorkerExtensions_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_RoadWorkerExtensions *pstruWjRoadWorkerExtensions = (WJV2_STRU_RoadWorkerExtensions *)pvoidWjDf;
    RoadWorkerExtensions_t *pstruAsnRoadWorkerExtensions = (RoadWorkerExtensions_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (NULL != pstruAsnRoadWorkerExtensions->workerType)
    {
        pstruWjRoadWorkerExtensions->enumworkerType = *(pstruAsnRoadWorkerExtensions->workerType);
        pstruWjRoadWorkerExtensions->u8workerTypePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjRoadWorkerExtensions->u8workerTypePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnRoadWorkerExtensions->activityType)
    {
        n32Ret = WJV2_RoadWorkerActivityType_DeDec(pstruAsnRoadWorkerExtensions->activityType, &(pstruWjRoadWorkerExtensions->bitactivityType));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RoadWorkerActivityType_DeDec is err");
            return false;
        }
        pstruWjRoadWorkerExtensions->u8activityTypePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjRoadWorkerExtensions->u8activityTypePresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_RST_DfEnc编码函数
* @details   协议栈RST编解码中 统一RST的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_RST_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_RST *pstruWjRST = (WJV2_STRU_RST *)pvoidWjDf;
    RST_t *pstruAsnRST = (RST_t *)pvoidAsnDf;
    ApplicationParameter_t *pstruAsnApplicationParameter_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    n32Ret = WJV2_DDateTime_DfEnc(&(pstruAsnRST->time), &(pstruWjRST->strutime));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_DDateTime_DfEnc is err");
        return false;
    }
    if ((WJV2_MAX_OCTid_SIZE != pstruWjRST->u8OCTidNum) /*||
        (1 > pstruWjRST->u8OCTidNum)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjRST->u8OCTidNum = %d",
                 pstruWjRST->u8OCTidNum);
        return false;
    }
    pstruAsnRST->id.size = pstruWjRST->u8OCTidNum;
    pstruAsnRST->id.buf = CALLOC(1, pstruAsnRST->id.size);
    if (NULL == pstruAsnRST->id.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruAsnRST->id.buf, pstruWjRST->u8OCTid, pstruAsnRST->id.size);
    if ((WJV2_MAX_LIST_Payment_LEN < pstruWjRST->strupaymentList.u8ApplicationParameterNum) ||
        (WJV2_MIN_LIST_Payment_LEN > pstruWjRST->strupaymentList.u8ApplicationParameterNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjRST->strupaymentList.u8ApplicationParameterNum = %d",
                 pstruWjRST->strupaymentList.u8ApplicationParameterNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjRST->strupaymentList.u8ApplicationParameterNum; u32i++)
    {
        pstruAsnApplicationParameter_node = CALLOC(1, sizeof(ApplicationParameter_t));
        if (NULL == pstruAsnApplicationParameter_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ApplicationParameter_DfEnc(pstruAsnApplicationParameter_node,
                                                 &(pstruWjRST->strupaymentList.struApplicationParameter[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ApplicationParameter_DfEnc is err");
            FREEMEM(pstruAsnApplicationParameter_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnRST->paymentList.list), pstruAsnApplicationParameter_node);
    }

    return true;
}
/**
* @brief     WJV2_RST_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_RST_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_RST *pstruWjRST = (WJV2_STRU_RST *)pvoidWjDf;
    RST_t *pstruAsnRST = (RST_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    n32Ret = WJV2_DDateTime_DfDec(&(pstruAsnRST->time), &(pstruWjRST->strutime));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_DDateTime_DfDec is err");
        return false;
    }
    if ((WJV2_MAX_OCTid_SIZE != pstruAsnRST->id.size) /*||
        (1 > pstruAsnRST->id.size)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnRST->id.size = %d",
                 pstruAsnRST->id.size);
        return false;
    }
    pstruWjRST->u8OCTidNum = pstruAsnRST->id.size;
    memcpy(pstruWjRST->u8OCTid, pstruAsnRST->id.buf, pstruAsnRST->id.size);
    if ((WJV2_MAX_LIST_Payment_LEN < pstruAsnRST->paymentList.list.count) ||
        (WJV2_MIN_LIST_Payment_LEN > pstruAsnRST->paymentList.list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnRST->paymentList.list.count= %d",
                 pstruAsnRST->paymentList.list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnRST->paymentList.list.count; u32i++)
    {
        n32Ret = WJV2_ApplicationParameter_DfDec(pstruAsnRST->paymentList.list.array[u32i],
                                                 &(pstruWjRST->strupaymentList.struApplicationParameter[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ApplicationParameter_DfDec is err");
            return false;
        }
    }
    pstruWjRST->strupaymentList.u8ApplicationParameterNum = (uint8_t)u32i;

    return true;
}
/**
* @brief     WJV2_RTCMmsg_DfEnc编码函数
* @details   协议栈RTCMmsg编解码中 统一RTCMmsg的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_RTCMmsg_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_RTCMmsg *pstruWjRTCMmsg = (WJV2_STRU_RTCMmsg *)pvoidWjDf;
    RTCMmsg_t *pstruAsnRTCMmsg = (RTCMmsg_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (WJV2_PRESENT == pstruWjRTCMmsg->u8revPresent)
    {
        pstruAsnRTCMmsg->rev = CALLOC(1, sizeof(RTCM_Revision_t));
        if (NULL == pstruAsnRTCMmsg->rev)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnRTCMmsg->rev) = pstruWjRTCMmsg->enumrev;
    }
    else
    {
        pstruAsnRTCMmsg->rev = NULL;
    }
    if (WJV2_PRESENT == pstruWjRTCMmsg->u8rtcmIDPresent)
    {
        pstruAsnRTCMmsg->rtcmID = CALLOC(1, sizeof(RTCM_ID_t));
        if (NULL == pstruAsnRTCMmsg->rtcmID)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnRTCMmsg->rtcmID) = pstruWjRTCMmsg->n32rtcmID;
    }
    else
    {
        pstruAsnRTCMmsg->rev = NULL;
    }
    n32Ret = WJV2_RTCMPayload_DeEnc(&(pstruAsnRTCMmsg->payload), &(pstruWjRTCMmsg->strupayload));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_RTCMPayload_DeEnc is err");
        return false;
    }

    return true;
}
/**
* @brief     WJV2_RTCMmsg_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_RTCMmsg_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_RTCMmsg *pstruWjRTCMmsg = (WJV2_STRU_RTCMmsg *)pvoidWjDf;
    RTCMmsg_t *pstruAsnRTCMmsg = (RTCMmsg_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (NULL != pstruAsnRTCMmsg->rev)
    {
        pstruWjRTCMmsg->enumrev = *(pstruAsnRTCMmsg->rev);
        pstruWjRTCMmsg->u8revPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjRTCMmsg->u8revPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnRTCMmsg->rev)
    {
        pstruWjRTCMmsg->n32rtcmID = *(pstruAsnRTCMmsg->rtcmID);
        pstruWjRTCMmsg->u8rtcmIDPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjRTCMmsg->u8rtcmIDPresent = WJV2_ABSENT;
    }
    n32Ret = WJV2_RTCMPayload_DeDec(&(pstruAsnRTCMmsg->payload), &(pstruWjRTCMmsg->strupayload));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_RTCMPayload_DeDec is err");
        return false;
    }

    return true;
}

/**
* @brief     WJV2_Section_DfEnc编码函数
* @details   协议栈Section编解码中 统一Section的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_Section_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Section *pstruWjSection = (WJV2_STRU_Section *)pvoidWjDf;
    Section_t *pstruAsnSection = (Section_t *)pvoidAsnDf;
    LaneEx_t *pstruAsnLaneEx_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    pstruWjSection->n32secId = pstruWjSection->n32secId;
    if ((WJV2_MAX_LIST_LaneEx_LEN < pstruWjSection->strulanes.u8LaneExNum) ||
        (WJV2_MIN_LIST_LaneEx_LEN > pstruWjSection->strulanes.u8LaneExNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjSection->strulanes.u8LaneExNum = %d",
                 pstruWjSection->strulanes.u8LaneExNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjSection->strulanes.u8LaneExNum; u32i++)
    {
        pstruAsnLaneEx_node = CALLOC(1, sizeof(LaneEx_t));
        if (NULL == pstruAsnLaneEx_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_LaneEx_DfEnc(pstruAsnLaneEx_node,
                                   &(pstruWjSection->strulanes.struLaneEx[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneEx_DfEnc is err");
            FREEMEM(pstruAsnLaneEx_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnSection->lanes.list), pstruAsnLaneEx_node);
    }

    return true;
}
/**
* @brief     WJV2_Section_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_Section_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_Section *pstruWjSection = (WJV2_STRU_Section *)pvoidWjDf;
    Section_t *pstruAsnSection = (Section_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    pstruWjSection->n32secId = pstruWjSection->n32secId;
    if ((WJV2_MAX_LIST_LaneEx_LEN < pstruAsnSection->lanes.list.count) ||
        (WJV2_MIN_LIST_LaneEx_LEN > pstruAsnSection->lanes.list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnSection->lanes.list.count = %d",
                 pstruAsnSection->lanes.list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnSection->lanes.list.count; u32i++)
    {
        n32Ret = WJV2_LaneEx_DfDec(pstruAsnSection->lanes.list.array[u32i],
                                   &(pstruWjSection->strulanes.struLaneEx[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_LaneEx_DfDec is err");
            return false;
        }
    }
    pstruWjSection->strulanes.u8LaneExNum = (uint8_t)u32i;

    return true;
}
/**
* @brief     WJV2_SectionList_DfEnc编码函数
* @details   协议栈SectionList编解码中 统一SectionList的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_SectionList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_SectionList *pstruWjSectionList = (WJV2_STRU_SectionList *)pvoidWjDf;
    SectionList_t *pstruAsnSectionList = (SectionList_t *)pvoidAsnDf;
    Section_t *pstruAsnSection_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_Section_LEN < pstruWjSectionList->u8SectionNum) ||
        (WJV2_MIN_LIST_Section_LEN > pstruWjSectionList->u8SectionNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjSectionList->u8SectionNum= %d",
                 pstruWjSectionList->u8SectionNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjSectionList->u8SectionNum; u32i++)
    {
        pstruAsnSection_node = CALLOC(1, sizeof(Section_t));
        if (NULL == pstruAsnSection_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_Section_DfEnc(pstruAsnSection_node,
                                    &(pstruWjSectionList->struSection[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Section_DfEnc is err");
            FREEMEM(pstruAsnSection_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnSectionList->list), pstruAsnSection_node);
    }

    return true;
}
/**
* @brief     WJV2_SectionList_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_SectionList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_SectionList *pstruWjSectionList = (WJV2_STRU_SectionList *)pvoidWjDf;
    SectionList_t *pstruAsnSectionList = (SectionList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_Section_LEN < pstruAsnSectionList->list.count) ||
        (WJV2_MIN_LIST_Section_LEN > pstruAsnSectionList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnSectionList->list.count= %d",
                 pstruAsnSectionList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnSectionList->list.count; u32i++)
    {
        n32Ret = WJV2_Section_DfDec(pstruAsnSectionList->list.array[u32i],
                                    &(pstruWjSectionList->struSection[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Section_DfDec is err");
            return false;
        }
    }
    pstruWjSectionList->u8SectionNum = (uint8_t)u32i;

    return true;
}
/**
* @brief     WJV2_SetMMIRq_DfEnc编码函数
* @details   协议栈SetMMIRq编解码中 统一SetMMIRq的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_SetMMIRq_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_SetMMIRq *pstruWjSetMMIRq = (WJV2_STRU_SetMMIRq *)pvoidWjDf;
    SetMMIRq_t *pstruAsnSetMMIRq = (SetMMIRq_t *)pvoidAsnDf;
    pstruAsnSetMMIRq->toll = pstruWjSetMMIRq->enumtoll;
    return true;
}
/**
* @brief     WJV2_SetMMIRq_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_SetMMIRq_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_SetMMIRq *pstruWjSetMMIRq = (WJV2_STRU_SetMMIRq *)pvoidWjDf;
    SetMMIRq_t *pstruAsnSetMMIRq = (SetMMIRq_t *)pvoidAsnDf;
    pstruWjSetMMIRq->enumtoll = pstruAsnSetMMIRq->toll;

    return true;
}
/**
* @brief     WJV2_SetTollDataRq_DfEnc编码函数
* @details   协议栈SetTollDataRq编解码中 统一SetTollDataRq的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_SetTollDataRq_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_SetTollDataRq *pstruWjSetTollDataRq = (WJV2_STRU_SetTollDataRq *)pvoidWjDf;
    SetTollDataRq_t *pstruAsnSetTollDataRq = (SetTollDataRq_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (NULL != pstruAsnSetTollDataRq->rndRSU)
    {
        n32Ret = WJV2_RandStr8_DeEnc(pstruAsnSetTollDataRq->rndRSU, &(pstruWjSetTollDataRq->octrndRSU));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RandStr8_DeEnc is err");
            return false;
        }
    }
    if (WJV2_PRESENT == pstruWjSetTollDataRq->u8transParaPresent)
    {
        pstruAsnSetTollDataRq->transPara = CALLOC(1, sizeof(struct TransPara));
        if (NULL == pstruAsnSetTollDataRq->transPara)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_TransPara_DfEnc(pstruAsnSetTollDataRq->transPara, &(pstruWjSetTollDataRq->strutransPara));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_TransPara_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnSetTollDataRq->transPara = NULL;
    }
    if (WJV2_PRESENT == pstruWjSetTollDataRq->u8tollInfoPresent)
    {
        pstruAsnSetTollDataRq->tollInfo = CALLOC(1, sizeof(struct PartOfFile));
        if (NULL == pstruAsnSetTollDataRq->tollInfo)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_TollInfo_DfEnc(pstruAsnSetTollDataRq->tollInfo, &(pstruWjSetTollDataRq->strutollInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_TollInfo_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnSetTollDataRq->tollInfo = NULL;
    }
    if (WJV2_PRESENT == pstruWjSetTollDataRq->u8tollingPosPresent)
    {
        pstruAsnSetTollDataRq->tollingPos = CALLOC(1, sizeof(struct TollingPos));
        if (NULL == pstruAsnSetTollDataRq->tollingPos)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_TollingPos_DfEnc(pstruAsnSetTollDataRq->tollingPos, &(pstruWjSetTollDataRq->tollingPos));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_TollingPos_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnSetTollDataRq->tollingPos = NULL;
    }
    if (WJV2_PRESENT == pstruWjSetTollDataRq->u8keyIdForAuthenPresent)
    {
        if ((WJV2_MAX_keyIdForAuthen_SIZE < pstruWjSetTollDataRq->n32keyIdForAuthen) ||
            (WJV2_MIN_keyIdForAuthen_SIZE > pstruWjSetTollDataRq->n32keyIdForAuthen))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth: pstruWjSetTollDataRq->n32keyIdForAuthen = %d",
                     pstruWjSetTollDataRq->n32keyIdForAuthen);
            return false;
        }
        *(pstruAsnSetTollDataRq->keyIdForAuthen) = pstruWjSetTollDataRq->n32keyIdForAuthen;
    }

    return true;
}
/**
* @brief     WJV2_SetTollDataRq_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_SetTollDataRq_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_SetTollDataRq *pstruWjSetTollDataRq = (WJV2_STRU_SetTollDataRq *)pvoidWjDf;
    SetTollDataRq_t *pstruAsnSetTollDataRq = (SetTollDataRq_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (NULL != pstruAsnSetTollDataRq->rndRSU)
    {
        n32Ret = WJV2_RandStr8_DeDec(pstruAsnSetTollDataRq->rndRSU, &(pstruWjSetTollDataRq->octrndRSU));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RandStr8_DeDec is err");
            return false;
        }
    }
    if (NULL != pstruAsnSetTollDataRq->transPara)
    {
        n32Ret = WJV2_TransPara_DfDec(pstruAsnSetTollDataRq->transPara, &(pstruWjSetTollDataRq->strutransPara));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_TransPara_DfDec is err");
            return false;
        }
        pstruWjSetTollDataRq->u8transParaPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjSetTollDataRq->u8transParaPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnSetTollDataRq->tollInfo)
    {
        n32Ret = WJV2_TollInfo_DfDec(pstruAsnSetTollDataRq->tollInfo, &(pstruWjSetTollDataRq->strutollInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_TollInfo_DfDec is err");
            return false;
        }
        pstruWjSetTollDataRq->u8tollInfoPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjSetTollDataRq->u8tollInfoPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnSetTollDataRq->tollingPos)
    {
        n32Ret = WJV2_TollingPos_DfDec(pstruAsnSetTollDataRq->tollingPos, &(pstruWjSetTollDataRq->tollingPos));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_TollingPos_DfDec is err");
            return false;
        }
        pstruWjSetTollDataRq->u8tollingPosPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjSetTollDataRq->u8tollingPosPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnSetTollDataRq->keyIdForAuthen)
    {
        if ((WJV2_MAX_keyIdForAuthen_SIZE < *(pstruAsnSetTollDataRq->keyIdForAuthen)) ||
            (WJV2_MIN_keyIdForAuthen_SIZE > *(pstruAsnSetTollDataRq->keyIdForAuthen)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth: *(pstruAsnSetTollDataRq->keyIdForAuthen) = %d",
                     *(pstruAsnSetTollDataRq->keyIdForAuthen));
            return false;
        }
        pstruWjSetTollDataRq->n32keyIdForAuthen = *(pstruAsnSetTollDataRq->keyIdForAuthen);
        pstruWjSetTollDataRq->u8keyIdForAuthenPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjSetTollDataRq->u8keyIdForAuthenPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_SetTollDataRs_DfEnc编码函数
* @details   协议栈SetTollDataRs编解码中 统一SetTollDataRs的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_SetTollDataRs_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_SetTollDataRs *pstruWjSetTollDataRs = (WJV2_STRU_SetTollDataRs *)pvoidWjDf;
    SetTollDataRs_t *pstruAsnSetTollDataRs = (SetTollDataRs_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_OCTtacInfo_SIZE != pstruWjSetTollDataRs->u8OCTtacInfoNum) /*||
        (1 > pstruWjSetTollDataRs->u8OCTtacInfoNum)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjSetTollDataRs->u8OCTtacInfoNum = %d",
                 pstruWjSetTollDataRs->u8OCTtacInfoNum);
        return false;
    }
    pstruAsnSetTollDataRs->tacInfo = CALLOC(1, sizeof(OCTET_STRING_t));
    if (NULL == pstruAsnSetTollDataRs->tacInfo)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    pstruAsnSetTollDataRs->tacInfo->size = pstruWjSetTollDataRs->u8OCTtacInfoNum;
    pstruAsnSetTollDataRs->tacInfo->buf = CALLOC(1, pstruAsnSetTollDataRs->tacInfo->size);
    if (NULL == pstruAsnSetTollDataRs->tacInfo->buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruAsnSetTollDataRs->tacInfo->buf, pstruWjSetTollDataRs->u8OCTtacInfo, pstruAsnSetTollDataRs->tacInfo->size);

    if ((WJV2_MAX_OCTauthenticator_SIZE != pstruWjSetTollDataRs->u8OCTauthenticatorNum) /*||
        (1 > pstruWjSetTollDataRs->u8OCTauthenticatorNum)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjSetTollDataRs->u8OCTauthenticatorNum = %d",
                 pstruWjSetTollDataRs->u8OCTauthenticatorNum);
        return false;
    }
    pstruAsnSetTollDataRs->authenticator = CALLOC(1, sizeof(OCTET_STRING_t));
    if (NULL == pstruAsnSetTollDataRs->authenticator)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    pstruAsnSetTollDataRs->authenticator->size = pstruWjSetTollDataRs->u8OCTauthenticatorNum;
    pstruAsnSetTollDataRs->authenticator->buf = CALLOC(1, pstruAsnSetTollDataRs->authenticator->size);
    if (NULL == pstruAsnSetTollDataRs->authenticator->buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruAsnSetTollDataRs->authenticator->buf, pstruWjSetTollDataRs->u8OCTauthenticator, pstruAsnSetTollDataRs->authenticator->size);
    if (WJV2_PRESENT == pstruWjSetTollDataRs->u8accountInfoPresent)
    {
        pstruAsnSetTollDataRs->accountInfo = CALLOC(1, sizeof(struct AccountInfo));
        if (NULL == pstruAsnSetTollDataRs->accountInfo)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_AccountInfo_DfEnc(pstruAsnSetTollDataRs->accountInfo, &(pstruWjSetTollDataRs->octaccountInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AccountInfo_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnSetTollDataRs->accountInfo = NULL;
    }

    if (WJV2_PRESENT == pstruWjSetTollDataRs->u8transCredentialPresent)
    {
        pstruAsnSetTollDataRs->transCredential = CALLOC(1, sizeof(struct TransCredential));
        if (NULL == pstruAsnSetTollDataRs->transCredential)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_TransCredential_DfEnc(pstruAsnSetTollDataRs->transCredential, &(pstruWjSetTollDataRs->transCredential));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_TransCredential_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnSetTollDataRs->transCredential = NULL;
    }

    return true;
}
/**
* @brief     WJV2_SetTollDataRs_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_SetTollDataRs_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_SetTollDataRs *pstruWjSetTollDataRs = (WJV2_STRU_SetTollDataRs *)pvoidWjDf;
    SetTollDataRs_t *pstruAsnSetTollDataRs = (SetTollDataRs_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_OCTtacInfo_SIZE != pstruAsnSetTollDataRs->tacInfo->size) /*||
        (1 > pstruAsnSetTollDataRs->tacInfo->size)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnSetTollDataRs->tacInfo->size = %d",
                 pstruAsnSetTollDataRs->tacInfo->size);
        return false;
    }
    pstruWjSetTollDataRs->u8OCTtacInfoNum = pstruAsnSetTollDataRs->tacInfo->size;
    if (NULL == pstruWjSetTollDataRs->u8OCTtacInfo)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "pstruWjSetTollDataRs->u8OCTtacInfo is NULL");
        return false;
    }
    memcpy(pstruWjSetTollDataRs->u8OCTtacInfo, pstruAsnSetTollDataRs->tacInfo->buf, pstruAsnSetTollDataRs->tacInfo->size);
    if ((WJV2_MAX_OCTauthenticator_SIZE != pstruAsnSetTollDataRs->authenticator->size) /*||
        (1 > pstruAsnSetTollDataRs->authenticator->size)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnSetTollDataRs->authenticator->size = %d",
                 pstruAsnSetTollDataRs->authenticator->size);
        return false;
    }
    pstruWjSetTollDataRs->u8OCTauthenticatorNum = pstruAsnSetTollDataRs->authenticator->size;
    if (NULL == pstruWjSetTollDataRs->u8OCTauthenticator)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "pstruWjSetTollDataRs->u8OCTauthenticator is NULL");
        return false;
    }
    memcpy(pstruWjSetTollDataRs->u8OCTauthenticator, pstruAsnSetTollDataRs->authenticator->buf, pstruAsnSetTollDataRs->authenticator->size);
    if (NULL != pstruAsnSetTollDataRs->accountInfo)
    {
        n32Ret = WJV2_AccountInfo_DfDec(pstruAsnSetTollDataRs->accountInfo, &(pstruWjSetTollDataRs->octaccountInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_AccountInfo_DfDec is err");
            return false;
        }
        pstruWjSetTollDataRs->u8accountInfoPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjSetTollDataRs->u8accountInfoPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnSetTollDataRs->transCredential)
    {
        n32Ret = WJV2_TransCredential_DfDec(pstruAsnSetTollDataRs->transCredential, &(pstruWjSetTollDataRs->transCredential));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_TransCredential_DfDec is err");
            return false;
        }
        pstruWjSetTollDataRs->u8transCredentialPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjSetTollDataRs->u8transCredentialPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_SignalWaitingLane_DfEnc编码函数
* @details   协议栈SignalWaitingLane编解码中 统一SignalWaitingLane的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_SignalWaitingLane_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_SignalWaitingLane *pstruWjSignalWaitingLane = (WJV2_STRU_SignalWaitingLane *)pvoidWjDf;
    SignalWaitingLane_t *pstruAsnSignalWaitingLane = (SignalWaitingLane_t *)pvoidAsnDf;

    PhaseID_t *pstruAsnPhaseID_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    pstruAsnSignalWaitingLane->laneWidth = pstruWjSignalWaitingLane->n32laneWidth;
    if ((WJV2_MAX_LIST_ROADPOINT_LEN < pstruWjSignalWaitingLane->strupoints.u8RoadPointNum) ||
        (WJV2_MIN_LIST_ROADPOINT_LEN > pstruWjSignalWaitingLane->strupoints.u8RoadPointNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjSignalWaitingLane->strupoints.u8RoadPointNum = %d",
                 pstruWjSignalWaitingLane->strupoints.u8RoadPointNum);
        return false;
    }

    n32Ret = WJV2_PointList_DfEnc(&pstruAsnSignalWaitingLane->points,
                                  &(pstruWjSignalWaitingLane->strupoints));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_Movement_DfEnc is err");
        return false;
    }

    if (WJV2_PRESENT == pstruWjSignalWaitingLane->u8allowedPhaseIdsPresent)
    {
        if ((WJV2_MAX_LIST_phaseId_LEN < pstruWjSignalWaitingLane->struallowedPhaseIds.u8phaseIdNum) ||
            (WJV2_MIN_LIST_phaseId_LEN > pstruWjSignalWaitingLane->struallowedPhaseIds.u8phaseIdNum))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjSignalWaitingLane->struallowedPhaseIds.u8phaseIdNum = %d",
                     pstruWjSignalWaitingLane->struallowedPhaseIds.u8phaseIdNum);
            return false;
        }
        for (u32i = 0; u32i < pstruWjSignalWaitingLane->struallowedPhaseIds.u8phaseIdNum; u32i++)
        {
            pstruAsnPhaseID_node = CALLOC(1, sizeof(PhaseID_t));
            if (NULL == pstruAsnPhaseID_node)
            {
                LogPrint(LOG_LEVEL_ERR,
                         STACK_DF_MODULE,
                         "CALLOC is err");
                return false;
            }
            n32Ret = WJV2_Phase_DfEnc(pstruAsnPhaseID_node,
                                      &(pstruWjSignalWaitingLane->struallowedPhaseIds.n32phaseId[u32i]));
            if (true != n32Ret)
            {
                LogPrint(LOG_LEVEL_ERR,
                         STACK_DF_MODULE,
                         "WJV2_Phase_DfEnc is err");
                FREEMEM(pstruAsnPhaseID_node);
                return false;
            }
            asn_sequence_add(&(pstruAsnSignalWaitingLane->allowedPhaseIds->list), pstruAsnPhaseID_node);
        }
    }
    else
    {
        pstruAsnSignalWaitingLane->allowedPhaseIds = NULL;
    }

    return true;
}
/**
* @brief     WJV2_SignalWaitingLane_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_SignalWaitingLane_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_SignalWaitingLane *pstruWjSignalWaitingLane = (WJV2_STRU_SignalWaitingLane *)pvoidWjDf;
    SignalWaitingLane_t *pstruAsnSignalWaitingLane = (SignalWaitingLane_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    pstruWjSignalWaitingLane->n32laneWidth = pstruAsnSignalWaitingLane->laneWidth;
    if ((WJV2_MAX_LIST_ROADPOINT_LEN < pstruAsnSignalWaitingLane->points.list.count) ||
        (WJV2_MIN_LIST_ROADPOINT_LEN > pstruAsnSignalWaitingLane->points.list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnSignalWaitingLane->points.list.count = %d",
                 pstruAsnSignalWaitingLane->points.list.count);
        return false;
    }

    n32Ret = WJV2_PointList_DfDec(&pstruAsnSignalWaitingLane->points,
                                  &(pstruWjSignalWaitingLane->strupoints));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_PointList_DfDec is err");
        return false;
    }

    if (NULL != pstruAsnSignalWaitingLane->allowedPhaseIds)
    {
        if ((WJV2_MAX_LIST_phaseId_LEN < pstruAsnSignalWaitingLane->allowedPhaseIds->list.count) ||
            (WJV2_MIN_LIST_phaseId_LEN > pstruAsnSignalWaitingLane->allowedPhaseIds->list.count))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruAsnSignalWaitingLane->allowedPhaseIds->list.count = %d",
                     pstruAsnSignalWaitingLane->allowedPhaseIds->list.count);
            return false;
        }
        for (u32i = 0; u32i < pstruAsnSignalWaitingLane->allowedPhaseIds->list.count; u32i++)
        {
            n32Ret = WJV2_Phase_DfDec(pstruAsnSignalWaitingLane->allowedPhaseIds->list.array[u32i],
                                      &(pstruWjSignalWaitingLane->struallowedPhaseIds.n32phaseId[u32i]));
            if (true != n32Ret)
            {
                LogPrint(LOG_LEVEL_ERR,
                         STACK_DF_MODULE,
                         "WJV2_Phase_DfEnc is err");
                return false;
            }
        }
        pstruWjSignalWaitingLane->struallowedPhaseIds.u8phaseIdNum = (uint8_t)u32i;
        pstruWjSignalWaitingLane->u8allowedPhaseIdsPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjSignalWaitingLane->u8allowedPhaseIdsPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_STPoint_DfEnc编码函数
* @details   协议栈STPoint编解码中 统一STPoint的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_STPoint_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ST_Point *pstruWjWJSTPoint = (WJV2_STRU_ST_Point *)pvoidWjDf;
    ST_Point_t *pstruAsnWJSTPoint = (ST_Point_t *)pvoidAsnDf;
    if ((WJV2_MAX_s_axis_SIZE < pstruWjWJSTPoint->n32s_axis) ||
        (WJV2_MIN_s_axis_SIZE > pstruWjWJSTPoint->n32s_axis))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjWJSTPoint->n32s_axis  = %d",
                 pstruWjWJSTPoint->n32s_axis);
        return false;
    }
    pstruAsnWJSTPoint->s_axis = pstruWjWJSTPoint->n32s_axis;
    if ((WJV2_MAX_t_axis_SIZE < pstruWjWJSTPoint->n32t_axis) ||
        (WJV2_MIN_t_axis_SIZE > pstruWjWJSTPoint->n32t_axis))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjWJSTPoint->n32t_axis  = %d",
                 pstruWjWJSTPoint->n32t_axis);
        return false;
    }
    pstruAsnWJSTPoint->t_axis = pstruWjWJSTPoint->n32t_axis;

    return true;
}
/**
* @brief     WJV2_STPoint_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_STPoint_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_ST_Point *pstruWjWJSTPoint = (WJV2_STRU_ST_Point *)pvoidWjDf;
    ST_Point_t *pstruAsnWJSTPoint = (ST_Point_t *)pvoidAsnDf;
    if ((WJV2_MAX_s_axis_SIZE < pstruAsnWJSTPoint->s_axis) ||
        (WJV2_MIN_s_axis_SIZE > pstruAsnWJSTPoint->s_axis))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnWJSTPoint->s_axis  = %d",
                 pstruAsnWJSTPoint->s_axis);
        return false;
    }
    pstruWjWJSTPoint->n32s_axis = pstruAsnWJSTPoint->s_axis;
    if ((WJV2_MAX_t_axis_SIZE < pstruAsnWJSTPoint->t_axis) ||
        (WJV2_MIN_t_axis_SIZE > pstruAsnWJSTPoint->t_axis))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnWJSTPoint->t_axis  = %d",
                 pstruAsnWJSTPoint->t_axis);
        return false;
    }
    pstruWjWJSTPoint->n32t_axis = pstruAsnWJSTPoint->t_axis;

    return true;
}
/**
* @brief     WJV2_STPointList_DfEnc编码函数
* @details   协议栈STPointList编解码中 统一STPointList的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_STPointList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_STPointList *pstruWjWJV2STPointList = (WJV2_STRU_STPointList *)pvoidWjDf;
    STPointList_t *pstruAsnWJV2STPointList = (STPointList_t *)pvoidAsnDf;
    ST_Point_t *pstruST_Point_node = NULL;
    int32_t n32Ret = 0;
    int32_t u32i = 0;
    if ((WJV2_MAX_LIST_ST_Point_LEN < pstruWjWJV2STPointList->u8ST_PointNum) ||
        (WJV2_MIN_LIST_ST_Point_LEN > pstruWjWJV2STPointList->u8ST_PointNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjWJV2STPointList->u8ST_PointNum = %d",
                 pstruWjWJV2STPointList->u8ST_PointNum);
        return false;
    }
    pstruAsnWJV2STPointList->list.count = pstruWjWJV2STPointList->u8ST_PointNum;
    for (u32i = 0; u32i < pstruWjWJV2STPointList->u8ST_PointNum; u32i++)
    {
        pstruST_Point_node = CALLOC(1, sizeof(ST_Point_t));
        if (NULL == pstruST_Point_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_STPoint_DfEnc(pstruST_Point_node, &(pstruWjWJV2STPointList->struST_Point[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Movement_DfEnc is err");
            FREEMEM(pstruST_Point_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnWJV2STPointList->list), pstruST_Point_node);
    }

    return true;
}
/**
* @brief     WJV2_STPointList_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_STPointList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_STPointList *pstruWjWJV2STPointList = (WJV2_STRU_STPointList *)pvoidWjDf;
    STPointList_t *pstruAsnWJV2STPointList = (STPointList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    int32_t u32i = 0;
    if ((WJV2_MAX_LIST_ST_Point_LEN < pstruAsnWJV2STPointList->list.count) ||
        (WJV2_MIN_LIST_ST_Point_LEN > pstruAsnWJV2STPointList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnWJV2STPointList->list.count = %d",
                 pstruAsnWJV2STPointList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruWjWJV2STPointList->u8ST_PointNum; u32i++)
    {
        n32Ret = WJV2_STPoint_DfDec(pstruAsnWJV2STPointList->list.array[u32i], &(pstruWjWJV2STPointList->struST_Point[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Movement_DfEnc is err");
            return false;
        }
    }
    pstruWjWJV2STPointList->u8ST_PointNum = (uint8_t)u32i;

    return true;
}
/**
* @brief     WJV2_SysInfo_DfEnc编码函数
* @details   协议栈SysInfo编解码中 统一SysInfo的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_SysInfo_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_SysInfo *pstruWj_SysInfo = (WJV2_STRU_SysInfo *)pvoidWjDf;
    SysInfo_t *pstruAsn_SysInfo = (SysInfo_t *)pvoidAsnDf;
    pstruAsn_SysInfo->contractProvider.size = WJV2_MAX_OCTcontractProvider_SIZE;
    pstruAsn_SysInfo->contractProvider.buf = CALLOC(1, pstruAsn_SysInfo->contractProvider.size);
    if (NULL == pstruAsn_SysInfo->contractProvider.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruAsn_SysInfo->contractProvider.buf, pstruWj_SysInfo->u8OCTcontractProvider, pstruAsn_SysInfo->contractProvider.size);
    if ((WJV2_MAX_contractType_SIZE < pstruWj_SysInfo->n32contractType) ||
        (WJV2_MIN_contractType_SIZE > pstruWj_SysInfo->n32contractType))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWj_SysInfo->n32contractType = %d",
                 pstruWj_SysInfo->n32contractType);
        return false;
    }
    pstruAsn_SysInfo->contractType = pstruWj_SysInfo->n32contractType;
    if ((WJV2_MAX_contractVersion_SIZE < pstruWj_SysInfo->n32contractVersion) ||
        (WJV2_MIN_contractVersion_SIZE > pstruWj_SysInfo->n32contractVersion))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWj_SysInfo->n32contractVersion = %d",
                 pstruWj_SysInfo->n32contractVersion);
        return false;
    }
    pstruAsn_SysInfo->contractVersion = pstruWj_SysInfo->n32contractVersion;
    pstruAsn_SysInfo->contractSerialNumer.size = WJV2_MAX_OCTcontractSerialNumer_SIZE;
    pstruAsn_SysInfo->contractSerialNumer.buf = CALLOC(1, pstruAsn_SysInfo->contractSerialNumer.size);
    if (NULL == pstruAsn_SysInfo->contractSerialNumer.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruAsn_SysInfo->contractSerialNumer.buf, pstruWj_SysInfo->u8OCTcontractSerialNumer, pstruAsn_SysInfo->contractSerialNumer.size);

    if (WJV2_MAX_DYEAR_SIZE < pstruWj_SysInfo->strucontractSignedDate.n32year ||
        WJV2_MIN_DYEAR_SIZE > pstruWj_SysInfo->strucontractSignedDate.n32year)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "pstruWj_SysInfo->strucontractSignedDate.n32year is err ");
        return false;
    }
    else
    {
        pstruAsn_SysInfo->contractSignedDate.year = pstruWj_SysInfo->strucontractSignedDate.n32year;
    }
    if (WJV2_MAX_DMONTH_SIZE < pstruWj_SysInfo->strucontractSignedDate.n32month ||
        WJV2_MIN_DMONTH_SIZE > pstruWj_SysInfo->strucontractSignedDate.n32month)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "pstruWj_SysInfo->strucontractSignedDate.month is err");
        return false;
    }
    else
    {
        pstruAsn_SysInfo->contractSignedDate.month = pstruWj_SysInfo->strucontractSignedDate.n32month;
    }
    if (WJV2_MAX_DDAY_SIZE < pstruWj_SysInfo->strucontractSignedDate.n32day ||
        WJV2_MIN_DDAY_SIZE > pstruWj_SysInfo->strucontractSignedDate.n32day)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "pstruWj_SysInfo->strucontractSignedDate.day is err");
        return false;
    }
    else
    {
        pstruAsn_SysInfo->contractSignedDate.day = pstruWj_SysInfo->strucontractSignedDate.n32day;
    }
    if (WJV2_MAX_DYEAR_SIZE < pstruWj_SysInfo->strucontractSignedDate.n32year ||
        WJV2_MIN_DYEAR_SIZE > pstruWj_SysInfo->strucontractSignedDate.n32year)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "pstruWj_SysInfo->strucontractExpiredDate.n32year is err");
        return false;
    }
    else
    {
        pstruAsn_SysInfo->contractExpiredDate.year = pstruWj_SysInfo->strucontractExpiredDate.n32year;
    }
    if (WJV2_MAX_DMONTH_SIZE < pstruWj_SysInfo->strucontractExpiredDate.n32month ||
        WJV2_MIN_DMONTH_SIZE > pstruWj_SysInfo->strucontractExpiredDate.n32month)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "pstruWj_SysInfo->strucontractSignedDate.month is err");
        return false;
    }
    else
    {
        pstruAsn_SysInfo->contractExpiredDate.month = pstruWj_SysInfo->strucontractExpiredDate.n32month;
    }
    if (WJV2_MAX_DYEAR_SIZE < pstruWj_SysInfo->strucontractExpiredDate.n32day ||
        WJV2_MIN_DYEAR_SIZE > pstruWj_SysInfo->strucontractExpiredDate.n32day)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "pstruWj_SysInfo->strucontractSignedDate.day is err");
        return false;
    }
    else
    {
        pstruAsn_SysInfo->contractExpiredDate.day = pstruWj_SysInfo->strucontractExpiredDate.n32day;
    }

    pstruAsn_SysInfo->reserved.size = WJV2_MAX_OCTreserved_SIZE;
    pstruAsn_SysInfo->reserved.buf = CALLOC(1, pstruAsn_SysInfo->reserved.size);
    if (NULL == pstruAsn_SysInfo->reserved.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruAsn_SysInfo->reserved.buf, pstruWj_SysInfo->u8OCTreserved, pstruAsn_SysInfo->reserved.size);

    return true;
}
/**
* @brief     WJV2_SysInfo_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_SysInfo_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_SysInfo *pstruWj_SysInfo = (WJV2_STRU_SysInfo *)pvoidWjDf;
    SysInfo_t *pstruAsn_SysInfo = (SysInfo_t *)pvoidAsnDf;
    if ((WJV2_MAX_OCTcontractProvider_SIZE != pstruAsn_SysInfo->contractProvider.size) /*||
        (1 > pstruAsn_SysInfo->contractProvider.size)*/
        ||
        (NULL == pstruAsn_SysInfo->contractSerialNumer.buf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsn_SysInfo->contractProvider.size = %d",
                 pstruAsn_SysInfo->contractProvider.size);
        return false;
    }
    memcpy(pstruWj_SysInfo->u8OCTcontractProvider, pstruAsn_SysInfo->contractProvider.buf, pstruAsn_SysInfo->contractProvider.size);
    if ((WJV2_MAX_contractType_SIZE < pstruAsn_SysInfo->contractType) ||
        (WJV2_MIN_contractType_SIZE > pstruAsn_SysInfo->contractType))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsn_SysInfo->contractType = %d",
                 pstruAsn_SysInfo->contractType);
        return false;
    }
    pstruWj_SysInfo->n32contractType = pstruAsn_SysInfo->contractType;
    if ((WJV2_MAX_contractVersion_SIZE < pstruAsn_SysInfo->contractVersion) ||
        (WJV2_MIN_contractVersion_SIZE > pstruAsn_SysInfo->contractVersion))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsn_SysInfo->contractVersion = %d",
                 pstruAsn_SysInfo->contractVersion);
        return false;
    }
    pstruWj_SysInfo->n32contractVersion = pstruAsn_SysInfo->contractVersion;
    if ((WJV2_MAX_OCTcontractSerialNumer_SIZE != pstruAsn_SysInfo->contractSerialNumer.size) /*||
        (1 > pstruAsn_SysInfo->contractSerialNumer.size)*/
        ||
        (NULL == pstruAsn_SysInfo->contractSerialNumer.buf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsn_SysInfo->contractSerialNumer.size = %d",
                 pstruAsn_SysInfo->contractSerialNumer.size);
        return false;
    }
    memcpy(pstruWj_SysInfo->u8OCTcontractSerialNumer, pstruAsn_SysInfo->contractSerialNumer.buf, pstruAsn_SysInfo->contractSerialNumer.size);
    if ((WJV2_MAX_DYEAR_SIZE < pstruAsn_SysInfo->contractSignedDate.year) ||
        (WJV2_MIN_DYEAR_SIZE > pstruAsn_SysInfo->contractSignedDate.year))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsn_SysInfo->contractSignedDate.year = %d",
                 pstruAsn_SysInfo->contractVersion);
        return false;
    }
    pstruWj_SysInfo->strucontractSignedDate.n32year = pstruAsn_SysInfo->contractSignedDate.year;
    if ((WJV2_MAX_DMONTH_SIZE < pstruAsn_SysInfo->contractSignedDate.month) ||
        (WJV2_MIN_DMONTH_SIZE > pstruAsn_SysInfo->contractSignedDate.month))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsn_SysInfo->contractSignedDate.year = %d",
                 pstruAsn_SysInfo->contractVersion);
        return false;
    }
    pstruWj_SysInfo->strucontractSignedDate.n32month = pstruAsn_SysInfo->contractSignedDate.month;
    if ((WJV2_MAX_DDAY_SIZE < pstruAsn_SysInfo->contractSignedDate.day) ||
        (WJV2_MIN_DDAY_SIZE > pstruAsn_SysInfo->contractSignedDate.day))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsn_SysInfo->contractSignedDate.year = %d",
                 pstruAsn_SysInfo->contractVersion);
        return false;
    }
    pstruWj_SysInfo->strucontractSignedDate.n32day = pstruAsn_SysInfo->contractSignedDate.day;

    if ((WJV2_MAX_DYEAR_SIZE < pstruAsn_SysInfo->contractExpiredDate.year) ||
        (WJV2_MIN_DYEAR_SIZE > pstruAsn_SysInfo->contractExpiredDate.year))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsn_SysInfo->contractExpiredDate.year = %d",
                 pstruAsn_SysInfo->contractExpiredDate.year);
        return false;
    }
    pstruWj_SysInfo->strucontractExpiredDate.n32year = pstruAsn_SysInfo->contractExpiredDate.year;
    if ((WJV2_MAX_DMONTH_SIZE < pstruAsn_SysInfo->contractExpiredDate.month) ||
        (WJV2_MIN_DMONTH_SIZE > pstruAsn_SysInfo->contractExpiredDate.month))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsn_SysInfo->contractExpiredDate.month = %d",
                 pstruAsn_SysInfo->contractExpiredDate.month);
        return false;
    }
    pstruWj_SysInfo->strucontractExpiredDate.n32month = pstruAsn_SysInfo->contractExpiredDate.month;
    if ((WJV2_MAX_DDAY_SIZE < pstruAsn_SysInfo->contractExpiredDate.day) ||
        (WJV2_MIN_DDAY_SIZE > pstruAsn_SysInfo->contractExpiredDate.day))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsn_SysInfo->contractExpiredDate.day = %d",
                 pstruAsn_SysInfo->contractExpiredDate.day);
        return false;
    }
    pstruWj_SysInfo->strucontractExpiredDate.n32day = pstruAsn_SysInfo->contractExpiredDate.day;

    if ((WJV2_MAX_OCTreserved_SIZE != pstruAsn_SysInfo->reserved.size) /* ||
        (1 > pstruAsn_SysInfo->reserved.size) */
        ||
        (NULL == pstruAsn_SysInfo->reserved.buf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsn_SysInfo->reserved.size = %d",
                 pstruAsn_SysInfo->reserved.size);
        return false;
    }
    memcpy(pstruWj_SysInfo->u8OCTreserved, pstruAsn_SysInfo->reserved.buf, pstruAsn_SysInfo->reserved.size);
    return true;
}
/**
* @brief     WJV2_TransCredential_DfEnc编码函数
* @details   协议栈TransCredential编解码中 统一TransCredential的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_TransCredential_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_OCT_TransCredential *pstruWjTransCredential = (WJV2_OCT_TransCredential *)pvoidWjDf;
    TransCredential_t *pstruAsnTransCredential = (TransCredential_t *)pvoidAsnDf;
    if ((WJV2_MAX_OCTTransCredential_SIZE < pstruWjTransCredential->u8OCTTransCredentialNum) ||
        (WJV2_MIN_OCTTransCredential_SIZE > pstruWjTransCredential->u8OCTTransCredentialNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjTransCredential->u8OCTTransCredentialNum = %d",
                 pstruWjTransCredential->u8OCTTransCredentialNum);
        return false;
    }
    pstruAsnTransCredential->tc.size = pstruWjTransCredential->u8OCTTransCredentialNum;
    pstruAsnTransCredential->tc.buf = CALLOC(1, pstruAsnTransCredential->tc.size);
    if (NULL == pstruAsnTransCredential->tc.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruAsnTransCredential->tc.buf, pstruWjTransCredential->u8OCTTransCredential, pstruAsnTransCredential->tc.size);

    return true;
}
/**
* @brief     WJV2_TransCredential_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_TransCredential_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_OCT_TransCredential *pstruWjTransCredential = (WJV2_OCT_TransCredential *)pvoidWjDf;
    TransCredential_t *pstruAsnTransCredential = (TransCredential_t *)pvoidAsnDf;
    if ((WJV2_MAX_OCTTransCredential_SIZE < pstruAsnTransCredential->tc.size) ||
        (WJV2_MIN_OCTTransCredential_SIZE > pstruAsnTransCredential->tc.size))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnTransCredential->tc.size = %d",
                 pstruAsnTransCredential->tc.size);
        return false;
    }
    pstruWjTransCredential->u8OCTTransCredentialNum = pstruAsnTransCredential->tc.size;
    if (NULL == pstruAsnTransCredential->tc.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "pstruAsnTransCredential->tc->buf is NULL");
        return false;
    }
    memcpy(pstruWjTransCredential->u8OCTTransCredential, pstruAsnTransCredential->tc.buf, pstruAsnTransCredential->tc.size);

    return true;
}
/**
* @brief     WJV2_TransInfo_DfEnc编码函数
* @details   协议栈TransInfo编解码中 统一TransInfo的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_TransInfo_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_TransInfo *pstruWjTransInfo = (WJV2_STRU_TransInfo *)pvoidWjDf;
    TransInfo_t *pstruAsnTransInfo = (TransInfo_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    switch (pstruWjTransInfo->present)
    {
    case WJV2_TransInfo_PR_NOTHING:
        pstruAsnTransInfo->present = pstruWjTransInfo->present;
        break;

    case WJV2_TransInfo_PR_getTollDataRq:
        pstruAsnTransInfo->present = pstruWjTransInfo->present;
        n32Ret = WJV2_GetTollDataRq_DfEnc(&(pstruAsnTransInfo->choice.getTollDataRq), &(pstruWjTransInfo->choice.strugetTollDataRq));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_GetTollDataRq_DfEnc is err");
            return false;
        }
        break;
    case WJV2_TransInfo_PR_getTollDataRs:
        pstruAsnTransInfo->present = pstruWjTransInfo->present;
        n32Ret = WJV2_GetTollDataRs_DfEnc(&(pstruAsnTransInfo->choice.getTollDataRs), &(pstruWjTransInfo->choice.strugetTollDataRs));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_GetTollDataRs_DfEnc is err");
            return false;
        }
        break;
    case WJV2_TransInfo_PR_getSecureRq:
        pstruAsnTransInfo->present = pstruWjTransInfo->present;
        n32Ret = WJV2_GetSecureRq_DfEnc(&(pstruAsnTransInfo->choice.getSecureRq), &(pstruWjTransInfo->choice.strugetSecureRq));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_GetSecureRq_DfEnc is err");
            return false;
        }
        break;
    case WJV2_TransInfo_PR_getSecureRs:
        pstruAsnTransInfo->present = pstruWjTransInfo->present;
        n32Ret = WJV2_GetSecureRs_DfEnc(&(pstruAsnTransInfo->choice.getSecureRs), &(pstruWjTransInfo->choice.strugetSecureRs));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_GetSecureRq_DfEnc is err");
            return false;
        }
        break;
    case WJV2_TransInfo_PR_setTollDataRq:
        pstruAsnTransInfo->present = pstruWjTransInfo->present;
        n32Ret = WJV2_SetTollDataRq_DfEnc(&(pstruAsnTransInfo->choice.setTollDataRq), &(pstruWjTransInfo->choice.strusetTollDataRq));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_SetTollDataRq_DfEnc is err");
            return false;
        }
        break;
    case WJV2_TransInfo_PR_setTollDataRs:
        pstruAsnTransInfo->present = pstruWjTransInfo->present;
        n32Ret = WJV2_SetTollDataRs_DfEnc(&(pstruAsnTransInfo->choice.setTollDataRs), &(pstruWjTransInfo->choice.strusetTollDataRs));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_SetTollDataRs_DfEnc is err");
            return false;
        }
        break;
    case WJV2_TransInfo_PR_transferChannelRq:
        pstruAsnTransInfo->present = pstruWjTransInfo->present;
        n32Ret = WJV2_ChannelRq_DfEnc(&(pstruAsnTransInfo->choice.transferChannelRq), &(pstruWjTransInfo->choice.strutransferChannelRq));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ChannelRq_DfEnc is err");
            return false;
        }
        break;
    case WJV2_TransInfo_PR_transferChannelRs:
        pstruAsnTransInfo->present = pstruWjTransInfo->present;
        n32Ret = WJV2_ChannelRs_DfEnc(&(pstruAsnTransInfo->choice.transferChannelRs), &(pstruWjTransInfo->choice.strutransferChannelRs));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ChannelRs_DfEnc is err");
            return false;
        }
        break;
    case WJV2_TransInfo_PR_setMMIRq:
        pstruAsnTransInfo->present = pstruWjTransInfo->present;
        n32Ret = WJV2_SetMMIRq_DfEnc(&(pstruAsnTransInfo->choice.setMMIRq), &(pstruWjTransInfo->choice.strusetMMIRq));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_SetMMIRq_DfEnc is err");
            return false;
        }
        break;

    default:
        pstruAsnTransInfo->present = TransInfo_PR_NOTHING;
        break;
    }

    return true;
}
/**
* @brief     WJV2_TransInfo_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_TransInfo_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_TransInfo *pstruWjTransInfo = (WJV2_STRU_TransInfo *)pvoidWjDf;
    TransInfo_t *pstruAsnTransInfo = (TransInfo_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    switch (pstruAsnTransInfo->present)
    {
    case TransInfo_PR_NOTHING:
        pstruWjTransInfo->present = pstruAsnTransInfo->present;
        break;

    case TransInfo_PR_getTollDataRq:
        pstruWjTransInfo->present = pstruAsnTransInfo->present;
        n32Ret = WJV2_GetTollDataRq_DfDec(&(pstruAsnTransInfo->choice.getTollDataRq), &(pstruWjTransInfo->choice.strugetTollDataRq));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_GetTollDataRq_DfDec is err");
            return false;
        }
        break;
    case TransInfo_PR_getTollDataRs:
        pstruAsnTransInfo->present = pstruWjTransInfo->present;
        n32Ret = WJV2_GetTollDataRs_DfDec(&(pstruAsnTransInfo->choice.getTollDataRs), &(pstruWjTransInfo->choice.strugetTollDataRs));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_GetTollDataRs_DfDec is err");
            return false;
        }
        break;
    case TransInfo_PR_getSecureRq:
        pstruWjTransInfo->present = pstruAsnTransInfo->present;
        n32Ret = WJV2_GetSecureRq_DfDec(&(pstruAsnTransInfo->choice.getSecureRq), &(pstruWjTransInfo->choice.strugetSecureRq));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_GetSecureRq_DfDec is err");
            return false;
        }
        break;
    case TransInfo_PR_getSecureRs:
        pstruWjTransInfo->present = pstruAsnTransInfo->present;
        n32Ret = WJV2_GetSecureRs_DfDec(&(pstruAsnTransInfo->choice.getSecureRs), &(pstruWjTransInfo->choice.strugetSecureRs));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_GetSecureRs_DfDec is err");
            return false;
        }
        break;
    case TransInfo_PR_setTollDataRq:
        pstruWjTransInfo->present = pstruAsnTransInfo->present;
        n32Ret = WJV2_SetTollDataRq_DfDec(&(pstruAsnTransInfo->choice.setTollDataRq), &(pstruWjTransInfo->choice.strusetTollDataRq));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_SetTollDataRq_DfDec is err");
            return false;
        }
        break;
    case TransInfo_PR_setTollDataRs:
        pstruWjTransInfo->present = pstruAsnTransInfo->present;
        n32Ret = WJV2_SetTollDataRs_DfDec(&(pstruAsnTransInfo->choice.setTollDataRs), &(pstruWjTransInfo->choice.strusetTollDataRs));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_SetTollDataRs_DfDec is err");
            return false;
        }
        break;
    case TransInfo_PR_transferChannelRq:
        pstruWjTransInfo->present = pstruAsnTransInfo->present;
        n32Ret = WJV2_ChannelRq_DfDec(&(pstruAsnTransInfo->choice.transferChannelRq), &(pstruWjTransInfo->choice.strutransferChannelRq));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ChannelRq_DfDec is err");
            return false;
        }
        break;
    case TransInfo_PR_transferChannelRs:
        pstruWjTransInfo->present = pstruAsnTransInfo->present;
        n32Ret = WJV2_ChannelRs_DfDec(&(pstruAsnTransInfo->choice.transferChannelRs), &(pstruWjTransInfo->choice.strutransferChannelRs));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ChannelRs_DfDec is err");
            return false;
        }
        break;
    case TransInfo_PR_setMMIRq:
        pstruWjTransInfo->present = pstruAsnTransInfo->present;
        n32Ret = WJV2_SetMMIRq_DfDec(&(pstruAsnTransInfo->choice.setMMIRq), &(pstruWjTransInfo->choice.strusetMMIRq));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_SetMMIRq_DfDec is err");
            return false;
        }
        break;

    default:
        pstruWjTransInfo->present = WJV2_TransInfo_PR_NOTHING;
        break;
    }

    return true;
}
/**
* @brief     WJV2_TransPara_DfEnc编码函数
* @details   协议栈TransPara编解码中 统一TransPara的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_TransPara_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_TacPara *pstruWjTransPara = (WJV2_STRU_TacPara *)pvoidWjDf;
    TransPara_t *pstruAsnTransPara = (TransPara_t *)pvoidAsnDf;

    if ((WJV2_MAX_OCTtransAmount_SIZE != pstruWjTransPara->u8OCTtransAmountNum) /*||
        (1 > pstruWjTransPara->u8OCTtransAmountNum)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjTransPara->u8OCTtransAmountNum = %d",
                 pstruWjTransPara->u8OCTtransAmountNum);
        return false;
    }
    pstruAsnTransPara->transAmount.size = pstruWjTransPara->u8OCTtransAmountNum;
    pstruAsnTransPara->transAmount.buf = CALLOC(1, pstruAsnTransPara->transAmount.size);
    if (NULL == pstruAsnTransPara->transAmount.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DE_MODULE,
                 "calloc is err");
        return false;
    }
    memcpy(pstruAsnTransPara->transAmount.buf, pstruWjTransPara->u8OCTtransAmount, pstruAsnTransPara->transAmount.size);
    if ((WJV2_MAX_OCTtransType_SIZE != pstruWjTransPara->u8OCTtransTypeNum) /*||
        (1 > pstruWjTransPara->u8OCTtransTypeNum)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjTransPara->u8OCTtransTypeNum = %d",
                 pstruWjTransPara->u8OCTtransTypeNum);
        return false;
    }
    pstruAsnTransPara->transType.size = pstruWjTransPara->u8OCTtransTypeNum;
    pstruAsnTransPara->transType.buf = CALLOC(1, pstruAsnTransPara->transType.size);
    if (NULL == pstruAsnTransPara->transType.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DE_MODULE,
                 "calloc is err");
        return false;
    }
    memcpy(pstruAsnTransPara->transType.buf, pstruWjTransPara->u8OCTtransType, pstruAsnTransPara->transType.size);
    if ((WJV2_MAX_OCTterminalID_SIZE != pstruWjTransPara->u8OCTterminalIDNum) /*||
        (1 > pstruWjTransPara->u8OCTterminalIDNum)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjTransPara->u8OCTterminalIDNum = %d",
                 pstruWjTransPara->u8OCTterminalIDNum);
        return false;
    }
    pstruAsnTransPara->terminalID.size = pstruWjTransPara->u8OCTterminalIDNum;
    pstruAsnTransPara->terminalID.buf = CALLOC(1, pstruAsnTransPara->terminalID.size);
    if (NULL == pstruAsnTransPara->terminalID.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DE_MODULE,
                 "calloc is err");
        return false;
    }
    memcpy(pstruAsnTransPara->terminalID.buf, pstruWjTransPara->u8OCTterminalID, pstruAsnTransPara->terminalID.size);
    if ((WJV2_MAX_OCTtransSN_SIZE != pstruWjTransPara->u8OCTtransSNNum) /*||
        (1 > pstruWjTransPara->u8OCTtransSNNum)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjTransPara->u8OCTtransSNNum = %d",
                 pstruWjTransPara->u8OCTtransSNNum);
        return false;
    }
    pstruAsnTransPara->transSN.size = pstruWjTransPara->u8OCTtransSNNum;
    pstruAsnTransPara->transSN.buf = CALLOC(1, pstruAsnTransPara->transSN.size);
    if (NULL == pstruAsnTransPara->transSN.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DE_MODULE,
                 "calloc is err");
        return false;
    }
    memcpy(pstruAsnTransPara->transSN.buf, pstruWjTransPara->u8OCTtransSN, pstruAsnTransPara->transSN.size);
    if ((WJV2_MAX_OCTtransTime_SIZE != pstruWjTransPara->u8OCTtransTimeNum) /*||
        (1 > pstruWjTransPara->u8OCTtransTimeNum)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjTransPara->u8OCTtransTimeNum = %d",
                 pstruWjTransPara->u8OCTtransTimeNum);
        return false;
    }
    pstruAsnTransPara->transTime.size = pstruWjTransPara->u8OCTtransTimeNum;
    pstruAsnTransPara->transTime.buf = CALLOC(1, pstruAsnTransPara->transTime.size);
    if (NULL == pstruAsnTransPara->transTime.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DE_MODULE,
                 "calloc is err");
        return false;
    }
    memcpy(pstruAsnTransPara->transTime.buf, pstruWjTransPara->u8OCTtransTime, pstruAsnTransPara->transTime.size);

    if ((WJV2_MAX_OCTtransStationID_SIZE != pstruWjTransPara->u8OCTtransStationIDNum) /*||
        (1 > pstruWjTransPara->u8OCTtransStationIDNum)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjTransPara->u8OCTtransStationIDNum = %d",
                 pstruWjTransPara->u8OCTtransStationIDNum);
        return false;
    }
    pstruAsnTransPara->transStationID.size = pstruWjTransPara->u8OCTtransStationIDNum;
    pstruAsnTransPara->transStationID.buf = CALLOC(1, pstruAsnTransPara->transStationID.size);
    if (NULL == pstruAsnTransPara->transStationID.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DE_MODULE,
                 "calloc is err");
        return false;
    }
    memcpy(pstruAsnTransPara->transStationID.buf, pstruWjTransPara->u8OCTtransStationID, pstruAsnTransPara->transStationID.size);

    return true;
}
/**
* @brief     WJV2_TransPara_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_TransPara_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_TacPara *pstruWjTransPara = (WJV2_STRU_TacPara *)pvoidWjDf;
    TransPara_t *pstruAsnTransPara = (TransPara_t *)pvoidAsnDf;

    if ((WJV2_MAX_OCTtransAmount_SIZE != pstruAsnTransPara->transAmount.size) /*||
        (1 > pstruAsnTransPara->transAmount.size)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnTransPara->transAmount.size = %d",
                 pstruAsnTransPara->transAmount.size);
        return false;
    }
    pstruWjTransPara->u8OCTtransAmountNum = pstruAsnTransPara->transAmount.size;
    if (NULL == pstruWjTransPara->u8OCTtransAmount)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DE_MODULE,
                 "pstruWjTransPara->u8OCTtransAmount is NULL");
        return false;
    }
    memcpy(pstruWjTransPara->u8OCTtransAmount, pstruAsnTransPara->transAmount.buf, pstruAsnTransPara->transAmount.size);
    if ((WJV2_MAX_OCTtransType_SIZE != pstruAsnTransPara->transType.size) /*||
        (1 > pstruAsnTransPara->transType.size)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnTransPara->transType.size = %d",
                 pstruAsnTransPara->transType.size);
        return false;
    }
    pstruWjTransPara->u8OCTtransTypeNum = pstruAsnTransPara->transType.size;
    if (NULL == pstruWjTransPara->u8OCTtransType)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DE_MODULE,
                 "pstruWjTransPara->u8OCTtransType is NULL");
        return false;
    }
    memcpy(pstruWjTransPara->u8OCTtransType, pstruAsnTransPara->transType.buf, pstruAsnTransPara->transType.size);
    if ((WJV2_MAX_OCTterminalID_SIZE != pstruAsnTransPara->terminalID.size) /*||
        (1 > pstruAsnTransPara->terminalID.size)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnTransPara->terminalID.size = %d",
                 pstruAsnTransPara->terminalID.size);
        return false;
    }
    pstruWjTransPara->u8OCTterminalIDNum = pstruAsnTransPara->terminalID.size;
    if (NULL == pstruWjTransPara->u8OCTterminalID)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DE_MODULE,
                 "pstruWjTransPara->u8OCTterminalID is NULL");
        return false;
    }
    memcpy(pstruWjTransPara->u8OCTterminalID, pstruAsnTransPara->terminalID.buf, pstruAsnTransPara->terminalID.size);
    if ((WJV2_MAX_OCTtransSN_SIZE != pstruAsnTransPara->transSN.size) /*||
        (1 > pstruAsnTransPara->transSN.size)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnTransPara->transSN.size = %d",
                 pstruAsnTransPara->transSN.size);
        return false;
    }
    pstruWjTransPara->u8OCTtransSNNum = pstruAsnTransPara->transSN.size;
    if (NULL == pstruWjTransPara->u8OCTtransSN)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DE_MODULE,
                 "pstruWjTransPara->u8OCTtransSN is NULL");
        return false;
    }
    memcpy(pstruWjTransPara->u8OCTtransSN, pstruAsnTransPara->transSN.buf, pstruAsnTransPara->transSN.size);
    if ((WJV2_MAX_OCTtransTime_SIZE != pstruAsnTransPara->transTime.size) /*||
        (1 > pstruAsnTransPara->transTime.size)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnTransPara->transTime.size = %d",
                 pstruAsnTransPara->transTime.size);
        return false;
    }
    pstruWjTransPara->u8OCTtransTimeNum = pstruAsnTransPara->transTime.size;
    if (NULL == pstruWjTransPara->u8OCTtransTime)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DE_MODULE,
                 "pstruWjTransPara->u8OCTtransTime is NULL");
        return false;
    }
    memcpy(pstruWjTransPara->u8OCTtransTime, pstruAsnTransPara->transTime.buf, pstruAsnTransPara->transTime.size);

    if ((WJV2_MAX_OCTtransStationID_SIZE != pstruAsnTransPara->transStationID.size) /*||
        (1 > pstruAsnTransPara->transStationID.size)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnTransPara->transStationID.size = %d",
                 pstruAsnTransPara->transStationID.size);
        return false;
    }
    pstruWjTransPara->u8OCTtransStationIDNum = pstruAsnTransPara->transStationID.size;
    if (NULL == pstruWjTransPara->u8OCTtransStationID)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DE_MODULE,
                 "pstruWjTransPara->u8OCTtransStationID is NULL");
        return false;
    }
    memcpy(pstruWjTransPara->u8OCTtransStationID, pstruAsnTransPara->transStationID.buf, pstruAsnTransPara->transStationID.size);

    return true;
}
/**
* @brief     WJV2_TollInfo_DfEnc编码函数
* @details   协议栈TollInfo编解码中 统一TollInfo的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_TollInfo_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_TollInfo *pstruWjTollInfo = (WJV2_STRU_TollInfo *)pvoidWjDf;
    TollInfo_t *pstruAsnTollInfo = (TollInfo_t *)pvoidAsnDf;
    NodeReferenceID_t *pstrbitAsnNodeReferenceID_node = NULL;
    int32_t n32Ret = 0;
    int32_t u32i = 0;
    if (WJV2_PRESENT == pstruWjTollInfo->u8pricePresent)
    {
        if ((WJV2_MAX_price_SIZE < pstruWjTollInfo->n32price) ||
            (WJV2_MIN_price_SIZE > pstruWjTollInfo->n32price))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjTollInfo->n32price = %d",
                     pstruWjTollInfo->n32price);
            return false;
        }

        pstruAsnTollInfo->price = CALLOC(1, sizeof(long));
        if (NULL == pstruAsnTollInfo->price)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnTollInfo->price) = pstruWjTollInfo->n32price;
    }
    else
    {
        pstruAsnTollInfo->price = NULL;
    }
    if (WJV2_PRESENT == pstruWjTollInfo->u8entrancePosPresent)
    {
        pstruAsnTollInfo->entrancePos = CALLOC(1, sizeof(struct PositionOffsetLLV));
        if (NULL == pstruAsnTollInfo->entrancePos)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PositionOffsetLLV_DfEnc(pstruAsnTollInfo->entrancePos, &(pstruWjTollInfo->struentrancePos));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionOffsetLLV_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnTollInfo->entrancePos = NULL;
    }

    if (WJV2_PRESENT == pstruWjTollInfo->u8exitPosPresent)
    {
        pstruAsnTollInfo->exitPos = CALLOC(1, sizeof(struct PositionOffsetLLV));
        if (NULL == pstruAsnTollInfo->exitPos)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PositionOffsetLLV_DfEnc(pstruAsnTollInfo->exitPos, &(pstruWjTollInfo->struexitPos));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionOffsetLLV_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnTollInfo->exitPos = NULL;
    }

    if (WJV2_PRESENT == pstruWjTollInfo->u8tollRoadPresent)
    {
        if ((WJV2_MAX_LIST_tollRoad_LEN < pstruWjTollInfo->strutollRoad.u16NodeReferenceIDNum) ||
            (WJV2_MIN_LIST_tollRoad_LEN > pstruWjTollInfo->strutollRoad.u16NodeReferenceIDNum))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjTollInfo->strutollRoad.u16NodeReferenceIDNum = %d",
                     pstruWjTollInfo->strutollRoad.u16NodeReferenceIDNum);
            return false;
        }
        for (u32i = 0; u32i < pstruWjTollInfo->strutollRoad.u16NodeReferenceIDNum; u32i++)
        {
            pstrbitAsnNodeReferenceID_node = CALLOC(1, sizeof(NodeReferenceID_t));
            if (NULL == pstrbitAsnNodeReferenceID_node)
            {
                LogPrint(LOG_LEVEL_ERR,
                         STACK_DF_MODULE,
                         "CALLOC is err");
                return false;
            }
            n32Ret = WJV2_NodeReferenceID_DfEnc(pstrbitAsnNodeReferenceID_node, &(pstruWjTollInfo->strutollRoad.struNodeReferenceID[u32i]));
            if (true != n32Ret)
            {
                LogPrint(LOG_LEVEL_ERR,
                         STACK_DF_MODULE,
                         "WJV2_NodeReferenceID_DfEnc is err");
                return false;
            }
            asn_sequence_add(&(pstruAsnTollInfo->tollRoad->list), pstrbitAsnNodeReferenceID_node);
        }
        pstruAsnTollInfo->tollRoad->list.count = pstruWjTollInfo->strutollRoad.u16NodeReferenceIDNum;
    }
    else
    {
        pstruAsnTollInfo->tollRoad = NULL;
    }

    if (WJV2_PRESENT == pstruWjTollInfo->u8tollPathPresent)
    {
        pstruAsnTollInfo->tollPath = CALLOC(1, sizeof(struct ReferencePath));
        if (NULL == pstruAsnTollInfo->tollPath)
        {
            LogPrint(LOG_LEVEL_ERR, STACK_DF_MODULE, "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_ReferencePath_DfEnc(pstruAsnTollInfo->tollPath, &(pstruWjTollInfo->strutollPath));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR, STACK_DF_MODULE, "WJV2_PositionOffsetLLV_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnTollInfo->tollPath = NULL;
    }

    if (WJV2_PRESENT == pstruWjTollInfo->u8timeBeginPresent)
    {
        pstruAsnTollInfo->timeBegin = CALLOC(1, sizeof(struct DDateTime));
        if (NULL == pstruAsnTollInfo->timeBegin)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_DDateTime_DfEnc(pstruAsnTollInfo->timeBegin, &(pstruWjTollInfo->strutimeBegin));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DDateTime_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnTollInfo->timeBegin = NULL;
    }
    if (WJV2_PRESENT == pstruWjTollInfo->u8timeEndPresent)
    {
        pstruAsnTollInfo->timeEnd = CALLOC(1, sizeof(struct DDateTime));
        if (NULL == pstruAsnTollInfo->timeEnd)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_DDateTime_DfEnc(pstruAsnTollInfo->timeEnd, &(pstruWjTollInfo->strutimeEnd));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DDateTime_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnTollInfo->timeEnd = NULL;
    }

    return true;
}
/**
* @brief     WJV2_TollInfo_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_TollInfo_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_TollInfo *pstruWjTollInfo = (WJV2_STRU_TollInfo *)pvoidWjDf;
    TollInfo_t *pstruAsnTollInfo = (TollInfo_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    int32_t u32i = 0;
    if (NULL != pstruAsnTollInfo->price)
    {
        if ((WJV2_MAX_price_SIZE < *(pstruAsnTollInfo->price)) ||
            (WJV2_MIN_price_SIZE > *(pstruAsnTollInfo->price)))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:*(pstruAsnTollInfo->price) = %d",
                     *(pstruAsnTollInfo->price));
            return false;
        }

        pstruWjTollInfo->n32price = *(pstruAsnTollInfo->price);
        pstruWjTollInfo->u8pricePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjTollInfo->u8pricePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnTollInfo->entrancePos)
    {
        n32Ret = WJV2_PositionOffsetLLV_DfDec(pstruAsnTollInfo->entrancePos, &(pstruWjTollInfo->struentrancePos));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionOffsetLLV_DfDec is err");
            return false;
        }
        pstruWjTollInfo->u8entrancePosPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjTollInfo->u8entrancePosPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnTollInfo->exitPos)
    {
        n32Ret = WJV2_PositionOffsetLLV_DfDec(pstruAsnTollInfo->exitPos, &(pstruWjTollInfo->struexitPos));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PositionOffsetLLV_DfDec is err");
            return false;
        }
        pstruWjTollInfo->u8exitPosPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjTollInfo->u8exitPosPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnTollInfo->tollRoad)
    {
        if ((WJV2_MAX_LIST_tollRoad_LEN < pstruAsnTollInfo->tollRoad->list.count) ||
            (WJV2_MIN_LIST_tollRoad_LEN > pstruAsnTollInfo->tollRoad->list.count))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruAsnTollInfo->tollRoad->list.count = %d",
                     pstruAsnTollInfo->tollRoad->list.count);
            return false;
        }
        for (u32i = 0; u32i < pstruAsnTollInfo->tollRoad->list.count; u32i++)
        {
            n32Ret = WJV2_NodeReferenceID_DfDec(pstruAsnTollInfo->tollRoad->list.array[u32i], &(pstruWjTollInfo->strutollRoad.struNodeReferenceID[u32i]));
            if (true != n32Ret)
            {
                LogPrint(LOG_LEVEL_ERR,
                         STACK_DF_MODULE,
                         "WJV2_NodeReferenceID_DfDec is err");
                return false;
            }
        }
        pstruWjTollInfo->strutollRoad.u16NodeReferenceIDNum = (uint8_t)u32i;
        pstruWjTollInfo->u8tollRoadPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjTollInfo->u8tollRoadPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnTollInfo->tollPath)
    {
        n32Ret = WJV2_ReferencePath_DfDec(pstruAsnTollInfo->tollPath, &(pstruWjTollInfo->strutollPath));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_ReferencePath_DfDec is err");
            return false;
        }
        pstruWjTollInfo->u8tollPathPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjTollInfo->u8tollPathPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnTollInfo->timeBegin)
    {
        n32Ret = WJV2_DDateTime_DfDec(pstruAsnTollInfo->timeBegin, &(pstruWjTollInfo->strutimeBegin));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DDateTime_DfDec is err");
            return false;
        }
        pstruWjTollInfo->u8timeBeginPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjTollInfo->u8timeBeginPresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnTollInfo->timeEnd)
    {
        n32Ret = WJV2_DDateTime_DfDec(pstruAsnTollInfo->timeEnd, &(pstruWjTollInfo->strutimeEnd));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DDateTime_DfDec is err");
            return false;
        }
        pstruWjTollInfo->u8timeEndPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjTollInfo->u8timeEndPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_TollingPos_DfEnc编码函数
* @details   协议栈TollingPos编解码中 统一TollingPos的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_TollingPos_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_TollingPos *pstruWjTollingPos = (WJV2_STRU_TollingPos *)pvoidWjDf;
    TollingPos_t *pstruAsnTollingPos = (TollingPos_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    pstruAsnTollingPos->id = pstruWjTollingPos->id;
    if (WJV2_PRESENT == pstruWjTollingPos->u8posPresent)
    {
        pstruAsnTollingPos->pos = CALLOC(1, sizeof(struct Position3D));
        if (NULL == pstruAsnTollingPos->pos)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_Position3D_DfEnc(pstruAsnTollingPos->pos, &(pstruWjTollingPos->sturpos));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Position3D_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnTollingPos->pos = NULL;
    }

    return true;
}
/**
* @brief     WJV2_TollingPos_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_TollingPos_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_TollingPos *pstruWjTollingPos = (WJV2_STRU_TollingPos *)pvoidWjDf;
    TollingPos_t *pstruAsnTollingPos = (TollingPos_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    pstruWjTollingPos->id = pstruAsnTollingPos->id;
    if (NULL != pstruAsnTollingPos->pos)
    {
        n32Ret = WJV2_Position3D_DfDec(pstruAsnTollingPos->pos, &(pstruWjTollingPos->sturpos));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Position3D_DfDec is err");
            return false;
        }
        pstruWjTollingPos->u8posPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjTollingPos->u8posPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_TollingNodeInfo_DfEnc编��函数
* @details   协议栈TollingNodeInfo编解码中 统一TollingNodeInfo的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_TollingNodeInfo_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_TollingNodeInfo *pstruWjTollingNodeInfo = (WJV2_STRU_TollingNodeInfo *)pvoidWjDf;
    TollingNodeInfo_t *pstruAsnTollingNodeInfo = (TollingNodeInfo_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (WJV2_PRESENT == pstruWjTollingNodeInfo->u8idPresent)
    {
        pstruAsnTollingNodeInfo->id = CALLOC(1, sizeof(StationOrGantryId_t));
        if (NULL == pstruAsnTollingNodeInfo->id)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnTollingNodeInfo->id) = pstruWjTollingNodeInfo->id;
    }
    else
    {
        pstruAsnTollingNodeInfo->id = NULL;
    }
    if (WJV2_PRESENT == pstruWjTollingNodeInfo->u8posPresent)
    {
        pstruAsnTollingNodeInfo->pos = CALLOC(1, sizeof(struct Position3D));
        if (NULL == pstruAsnTollingNodeInfo->pos)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_Position3D_DfEnc(pstruAsnTollingNodeInfo->pos, &(pstruWjTollingNodeInfo->strupos));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Position3D_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnTollingNodeInfo->pos = NULL;
    }
    if (WJV2_PRESENT == pstruWjTollingNodeInfo->u8tollingNodeTypePresent)
    {
        pstruAsnTollingNodeInfo->tollingNodeType = CALLOC(1, sizeof(TollingNodeType_t));
        if (NULL == pstruAsnTollingNodeInfo->tollingNodeType)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnTollingNodeInfo->tollingNodeType) = pstruWjTollingNodeInfo->enumtollingNodeType;
    }
    else
    {
        pstruAsnTollingNodeInfo->tollingNodeType = NULL;
    }

    if (WJV2_PRESENT == pstruWjTollingNodeInfo->u8tollingDirectionPresent)
    {
        pstruAsnTollingNodeInfo->tollingDirection = CALLOC(1, sizeof(TollingDirection_t));
        if (NULL == pstruAsnTollingNodeInfo->tollingDirection)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        *(pstruAsnTollingNodeInfo->tollingDirection) = pstruWjTollingNodeInfo->enumtollingDirection;
    }
    else
    {
        pstruAsnTollingNodeInfo->tollingDirection = NULL;
    }

    return true;
}
/**
* @brief     WJV2_TollingNodeInfo_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_TollingNodeInfo_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_TollingNodeInfo *pstruWjTollingNodeInfo = (WJV2_STRU_TollingNodeInfo *)pvoidWjDf;
    TollingNodeInfo_t *pstruAsnTollingNodeInfo = (TollingNodeInfo_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if (NULL != pstruAsnTollingNodeInfo->id)
    {
        pstruWjTollingNodeInfo->id = *(pstruAsnTollingNodeInfo->id);
        pstruWjTollingNodeInfo->u8idPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjTollingNodeInfo->u8idPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnTollingNodeInfo->pos)
    {
        n32Ret = WJV2_Position3D_DfDec(pstruAsnTollingNodeInfo->pos, &(pstruWjTollingNodeInfo->strupos));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Position3D_DfDec is err");
            return false;
        }
        pstruWjTollingNodeInfo->u8posPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjTollingNodeInfo->u8posPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnTollingNodeInfo->tollingNodeType)
    {
        pstruWjTollingNodeInfo->enumtollingNodeType = *(pstruAsnTollingNodeInfo->tollingNodeType);
        pstruWjTollingNodeInfo->u8tollingNodeTypePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjTollingNodeInfo->u8tollingNodeTypePresent = WJV2_ABSENT;
    }

    if (NULL != pstruAsnTollingNodeInfo->tollingDirection)
    {
        pstruWjTollingNodeInfo->enumtollingDirection = *(pstruAsnTollingNodeInfo->tollingDirection);
        pstruWjTollingNodeInfo->u8tollingDirectionPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjTollingNodeInfo->u8tollingDirectionPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_VehicleCoordination_DfEnc编码函数
* @details   协议栈VehicleCoordination编解码中 统一VehicleCoordination的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_VehicleCoordination_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_VehicleCoordination *pstruWjVehicleCoordination = (WJV2_STRU_VehicleCoordination *)pvoidWjDf;
    VehicleCoordination_t *pstruAsnVehicleCoordination = (VehicleCoordination_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_OCTvehId_SIZE != pstruWjVehicleCoordination->u8OCTvehIdNum) /*||
        (1 > pstruWjVehicleCoordination->u8OCTvehIdNum)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjVehicleCoordination->u8OCTvehIdNum = %d",
                 pstruWjVehicleCoordination->u8OCTvehIdNum);
        return false;
    }
    pstruAsnVehicleCoordination->vehId.size = pstruWjVehicleCoordination->u8OCTvehIdNum;
    pstruAsnVehicleCoordination->vehId.buf = CALLOC(1, pstruAsnVehicleCoordination->vehId.size);
    if (NULL == pstruAsnVehicleCoordination->vehId.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruAsnVehicleCoordination->vehId.buf, pstruWjVehicleCoordination->u8OCTvehId, pstruAsnVehicleCoordination->vehId.size);
    if (WJV2_PRESENT == pstruWjVehicleCoordination->u8driveSuggestionPresent)
    {
        pstruAsnVehicleCoordination->driveSuggestion = CALLOC(1, sizeof(struct DriveSuggestion));
        if (NULL == pstruAsnVehicleCoordination->driveSuggestion)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_DriveSuggestion_DfEnc(pstruAsnVehicleCoordination->driveSuggestion, &(pstruWjVehicleCoordination->strudriveSuggestion));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DriveSuggestion_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnVehicleCoordination->driveSuggestion = NULL;
    }
    if (WJV2_PRESENT == pstruWjVehicleCoordination->u8pathGuidancePresent)
    {
        pstruAsnVehicleCoordination->pathGuidance = CALLOC(1, sizeof(struct PathPlanning));
        if (NULL == pstruAsnVehicleCoordination->pathGuidance)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_PathPlanning_DfEnc(pstruAsnVehicleCoordination->pathGuidance, &(pstruWjVehicleCoordination->strupathGuidance));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PathPlanning_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnVehicleCoordination->pathGuidance = NULL;
    }
    if (WJV2_PRESENT == pstruWjVehicleCoordination->u8infoPresent)
    {
        pstruAsnVehicleCoordination->info = CALLOC(1, sizeof(CoordinationInfo_t));
        if (NULL == pstruAsnVehicleCoordination->info)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_CoordinationInfo_DeEnc(pstruAsnVehicleCoordination->info, &(pstruWjVehicleCoordination->bitinfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_CoordinationInfo_DeEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnVehicleCoordination->info = NULL;
    }

    return true;
}
/**
* @brief     WJV2_VehicleCoordination_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修��日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_VehicleCoordination_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_VehicleCoordination *pstruWjVehicleCoordination = (WJV2_STRU_VehicleCoordination *)pvoidWjDf;
    VehicleCoordination_t *pstruAsnVehicleCoordination = (VehicleCoordination_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_OCTvehId_SIZE != pstruAsnVehicleCoordination->vehId.size) /*||
        (1 > pstruAsnVehicleCoordination->vehId.size)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnVehicleCoordination->vehId.size = %d",
                 pstruAsnVehicleCoordination->vehId.size);
        return false;
    }
    pstruWjVehicleCoordination->u8OCTvehIdNum = pstruAsnVehicleCoordination->vehId.size;
    if (NULL == pstruWjVehicleCoordination->u8OCTvehId)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "pstruWjVehicleCoordination->u8OCTvehId is NULL");
        return false;
    }
    memcpy(pstruWjVehicleCoordination->u8OCTvehId, pstruAsnVehicleCoordination->vehId.buf, pstruAsnVehicleCoordination->vehId.size);
    if (NULL != pstruAsnVehicleCoordination->driveSuggestion)
    {
        n32Ret = WJV2_DriveSuggestion_DfDec(pstruAsnVehicleCoordination->driveSuggestion, &(pstruWjVehicleCoordination->strudriveSuggestion));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_DriveSuggestion_DfDec is err");
            return false;
        }
        pstruWjVehicleCoordination->u8driveSuggestionPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjVehicleCoordination->u8driveSuggestionPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnVehicleCoordination->pathGuidance)
    {
        n32Ret = WJV2_PathPlanning_DfDec(pstruAsnVehicleCoordination->pathGuidance, &(pstruWjVehicleCoordination->strupathGuidance));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_PathPlanning_DfDec is err");
            return false;
        }
        pstruWjVehicleCoordination->u8pathGuidancePresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjVehicleCoordination->u8pathGuidancePresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnVehicleCoordination->pathGuidance)
    {
        n32Ret = WJV2_CoordinationInfo_DeDec(pstruAsnVehicleCoordination->info, &(pstruWjVehicleCoordination->bitinfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_CoordinationInfo_DeDec is err");
            return false;
        }
        pstruWjVehicleCoordination->u8infoPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjVehicleCoordination->u8infoPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_VehicleDimensions_DfEnc编码函数
* @details   协议栈VehicleDimensions编解码中 统一VehicleDimensions的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_VehicleDimensions_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_VehicleDimensions *pstruWjVehicleDimensions = (WJV2_STRU_VehicleDimensions *)pvoidWjDf;
    VehicleDimensions_t *pstruAsnVehicleDimensions = (VehicleDimensions_t *)pvoidAsnDf;
    pstruAsnVehicleDimensions->vehicleLength = pstruWjVehicleDimensions->n32vehicleLength;
    pstruAsnVehicleDimensions->vehicleWidth = pstruWjVehicleDimensions->n32vehicleWidth;
    pstruAsnVehicleDimensions->vehicleHeigth = pstruWjVehicleDimensions->vehicleHeigth;

    return true;
}
/**
* @brief     WJV2_VehicleDimensions_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_VehicleDimensions_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_VehicleDimensions *pstruWjVehicleDimensions = (WJV2_STRU_VehicleDimensions *)pvoidWjDf;
    VehicleDimensions_t *pstruAsnVehicleDimensions = (VehicleDimensions_t *)pvoidAsnDf;
    pstruWjVehicleDimensions->n32vehicleLength = pstruAsnVehicleDimensions->vehicleLength;
    pstruWjVehicleDimensions->n32vehicleWidth = pstruAsnVehicleDimensions->vehicleWidth;
    pstruWjVehicleDimensions->vehicleHeigth = pstruAsnVehicleDimensions->vehicleHeigth;

    return true;
}
/**
* @brief     WJV2_VehicleInfo_DfEnc编码函数
* @details   协议栈VehicleInfo编解码中 统一VehicleInfo的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_VehicleInfo_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_VehicleInfo *pstruWjVehicleInfo = (WJV2_STRU_VehicleInfo *)pvoidWjDf;
    VehicleInfo_t *pstruAsnVehicleInfo = (VehicleInfo_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    pstruAsnVehicleInfo->vehicleLicencePlateNumber.size = WJV2_MAX_OCTvehicleLicencePlateNumber_SIZE;
    pstruAsnVehicleInfo->vehicleLicencePlateNumber.buf = CALLOC(1, pstruAsnVehicleInfo->vehicleLicencePlateNumber.size);
    if (NULL == pstruAsnVehicleInfo->vehicleLicencePlateNumber.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruAsnVehicleInfo->vehicleLicencePlateNumber.buf, pstruWjVehicleInfo->u8OCTvehicleLicencePlateNumber, pstruAsnVehicleInfo->vehicleEngineNumber.size);
    pstruAsnVehicleInfo->vehicleLicencePlateColor.size = WJV2_MAX_OCTvehicleLicencePlateColor_SIZE;
    pstruAsnVehicleInfo->vehicleLicencePlateColor.buf = CALLOC(1, pstruAsnVehicleInfo->vehicleLicencePlateColor.size);
    if (NULL == pstruAsnVehicleInfo->vehicleLicencePlateColor.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruAsnVehicleInfo->vehicleLicencePlateColor.buf, pstruWjVehicleInfo->u8OCTvehicleLicencePlateColor, pstruAsnVehicleInfo->vehicleEngineNumber.size);
    if ((WJV2_MAX_vehicleTollingClass_SIZE < pstruWjVehicleInfo->n32vehicleTollingClass) ||
        (WJV2_MIN_vehicleTollingClass_SIZE > pstruWjVehicleInfo->n32vehicleTollingClass))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjVehicleInfo->n32vehicleTollingClass= %d",
                 pstruWjVehicleInfo->n32vehicleTollingClass);
        return false;
    }
    pstruAsnVehicleInfo->vehicleTollingClass = pstruWjVehicleInfo->n32vehicleTollingClass;
    if ((WJV2_MAX_vehicleUserType_SIZE < pstruWjVehicleInfo->n32vehicleUserType) ||
        (WJV2_MIN_vehicleUserType_SIZE > pstruWjVehicleInfo->n32vehicleUserType))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjVehicleInfo->n32vehicleUserType= %d",
                 pstruWjVehicleInfo->n32vehicleUserType);
        return false;
    }
    pstruAsnVehicleInfo->vehicleUserType = pstruWjVehicleInfo->n32vehicleUserType;
    n32Ret = WJV2_VehicleDimensions_DfEnc(&(pstruAsnVehicleInfo->vehicleDimensions), &(pstruWjVehicleInfo->struvehicleDimensions));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_VehicleDimensions_DfEnc is err");
        return false;
    }

    if ((WJV2_MAX_vehicleWheels_SIZE < pstruWjVehicleInfo->n32vehicleWheels) ||
        (WJV2_MIN_vehicleWheels_SIZE > pstruWjVehicleInfo->n32vehicleWheels))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjVehicleInfo->n32vehicleWheels= %d",
                 pstruWjVehicleInfo->n32vehicleWheels);
        return false;
    }
    pstruAsnVehicleInfo->vehicleWheels = pstruWjVehicleInfo->n32vehicleWheels;

    if ((WJV2_MAX_vehicleAxles_SIZE < pstruWjVehicleInfo->n32vehicleAxles) ||
        (WJV2_MIN_vehicleAxles_SIZE > pstruWjVehicleInfo->n32vehicleAxles))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjVehicleInfo->n32vehicleAxles= %d",
                 pstruWjVehicleInfo->n32vehicleAxles);
        return false;
    }
    pstruAsnVehicleInfo->vehicleAxles = pstruWjVehicleInfo->n32vehicleAxles;

    if ((WJV2_MAX_vehicleWheelBases_SIZE < pstruWjVehicleInfo->n32vehicleWheelBases) ||
        (WJV2_MIN_vehicleWheelBases_SIZE > pstruWjVehicleInfo->n32vehicleWheelBases))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjVehicleInfo->n32vehicleWheelBases= %d",
                 pstruWjVehicleInfo->n32vehicleWheelBases);
        return false;
    }
    pstruAsnVehicleInfo->vehicleWheelBases = pstruWjVehicleInfo->n32vehicleWheelBases;

    if ((WJV2_MAX_vehicleWeightLimits_SIZE < pstruWjVehicleInfo->n32vehicleWeightLimits) ||
        (WJV2_MAX_vehicleWeightLimits_SIZE > pstruWjVehicleInfo->n32vehicleWeightLimits))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjVehicleInfo->n32vehicleWeightLimits= %d",
                 pstruWjVehicleInfo->n32vehicleWeightLimits);
        return false;
    }
    pstruAsnVehicleInfo->vehicleWeightLimits = pstruWjVehicleInfo->n32vehicleWeightLimits;
    if ((WJV2_MAX_OCTvehicleSpecificInformation_SIZE != pstruWjVehicleInfo->u8OCTvehicleSpecificInformationNum) /*||
        (1 > pstruWjVehicleInfo->u8OCTvehicleSpecificInformationNum)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjVehicleInfo->u8OCTvehicleSpecificInformationNum= %d",
                 pstruWjVehicleInfo->u8OCTvehicleSpecificInformationNum);
        return false;
    }
    pstruAsnVehicleInfo->vehicleSpecificInformation.size = pstruWjVehicleInfo->u8OCTvehicleSpecificInformationNum;
    pstruAsnVehicleInfo->vehicleSpecificInformation.buf = CALLOC(1, pstruAsnVehicleInfo->vehicleSpecificInformation.size);
    if (NULL == pstruAsnVehicleInfo->vehicleSpecificInformation.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruAsnVehicleInfo->vehicleSpecificInformation.buf, pstruWjVehicleInfo->u8OCTvehicleSpecificInformation, pstruAsnVehicleInfo->vehicleSpecificInformation.size);
    pstruAsnVehicleInfo->vehicleEngineNumber.size = WJV2_MAX_OCTvehicleEngineNumber_SIZE;
    pstruAsnVehicleInfo->vehicleEngineNumber.buf = CALLOC(1, pstruAsnVehicleInfo->vehicleEngineNumber.size);
    if (NULL == pstruAsnVehicleInfo->vehicleEngineNumber.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruAsnVehicleInfo->vehicleEngineNumber.buf, pstruWjVehicleInfo->u8OCTvehicleEngineNumber, pstruAsnVehicleInfo->vehicleEngineNumber.size);
    if (WJV2_PRESENT == pstruWjVehicleInfo->u8descriptionPresent)
    {
        if ((WJV2_MAX_OCTdescription_SIZE < pstruWjVehicleInfo->u16OCTdescriptionNum) ||
            (WJV2_MIN_OCTdescription_SIZE > pstruWjVehicleInfo->u16OCTdescriptionNum))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruWjVehicleInfo->u16OCTdescriptionNum = %d",
                     pstruWjVehicleInfo->u16OCTdescriptionNum);
            return false;
        }
        pstruAsnVehicleInfo->description = CALLOC(1, sizeof(OCTET_STRING_t));
        if (NULL == pstruAsnVehicleInfo->description)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        pstruAsnVehicleInfo->description->size = pstruWjVehicleInfo->u16OCTdescriptionNum;
        pstruAsnVehicleInfo->description->buf = CALLOC(1, pstruAsnVehicleInfo->description->size);
        if (NULL == pstruAsnVehicleInfo->description->buf)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        memcpy(pstruAsnVehicleInfo->description->buf, pstruWjVehicleInfo->u8OCTdescription, pstruAsnVehicleInfo->description->size);
    }
    else
    {
        pstruAsnVehicleInfo->description = NULL;
    }
    return true;
}
/**
* @brief     WJV2_VehicleInfo_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_VehicleInfo_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_VehicleInfo *pstruWjVehicleInfo = (WJV2_STRU_VehicleInfo *)pvoidWjDf;
    VehicleInfo_t *pstruAsnVehicleInfo = (VehicleInfo_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    if ((WJV2_MAX_OCTvehicleLicencePlateNumber_SIZE != pstruAsnVehicleInfo->vehicleLicencePlateNumber.size) /*||
        (1 > pstruAsnVehicleInfo->vehicleLicencePlateNumber.size)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnVehicleInfo->vehicleLicencePlateNumber.size= %d",
                 pstruAsnVehicleInfo->vehicleLicencePlateNumber.size);
        return false;
    }
    if (NULL == pstruWjVehicleInfo->u8OCTvehicleLicencePlateNumber)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "pstruWjVehicleInfo->u8OCTvehicleLicencePlateNumber is NULL");
        return false;
    }
    memcpy(pstruWjVehicleInfo->u8OCTvehicleLicencePlateNumber, pstruAsnVehicleInfo->vehicleLicencePlateNumber.buf, pstruAsnVehicleInfo->vehicleEngineNumber.size);
    if ((WJV2_MAX_OCTvehicleLicencePlateColor_SIZE != pstruAsnVehicleInfo->vehicleLicencePlateColor.size) /*||
        (1 > pstruAsnVehicleInfo->vehicleLicencePlateColor.size)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnVehicleInfo->vehicleLicencePlateColor.size= %d",
                 pstruAsnVehicleInfo->vehicleLicencePlateColor.size);
        return false;
    }
    if (NULL == pstruWjVehicleInfo->u8OCTvehicleLicencePlateNumber)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "pstruWjVehicleInfo->u8OCTvehicleLicencePlateColor is NULL");
        return false;
    }
    memcpy(pstruWjVehicleInfo->u8OCTvehicleLicencePlateColor, pstruAsnVehicleInfo->vehicleLicencePlateColor.buf, pstruAsnVehicleInfo->vehicleEngineNumber.size);

    if ((WJV2_MAX_vehicleTollingClass_SIZE < pstruAsnVehicleInfo->vehicleTollingClass) ||
        (WJV2_MIN_vehicleTollingClass_SIZE > pstruAsnVehicleInfo->vehicleTollingClass))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnVehicleInfo->vehicleTollingClass= %d",
                 pstruAsnVehicleInfo->vehicleTollingClass);
        return false;
    }
    pstruWjVehicleInfo->n32vehicleTollingClass = pstruAsnVehicleInfo->vehicleTollingClass;

    if ((WJV2_MAX_vehicleUserType_SIZE < pstruAsnVehicleInfo->vehicleUserType) ||
        (WJV2_MIN_vehicleUserType_SIZE > pstruAsnVehicleInfo->vehicleUserType))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnVehicleInfo->vehicleUserType= %d",
                 pstruAsnVehicleInfo->vehicleUserType);
        return false;
    }
    pstruWjVehicleInfo->n32vehicleUserType = pstruAsnVehicleInfo->vehicleUserType;
    n32Ret = WJV2_VehicleDimensions_DfDec(&(pstruAsnVehicleInfo->vehicleDimensions), &(pstruWjVehicleInfo->struvehicleDimensions));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_VehicleDimensions_DfDec is err");
        return false;
    }
    if ((WJV2_MAX_vehicleWheels_SIZE < pstruAsnVehicleInfo->vehicleWheels) ||
        (WJV2_MIN_vehicleWheels_SIZE > pstruAsnVehicleInfo->vehicleWheels))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnVehicleInfo->vehicleWheels= %d",
                 pstruAsnVehicleInfo->vehicleWheels);
        return false;
    }
    pstruWjVehicleInfo->n32vehicleWheels = pstruAsnVehicleInfo->vehicleWheels;

    if ((WJV2_MAX_vehicleAxles_SIZE < pstruAsnVehicleInfo->vehicleAxles) ||
        (WJV2_MIN_vehicleAxles_SIZE > pstruAsnVehicleInfo->vehicleAxles))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnVehicleInfo->vehicleAxles= %d",
                 pstruAsnVehicleInfo->vehicleAxles);
        return false;
    }
    pstruWjVehicleInfo->n32vehicleAxles = pstruAsnVehicleInfo->vehicleAxles;

    if ((WJV2_MAX_vehicleWheelBases_SIZE < pstruAsnVehicleInfo->vehicleWheelBases) ||
        (WJV2_MIN_vehicleWheelBases_SIZE > pstruAsnVehicleInfo->vehicleWheelBases))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnVehicleInfo->vehicleWheelBases= %d",
                 pstruAsnVehicleInfo->vehicleWheelBases);
        return false;
    }
    pstruWjVehicleInfo->n32vehicleWheelBases = pstruAsnVehicleInfo->vehicleWheelBases;

    if ((WJV2_MAX_vehicleWeightLimits_SIZE < pstruAsnVehicleInfo->vehicleWeightLimits) ||
        (WJV2_MAX_vehicleWeightLimits_SIZE > pstruAsnVehicleInfo->vehicleWeightLimits))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnVehicleInfo->vehicleWeightLimits= %d",
                 pstruAsnVehicleInfo->vehicleWeightLimits);
        return false;
    }
    pstruWjVehicleInfo->n32vehicleWeightLimits = pstruAsnVehicleInfo->vehicleWeightLimits;
    if ((WJV2_MAX_OCTvehicleSpecificInformation_SIZE != pstruAsnVehicleInfo->vehicleSpecificInformation.size) /*||
        (1 > pstruAsnVehicleInfo->vehicleSpecificInformation.size)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnVehicleInfo->vehicleSpecificInformation.size= %d",
                 pstruAsnVehicleInfo->vehicleSpecificInformation.size);
        return false;
    }
    pstruWjVehicleInfo->u8OCTvehicleSpecificInformationNum = pstruAsnVehicleInfo->vehicleSpecificInformation.size;
    if (NULL == pstruWjVehicleInfo->u8OCTvehicleSpecificInformation)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "pstruWjVehicleInfo->u8OCTvehicleSpecificInformation is NULL");
        return false;
    }
    memcpy(pstruWjVehicleInfo->u8OCTvehicleSpecificInformation, pstruAsnVehicleInfo->vehicleSpecificInformation.buf, pstruAsnVehicleInfo->vehicleSpecificInformation.size);
    if ((WJV2_MAX_OCTvehicleEngineNumber_SIZE != pstruAsnVehicleInfo->vehicleEngineNumber.size) /*||
        (1 > pstruAsnVehicleInfo->vehicleEngineNumber.size)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnVehicleInfo->vehicleEngineNumber.size= %d",
                 pstruAsnVehicleInfo->vehicleEngineNumber.size);
        return false;
    }
    if (NULL == pstruWjVehicleInfo->u8OCTvehicleEngineNumber)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "pstruWjVehicleInfo->u8OCTvehicleEngineNumber is NULL");
        return false;
    }
    memcpy(pstruWjVehicleInfo->u8OCTvehicleEngineNumber, pstruAsnVehicleInfo->vehicleEngineNumber.buf, pstruAsnVehicleInfo->vehicleEngineNumber.size);
    if (NULL == pstruAsnVehicleInfo->description)
    {
        if ((WJV2_MAX_OCTdescription_SIZE < pstruAsnVehicleInfo->description->size) ||
            (WJV2_MIN_OCTdescription_SIZE > pstruAsnVehicleInfo->description->size))
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruAsnVehicleInfo->description->size = %d",
                     pstruAsnVehicleInfo->description->size);
            return false;
        }
        pstruWjVehicleInfo->u16OCTdescriptionNum = pstruAsnVehicleInfo->description->size;
        if (NULL == pstruWjVehicleInfo->u8OCTdescription)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "pstruWjVehicleInfo->u8OCTdescription is NULL");
            return false;
        }
        memcpy(pstruWjVehicleInfo->u8OCTdescription, pstruAsnVehicleInfo->description->buf, pstruAsnVehicleInfo->description->size);
        pstruWjVehicleInfo->u8descriptionPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjVehicleInfo->u8descriptionPresent = WJV2_ABSENT;
    }

    return true;
}
/**
* @brief     WJV2_VPApplicationList_DfEnc编码函数
* @details   协议栈VPApplicationList编解码中 统一VPApplicationList的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_VPApplicationList_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_VPApplicationList *pstruWjVPApplicationList = (WJV2_STRU_VPApplicationList *)pvoidWjDf;
    VPApplicationList_t *pstruAsnVPApplicationList = (VPApplicationList_t *)pvoidAsnDf;
    VPApplicationParameter_t *pstruVPApplicationParameter_node = NULL;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_VPApplicationParameter_LEN < pstruWjVPApplicationList->u8VPApplicationParameterNum) ||
        (WJV2_MIN_LIST_VPApplicationParameter_LEN > pstruWjVPApplicationList->u8VPApplicationParameterNum))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruWjVPApplicationList->u8VPApplicationParameterNum = %d",
                 pstruWjVPApplicationList->u8VPApplicationParameterNum);
        return false;
    }
    for (u32i = 0; u32i < pstruWjVPApplicationList->u8VPApplicationParameterNum; u32i++)
    {
        pstruVPApplicationParameter_node = CALLOC(1, sizeof(VPApplicationParameter_t));
        if (NULL == pstruVPApplicationParameter_node)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_VPApplicationParameter_DfEnc(pstruVPApplicationParameter_node, &(pstruWjVPApplicationList->struVPApplicationParameter[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_Movement_DfEnc is err");
            FREEMEM(pstruVPApplicationParameter_node);
            return false;
        }
        asn_sequence_add(&(pstruAsnVPApplicationList->list), pstruVPApplicationParameter_node);
    }

    return true;
}
/**
* @brief     WJV2_VPApplicationList_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_VPApplicationList_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_VPApplicationList *pstruWjVPApplicationList = (WJV2_STRU_VPApplicationList *)pvoidWjDf;
    VPApplicationList_t *pstruAsnVPApplicationList = (VPApplicationList_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    uint32_t u32i = 0;
    if ((WJV2_MAX_LIST_VPApplicationParameter_LEN < pstruAsnVPApplicationList->list.count) ||
        (WJV2_MIN_LIST_VPApplicationParameter_LEN > pstruAsnVPApplicationList->list.count))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnVPApplicationList->list.count = %d",
                 pstruAsnVPApplicationList->list.count);
        return false;
    }
    for (u32i = 0; u32i < pstruAsnVPApplicationList->list.count; u32i++)
    {
        n32Ret = WJV2_VPApplicationParameter_DfDec(pstruAsnVPApplicationList->list.array[u32i], &(pstruWjVPApplicationList->struVPApplicationParameter[u32i]));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_VPApplicationParameter_DfDec is err");
            return false;
        }
    }
    pstruWjVPApplicationList->u8VPApplicationParameterNum = (uint8_t)u32i;

    return true;
}
/**
* @brief     WJV2_VPApplicationParameter_DfEnc编码函数
* @details   协议栈VPApplicationParameter编解码中 统一VPApplicationParameter的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_VPApplicationParameter_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_VPApplicationParameter *pstruWjVPApplicationParameter = (WJV2_STRU_VPApplicationParameter *)pvoidWjDf;
    VPApplicationParameter_t *pstruAsnVPApplicationParameter = (VPApplicationParameter_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    pstruAsnVPApplicationParameter->pid = pstruWjVPApplicationParameter->enumpid;
    n32Ret = WJV2_OBUPaymentInfo_DfEnc(&(pstruAsnVPApplicationParameter->obuPaymentInfo), &(pstruWjVPApplicationParameter->struobuPaymentInfo));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_OBUPaymentInfo_DfEnc is err");
        return false;
    }

    return true;
}
/**
* @brief     WJV2_VPApplicationParameter_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_VPApplicationParameter_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_VPApplicationParameter *pstruWjVPApplicationParameter = (WJV2_STRU_VPApplicationParameter *)pvoidWjDf;
    VPApplicationParameter_t *pstruAsnVPApplicationParameter = (VPApplicationParameter_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    pstruWjVPApplicationParameter->enumpid = pstruAsnVPApplicationParameter->pid;
    n32Ret = WJV2_OBUPaymentInfo_DfDec(&(pstruAsnVPApplicationParameter->obuPaymentInfo), &(pstruWjVPApplicationParameter->struobuPaymentInfo));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_OBUPaymentInfo_DfDec is err");
        return false;
    }

    return true;
}
/**
* @brief     WJV2_VSI_DfEnc编码函数
* @details   协议栈VSI编解码中 统一VSI的编码函数入口
* @param   [in]   void * pvoidAsnDf  编码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_VSI_DfEnc(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_VSI *pstruWjVSI = (WJV2_STRU_VSI *)pvoidWjDf;
    VSI_t *pstruAsnVSI = (VSI_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_DDateTime_DfEnc(&(pstruAsnVSI->time), &(pstruWjVSI->strutime));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_DDateTime_DfEnc is err");
        return false;
    }
    pstruAsnVSI->obuId.size = WJV2_MAX_OCTobuId_SIZE;
    pstruAsnVSI->obuId.buf = CALLOC(1, pstruAsnVSI->obuId.size);
    if (NULL == pstruAsnVSI->obuId.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "CALLOC is err");
        return false;
    }
    memcpy(pstruAsnVSI->obuId.buf, pstruWjVSI->u8OCTobuId, pstruAsnVSI->obuId.size);
    if (WJV2_PRESENT == pstruWjVSI->u8targetIdPresent)
    {
        pstruAsnVSI->targetId = CALLOC(1, sizeof(OCTET_STRING_t));
        if (NULL == pstruAsnVSI->targetId)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        pstruAsnVSI->targetId->size = WJV2_MAX_OCTtargetId_SIZE;
        pstruAsnVSI->targetId->buf = CALLOC(1, pstruAsnVSI->targetId->size);
        if (NULL == pstruAsnVSI->targetId->buf)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        memcpy(pstruAsnVSI->targetId->buf, pstruWjVSI->u8OCTtargetId, pstruAsnVSI->targetId->size);
    }
    else
    {
        pstruAsnVSI->targetId = NULL;
    }
    if (WJV2_PRESENT == pstruWjVSI->u8vpapplicationListPresent)
    {
        pstruAsnVSI->vpapplicationList = CALLOC(1, sizeof(struct VPApplicationList));
        if (NULL == pstruAsnVSI->vpapplicationList)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_VPApplicationList_DfEnc(pstruAsnVSI->vpapplicationList, &(pstruWjVSI->struvpapplicationList));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_VPApplicationList_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnVSI->vpapplicationList = NULL;
    }
    if (WJV2_PRESENT == pstruWjVSI->u8obuInfoPresent)
    {
        pstruAsnVSI->obuInfo = CALLOC(1, sizeof(struct OBUInfo));
        if (NULL == pstruAsnVSI->obuInfo)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_OBUInfo_DfEnc(pstruAsnVSI->obuInfo, &(pstruWjVSI->struobuInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_OBUInfo_DfEnc is err");
            return false;
        }
    }
    else
    {
        pstruAsnVSI->obuInfo = NULL;
    }
    if (WJV2_PRESENT == pstruWjVSI->u8rndOBUPresent)
    {
        pstruAsnVSI->rndOBU = CALLOC(1, sizeof(RandStr8_t));
        if (NULL == pstruAsnVSI->rndOBU)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        n32Ret = WJV2_RandStr8_DeEnc(pstruAsnVSI->rndOBU, &(pstruWjVSI->strurndOBU));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_RandStr8_DeEnc is err");
            return false;
        }
    }
    return true;
}
/**
* @brief     WJV2_VSI_DfDec解码函数
* @details   协议栈编解码中 统一的解码函数入口
* @param   [in]   void * pvoidAsnDf  解码结构
* @param   [in]   void * pvoidWjDf   WJ结构
* @return      本函数返回执行结果
*                  若成功则返回   true
*                  否则返回      false
* @author      guofenghe
* @par 修改日志:
* <table>
* <tr><th>Date        <th>Version  <th>Author    <th>Description
* <tr><td>2021-01-04  <td>1.0      <td>guofenghe  <td>创建初始版本
* </table>
*/
int32_t WJV2_VSI_DfDec(void *pvoidAsnDf, void *pvoidWjDf)
{
    if ((NULL == pvoidAsnDf) || (NULL == pvoidWjDf))
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_MSG_MODULE,
                 "input is null:pvoidAsnDf = %p pvoidWjDf = %p",
                 pvoidAsnDf, pvoidWjDf);
        return false;
    }
    WJV2_STRU_VSI *pstruWjVSI = (WJV2_STRU_VSI *)pvoidWjDf;
    VSI_t *pstruAsnVSI = (VSI_t *)pvoidAsnDf;
    int32_t n32Ret = 0;
    n32Ret = WJV2_DDateTime_DfDec(&(pstruAsnVSI->time), &(pstruWjVSI->strutime));
    if (true != n32Ret)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "WJV2_DDateTime_DfDec is err");
        return false;
    }
    if ((WJV2_MAX_OCTobuId_SIZE != pstruAsnVSI->obuId.size) /*||
        (1 > pstruAsnVSI->obuId.size)*/
    )
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "out of rangth:pstruAsnVSI->obuId.size = %d",
                 pstruAsnVSI->obuId.size);
        return false;
    }
    if (NULL == pstruAsnVSI->obuId.buf)
    {
        LogPrint(LOG_LEVEL_ERR,
                 STACK_DF_MODULE,
                 "obuId.buf is NULL");
        return false;
    }
    memcpy(pstruWjVSI->u8OCTobuId, pstruAsnVSI->obuId.buf, pstruAsnVSI->obuId.size);
    if (NULL != pstruAsnVSI->targetId)
    {
        if ((WJV2_MAX_OCTtargetId_SIZE != pstruAsnVSI->targetId->size) /*||
            (1 > pstruAsnVSI->targetId->size)*/
        )
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "out of rangth:pstruAsnVSI->targetId->size = %d",
                     pstruAsnVSI->targetId->size);
            return false;
        }
        if (NULL == pstruAsnVSI->targetId->buf)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "CALLOC is err");
            return false;
        }
        memcpy(pstruWjVSI->u8OCTtargetId, pstruAsnVSI->targetId->buf, pstruAsnVSI->targetId->size);
        pstruWjVSI->u8targetIdPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjVSI->u8targetIdPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnVSI->obuInfo)
    {
        n32Ret = WJV2_OBUInfo_DfDec(pstruAsnVSI->obuInfo, &(pstruWjVSI->struobuInfo));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_OBUInfo_DfDec is err");
            return false;
        }
        pstruWjVSI->u8obuInfoPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjVSI->u8obuInfoPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnVSI->vpapplicationList)
    {
        n32Ret = WJV2_VPApplicationList_DfDec(pstruAsnVSI->vpapplicationList, &(pstruWjVSI->struvpapplicationList));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_VPApplicationList_DfDec is err");
            return false;
        }
        pstruWjVSI->u8vpapplicationListPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjVSI->u8vpapplicationListPresent = WJV2_ABSENT;
    }
    if (NULL != pstruAsnVSI->rndOBU)
    {
        n32Ret = WJV2_RandStr8_DeDec(pstruAsnVSI->rndOBU, &(pstruWjVSI->strurndOBU));
        if (true != n32Ret)
        {
            LogPrint(LOG_LEVEL_ERR,
                     STACK_DF_MODULE,
                     "WJV2_OBUInfo_DfDec is err");
            return false;
        }
        pstruWjVSI->u8rndOBUPresent = WJV2_PRESENT;
    }
    else
    {
        pstruWjVSI->u8rndOBUPresent = WJV2_ABSENT;
    }
    return true;
}
/***** 文件结束 *****/